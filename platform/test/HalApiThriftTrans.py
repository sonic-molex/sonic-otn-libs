import os
import sys
import shutil

g_basicTypes = ['bool', 'i8', 'i16', 'i32', 'i64', 'double', 'string', 'binary']
g_containTypes = ['list']

g_typeMap = {
    'bool': 'bool',
    'char': 'i8',
    'int8_t': 'i8',
    'int16_t': 'i16',
    'int32_t': 'i32',
    'int64_t': 'i64',
    'uint8_t': 'i8',
    'uint16_t': 'i16',
    'uint32_t': 'i32',
    'uint64_t': 'i32',
    'float': 'double',
    'double': 'double'
}

g_pathGen = './gen-thrift'
g_pathGenApi = g_pathGen + '/HalApi.thrift'
g_pathGenConv = g_pathGen + "/Convert.h"
g_pathInc = '../../shasta/libs/hal/api_lib/inc'


def FindFile(path):
    return os.path.exists(path)


def RemoveFolder(path):
    if os.path.exists(path):
        shutil.rmtree(path)


def CreateFolder(path):
    if not os.path.exists(path):
        os.mkdir(path)


def CopyFiles(filelist, dir):
    for files in filelist:
        for file in files:
            shutil.copy(file, dir)


def ListFiles(path, apis):
    files = {}
    list = os.listdir(path)
    for i in list:
        p = os.path.join(path, i)
        if os.path.isfile(p):
            if i.find('Api.h') != -1:
                files[i] = p
    for i in sorted(files.keys()):
        apis[i] = files[i]


def StrFind(str, tar):
    if str.find(tar) == -1:
        return False
    return True


def IsNullStr(str):
    if str is None:
        return True
    if str.isspace():
        return True
    if str == '':
        return True
    return False


def DelComment(str):
    str = str.strip()
    start = str.find(r'//')
    if start == 0:
        return None
    if start > 0:
        return str[:start].strip()

    start = str.find(r'/*')
    if start == -1:
        return str
    if start > 0:
        return str[:start].strip()
    end = str.find(r'*/')
    return str[(end + 2):].strip()


def ReplaceStructLine(index, line):
    isChar = False
    #delete ;
    line = line.strip(' ;')
    typeIndex = line.find(' ')
    arraySize = line.count('[')
    arrayIndex = line.find('[')
    isArray = False if arrayIndex == -1 else True
    if isArray:
        line = line[:arrayIndex]

    bitIndex = line.find(':')
    if bitIndex > 0:
        line = line[:bitIndex].strip()

    typeName = line[:typeIndex].strip()
    varName = line[typeIndex:].strip()

    convType = None
    finalType = None
    finalArray = False

    for k, v in g_typeMap.items():
        if typeName.lower() == k:
            convType = k
            if isArray:
                if k == 'char':
                    finalType = 'string'
                elif v == 'i8':
                    finalType = 'binary'
                else:
                    finalType = ''
                    for i in range(arraySize):
                        finalType += 'list<'
                    finalType += v
                    for i in range(arraySize):
                        finalType += '>'
                    finalArray = True
            else:
                finalType = v
            break

    isStruct = False
    isEnum = False
    if finalType is None:
        if StrFind(typeName, 'EN_'):
            convType = 'int32_t'
            finalType = 'i32'
            isEnum = True
        elif isArray:
            convType = typeName + '_t'
            finalType = ''
            for i in range(arraySize):
                finalType += 'list<'
            finalType += convType
            for i in range(arraySize):
                finalType += '>'
            finalArray = True
            isStruct = True
        else:
            finalType =  convType = typeName + '_t'
            isStruct = True

    convType = convType.replace('uint', 'int')

    return {'index': str(index), 'type': [finalType, typeName, convType], 'name': varName, 'isArray': finalArray, 'arraySize': arraySize, 'isStruct': isStruct, 'isEnum': isEnum}


def ParseStructNames(str):
    index = 0
    if str.find('struct ') == 0:
        index = len('struct')
    else:
        index = str.find('}')
    str = str[(index + 1):]
    str = str.strip(' ;')
    if IsNullStr(str):
        return None

    if StrFind(str, '__attribute__'):
        index = str.find(' ')
        str = str[(index + 1):]

    old = str.split(',')
    new = []
    for str in old:
        new.append(str.strip() + '_t')

    return new


def ParseIncludeFile(str):
    index = str.find('"')
    str = str[(index + 1):]
    index = str.find('"')
    str = str[:index]
    return str.strip()


def WriteThriftTitle(f, prefix, title):
    f.write('\n')
    f.write(prefix)
    f.write('/* ')
    f.write(title)
    f.write(' */\n\n')


def WriteConvertHead(incs):
    with open(g_pathGenConv, 'a') as f:
        f.write('/* AUTOGENERATED FILE! DO NOT EDIT */\n\n')
        f.write('#pragma once\n\n')

        f.write('#include <string.h>\n\n')

        for k in incs.keys():
            f.write('#include "' + k + '"\n')
        f.write('#include "HalApi_types.h"\n\n\n')
        f.write('class Convert {\n')
        f.write('public:\n')


def WriteConvertTail():
    with open(g_pathGenConv, 'a') as f:
        f.write('};\n')


def WriteStructText(fa, fc, type, names, lines, structs):
    #if len(names) < 1 or len(lines) < 1:
    if len(names) < 1:
        return

    for name in names:
        structs.append(name)
        #thrift api file
        fa.write(type + ' ' + name + ' {\n')
        if len(lines) > 0:
            fa.write('    ')
            fa.write(lines[0]['index'] + ': ' + lines[0]['type'][0] + ' ' + lines[0]['name'])
            for line in lines[1:]:
                fa.write(',\n    ' + line['index'] + ': ' + line['type'][0] + ' ' + line['name'])
        fa.write('\n}\n\n')

        #C struct convert to thrift struct
        fc.write('    static void To' + name + '(' + name + ' &dest, const ' + name[:-2] + ' &src) {\n')
        for line in lines:
            #print(line)
            if line['isArray']:
                spaceText = '    '
                arrayName = 'src.' + line['name']
                for arrayIndex in range(line['arraySize']):
                    varName = 'i' + str(arrayIndex)
                    if arrayIndex > 0:
                        arrayName += '[i' + str(arrayIndex - 1) + ']'
                    spaceText += '    '
                    if arrayIndex > 0:
                        fc.write(spaceText)
                        for arrayIndex1 in range(line['arraySize'] - arrayIndex):
                            fc.write('std::vector<')
                        fc.write(line['type'][2])
                        for arrayIndex1 in range(line['arraySize'] - arrayIndex):
                            fc.write('>')
                        fc.write(' temp' + str(arrayIndex) + ';\n')
                    fc.write(spaceText)
                    fc.write('for (size_t ' + varName + ' = 0; ' + varName + ' < sizeof(' + arrayName + ') / sizeof(' + arrayName + '[0]); ' + varName +'++) {\n')

                for arrayIndex in range(line['arraySize'], 0, -1):
                    if line['isStruct']:
                        if arrayIndex == line['arraySize']:
                            orgType = line['type'][2]
                            fc.write(spaceText)
                            fc.write('    ' + orgType + ' temp' + str(arrayIndex) + ';\n')
                            fc.write(spaceText)
                            varName = line['name']
                            for arrayIndex1 in range(line['arraySize']):
                                varName += '[i' + str(arrayIndex1) + ']'
                            fc.write('    To' + orgType + '(temp' + str(arrayIndex) + ', src.' + varName + ');\n')
                        fc.write(spaceText)
                        if arrayIndex > 1:
                            fc.write('    temp' + str(arrayIndex - 1) + '.push_back(temp' + str(arrayIndex) + ');\n')
                        else:
                            fc.write('    dest.' + line['name'] + '.push_back(temp' + str(arrayIndex) + ');\n')

                    else:
                        fc.write(spaceText)
                        #varName = 'srcline['name']
                        #for arrayIndex1 in range(line['arraySize'] - 1):
                        #    varName += '[i' + str(arrayIndex1) + ']'
                        if line['arraySize'] == 1:
                            fc.write('    dest.' + line['name'] + '.push_back(' + arrayName + '[i' + str(arrayIndex - 1) + ']);\n')
                        elif arrayIndex > 1:
                            fc.write('    temp' + str(arrayIndex - 1) + '.push_back(' + arrayName + '[i' + str(arrayIndex - 1) + ']);\n')
                        else:
                            fc.write('    dest.' + line['name'] + '.push_back(temp' + str(arrayIndex) + ');\n')

                    fc.write(spaceText)
                    fc.write('}\n')
                    spaceText = spaceText.replace('    ', '', 1)

            elif line['isStruct']:
                fc.write('        To' + line['type'][0] + '(dest.' + line['name'] + ', src.' + line['name'] + ');\n')
            elif line['type'][0] == 'binary':
                varName = 'size_' + line['name']
                fc.write('        size_t ' + varName + ' = sizeof(src.' + line['name'] + ');\n')
                fc.write('        dest.' + line['name'] + '.resize(' + varName + ');\n')
                fc.write('        memcpy(&dest.' + line['name'] + '[0], src.' + line['name'] + ', ' + varName + ');\n')
            elif line['isEnum']:
                fc.write('        dest.' + line['name'] + ' = (' + line['type'][2] + ')src.' + line['name'] + ';\n')
            else:
                fc.write('        dest.' + line['name'] + ' = src.' + line['name'] + ';\n')
            
            if type == 'union':
                break

        fc.write('        return;\n')
        fc.write('    }\n\n')

        #thrift struct convert to C struct
        fc.write('    static void To' + name[:-2] + '(' + name[:-2] + ' &dest, const ' + name + ' &src) {\n')
        for line in lines:
            if line['isArray']:
                spaceText = '    '
                arrayName = line['name']
                for arrayIndex in range(line['arraySize']):
                    spaceText += '    '
                    varName = 'i' + str(arrayIndex)
                    if arrayIndex > 0:
                        arrayName += '[i' + str(arrayIndex - 1) + ']'
                    fc.write(spaceText)
                    fc.write('for (size_t ' + varName + ' = 0; ' + varName + ' < src.' + arrayName + '.size(); ' + varName +'++) {\n')

                if line['isStruct']:
                    orgType = line['type'][1]
                    fc.write(spaceText)
                    fc.write('    To' + orgType + '(dest.' + arrayName + '[' + varName + '], src.' + arrayName + '[' + varName + ']);\n')
                elif line['type'][0] == 'string':
                    fc.write(spaceText)
                    fc.write('    memset(&dest.' + arrayName + '[' + varName + '], 0, sizeof(dest.' + arrayName + '[' + varName + ']));\n')
                    fc.write(spaceText)
                    fc.write('    memcpy(&dest.' + arrayName + '[' + varName + '], src.' + arrayName + '[' + varName + '].data(), src.' + arrayName + '[' + varName + '].length());\n')
                else:
                    fc.write(spaceText)
                    fc.write('    dest.' + arrayName + '[' + varName + '] = src.' + arrayName + '[' + varName + '];\n')

                for arrayIndex in range(line['arraySize']):
                    fc.write(spaceText)
                    fc.write('}\n')
                    spaceText = spaceText.replace('    ', '', 1)


            elif line['isStruct']:
                fc.write('        To' + line['type'][1] + '(dest.' + line['name'] + ', src.' + line['name'] + ');\n')
            elif line['type'][0] == 'binary' or line['type'][0] == 'string':
                fc.write('        memset(dest.' + line['name'] + ', 0, sizeof(dest.' + line['name'] + '));\n')
                fc.write('        memcpy(dest.' + line['name'] + ', src.' + line['name'] + '.data(), src.' + line['name'] + '.length());\n')
            elif line['isEnum']:
                fc.write('        dest.' + line['name'] + ' = (' + line['type'][1] + ')src.' + line['name'] + ';\n')
            else:
                fc.write('        dest.' + line['name'] + ' = src.' + line['name'] + ';\n')

            if type == 'union':
                break

        fc.write('        return;\n')
        fc.write('    }\n\n')


def ParseData(name, path, files, marks, structs):
    if not (name in files.keys()):
        return

    if marks[name] == 1:
        return

    marks[name] = 1

    print('Processing ',name,'...')
    commentEnable = True
    macroEnable = True
    index = 0
    parseStart = False
    parseType = 'struct'
    parseLines = []
    parseNames = []

    with open(g_pathGenApi, 'a') as wga, open(g_pathGenConv, 'a') as wgc:
        WriteThriftTitle(wga, '', name)

        with open(path, 'r', errors='ignore') as rf:
            for line in rf.readlines():
                #find the comment /* for multiple lines
                if StrFind(line, '/*') and not StrFind(line, '*/'):
                    commentEnable = False
                    continue
                if StrFind(line, '*/') and not StrFind(line, '/*'):
                    commentEnable = True
                    continue
                if not commentEnable:
                    continue

                #find the pre macro #if
                if StrFind(line, '#if 1') or StrFind(line, '#endif'):
                    macroEnable = True
                    continue
                if StrFind(line, '#if 0'):
                    macroEnable = False
                    continue
                if StrFind(line, '#else'):
                    macroEnable = not macroEnable
                    continue
                if not macroEnable:
                    continue

                #delete the comment
                str = DelComment(line)
                if IsNullStr(str):
                    continue

                #print(commentEnable, macroEnable, str)

                if StrFind(str, '#include'):
                    jumpFile = ParseIncludeFile(str)
                    ParseData(jumpFile, files[jumpFile], files, marks, structs)
                    continue

                if StrFind(str, 'typedef struct') or StrFind(str, 'typedef union'):
                    parseStart = True
                    index = 1
                    parseType = 'union' if StrFind(str, 'typedef union') else 'struct'
                    continue


                if not parseStart and (str.find('struct ') == 0 or str.find('union ') == 0):
                    parseStart = True
                    index = 1
                    parseType = 'union' if StrFind(str, 'union ') else 'struct'
                    parseNames = ParseStructNames(str)
                    continue

                if parseStart:
                    if (StrFind(str, '{')):
                        continue
                    if (StrFind(str, '}')):
                        parseStart = False
                        tempNames = ParseStructNames(str)
                        if tempNames is not None:
                            parseNames = tempNames

                        WriteStructText(wga, wgc, parseType, parseNames, parseLines, structs)
                        parseNames.clear()
                        parseLines.clear()
                        continue
                    if StrFind(str, '#if'):
                        continue

                    parseLines.append(ReplaceStructLine(index, str))
                    index = index + 1
                    continue

def AddStructRsp(structs):
    with open(g_pathGenApi, 'a') as wf:
        wf.write('\n/* Struct response define */\n\n')
        for name in structs:
            wf.write('struct ' + name.replace('_t', '_rsp') + ' {\n')
            wf.write('    1: i32 response,\n')
            wf.write('    2: ' + name + ' data\n}\n\n')


def AddBasicTypeRsp():
    with open(g_pathGenApi, 'a') as wf:
        wf.write('\n/* Basic types response define */\n\n')
        for v in g_basicTypes:
            wf.write('struct ' + v + '_rsp {\n')
            wf.write('    1: i32 response,\n')
            wf.write('    2: ' + v + ' data\n}\n\n')

            if v == 'binary':
                continue

            #contain
            for c in g_containTypes:
                wf.write('struct ' + v + '_' + c + '_rsp {\n')
                wf.write('    1: i32 response,\n')
                if v == 'i8' and c == 'list':
                    wf.write('    2: binary data\n}\n\n')
                else:
                    wf.write('    2: ' + c + '<' + v + '> data\n}\n\n')


def WriteApiHead():
    with open(g_pathGenApi, 'a') as wf:
        wf.write('/* service define */\n\n')
        wf.write('service HalApi {\n')

def WriteApiTail():
    with open(g_pathGenApi, 'a') as wf:
        wf.write('}\n')


def ParseApi(name, path):
    print('Processing ',name,'...')

    commentEnable = True
    macroEnable = True

    with open(g_pathGenApi, 'a') as wf:
        WriteThriftTitle(wf, '    ', name)

        with open(path, 'r', errors='ignore') as rf:
            for line in rf.readlines():

                #find the comment /* for multiple lines
                if StrFind(line, '/*') and not StrFind(line, '*/'):
                    commentEnable = False
                    continue
                if StrFind(line, '*/') and not StrFind(line, '/*'):
                    commentEnable = True
                    continue
                if not commentEnable:
                    continue

                #find the pre macro #if
                if StrFind(line, '#if 1') or StrFind(line, '#endif'):
                    macroEnable = True
                    continue
                if StrFind(line, '#if 0'):
                    macroEnable = False
                    continue
                if StrFind(line, '#else'):
                    macroEnable = not macroEnable
                    continue
                if not macroEnable:
                    continue

                #delete the comment
                str = DelComment(line)
                if IsNullStr(str):
                    continue

                #Copy functions
                if StrFind(str, '(') and StrFind(str, ');') :
                    wf.write(r'    //')
                    wf.write(str)
                    wf.write('\n\n')


def FilterDataFiles(files):
    setFiles = set()
    for file in files.values():
        commentEnable = True
        macroEnable = True
        with open(file, 'r', errors='ignore') as rf:
            for line in rf.readlines():
                #find the comment /* for multiple lines
                if StrFind(line, '/*') and not StrFind(line, '*/'):
                    commentEnable = False
                    continue
                if StrFind(line, '*/') and not StrFind(line, '/*'):
                    commentEnable = True
                    continue
                if not commentEnable:
                    continue

                #find the pre macro #if
                if StrFind(line, '#if 1') or StrFind(line, '#endif'):
                    macroEnable = True
                    continue
                if StrFind(line, '#if 0'):
                    macroEnable = False
                    continue
                if StrFind(line, '#else'):
                    macroEnable = not macroEnable
                    continue
                if not macroEnable:
                    continue

                #delete the comment
                str = DelComment(line)
                if IsNullStr(str):
                    continue

                if StrFind(str, '#include'):
                    incFile = ParseIncludeFile(str)
                    setFiles.add(incFile)

    incFiles = {}
    for file in setFiles: 
        path = g_pathInc + '/' + file
        if FindFile(path):
            incFiles[file] = g_pathInc + '/' + file
    return incFiles


def main(argv):
    RemoveFolder(g_pathGen)
    CreateFolder(g_pathGen)

    apiFiles = {}
    ListFiles(g_pathInc, apiFiles)
    #print(apiFiles)

    dataFiles = FilterDataFiles(apiFiles)

    #data
    markFiles = {}
    for k in dataFiles.keys():
        markFiles[k] = 0

    markStructs = []
    WriteConvertHead(apiFiles)
    firstProFile = 'DevData.h'
    for k, v in dataFiles.items():
        if k == firstProFile:
            ParseData(k, v, dataFiles, markFiles, markStructs)
            break
    for k, v in dataFiles.items():
        if k == firstProFile:
            continue
        ParseData(k, v, dataFiles, markFiles, markStructs)

    WriteConvertTail()
    AddStructRsp(markStructs)
    AddBasicTypeRsp()

    #api
    WriteApiHead()
    for k, v in apiFiles.items():
        ParseApi(k, v)
    WriteApiTail()

    print('completed')


if __name__ == "__main__":
    main(sys.argv)