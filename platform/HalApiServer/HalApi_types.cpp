/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "HalApi_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




CLedCfg_t::~CLedCfg_t() noexcept {
}


void CLedCfg_t::__set_uiState(const int32_t val) {
  this->uiState = val;
}
std::ostream& operator<<(std::ostream& out, const CLedCfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CLedCfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiState);
          this->__isset.uiState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLedCfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLedCfg_t");

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLedCfg_t &a, CLedCfg_t &b) {
  using ::std::swap;
  swap(a.uiState, b.uiState);
  swap(a.__isset, b.__isset);
}

CLedCfg_t::CLedCfg_t(const CLedCfg_t& other0) {
  uiState = other0.uiState;
  __isset = other0.__isset;
}
CLedCfg_t& CLedCfg_t::operator=(const CLedCfg_t& other1) {
  uiState = other1.uiState;
  __isset = other1.__isset;
  return *this;
}
void CLedCfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLedCfg_t(";
  out << "uiState=" << to_string(uiState);
  out << ")";
}


CLedSta_t::~CLedSta_t() noexcept {
}


void CLedSta_t::__set_uiState(const int32_t val) {
  this->uiState = val;
}
std::ostream& operator<<(std::ostream& out, const CLedSta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CLedSta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiState);
          this->__isset.uiState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLedSta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLedSta_t");

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLedSta_t &a, CLedSta_t &b) {
  using ::std::swap;
  swap(a.uiState, b.uiState);
  swap(a.__isset, b.__isset);
}

CLedSta_t::CLedSta_t(const CLedSta_t& other2) {
  uiState = other2.uiState;
  __isset = other2.__isset;
}
CLedSta_t& CLedSta_t::operator=(const CLedSta_t& other3) {
  uiState = other3.uiState;
  __isset = other3.__isset;
  return *this;
}
void CLedSta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLedSta_t(";
  out << "uiState=" << to_string(uiState);
  out << ")";
}


CMfg_t::~CMfg_t() noexcept {
}


void CMfg_t::__set_acManufacturer(const std::string& val) {
  this->acManufacturer = val;
}

void CMfg_t::__set_acProductName(const std::string& val) {
  this->acProductName = val;
}

void CMfg_t::__set_acModuleType(const std::string& val) {
  this->acModuleType = val;
}

void CMfg_t::__set_acBootVer(const std::string& val) {
  this->acBootVer = val;
}

void CMfg_t::__set_acSwVer(const std::string& val) {
  this->acSwVer = val;
}

void CMfg_t::__set_acFwVer(const std::string& val) {
  this->acFwVer = val;
}

void CMfg_t::__set_acFpgaRunVer(const std::string& val) {
  this->acFpgaRunVer = val;
}

void CMfg_t::__set_acFpga1Ver(const std::string& val) {
  this->acFpga1Ver = val;
}

void CMfg_t::__set_acFpga2Ver(const std::string& val) {
  this->acFpga2Ver = val;
}

void CMfg_t::__set_acCpldRunVer(const std::string& val) {
  this->acCpldRunVer = val;
}

void CMfg_t::__set_acCpld1Ver(const std::string& val) {
  this->acCpld1Ver = val;
}

void CMfg_t::__set_acCpld2Ver(const std::string& val) {
  this->acCpld2Ver = val;
}

void CMfg_t::__set_acHwVer(const std::string& val) {
  this->acHwVer = val;
}

void CMfg_t::__set_acHwFuncRev(const std::string& val) {
  this->acHwFuncRev = val;
}

void CMfg_t::__set_acPcbRev(const std::string& val) {
  this->acPcbRev = val;
}

void CMfg_t::__set_acSN(const std::string& val) {
  this->acSN = val;
}

void CMfg_t::__set_acPN(const std::string& val) {
  this->acPN = val;
}

void CMfg_t::__set_acMfgDate(const std::string& val) {
  this->acMfgDate = val;
}

void CMfg_t::__set_acCaliDate(const std::string& val) {
  this->acCaliDate = val;
}

void CMfg_t::__set_acCleiCode(const std::string& val) {
  this->acCleiCode = val;
}

void CMfg_t::__set_acSubBdlVer(const std::string& val) {
  this->acSubBdlVer = val;
}

void CMfg_t::__set_acEepromVer(const std::string& val) {
  this->acEepromVer = val;
}

void CMfg_t::__set_acEth0Mac(const std::string& val) {
  this->acEth0Mac = val;
}

void CMfg_t::__set_acEth1Mac(const std::string& val) {
  this->acEth1Mac = val;
}

void CMfg_t::__set_acEth2Mac(const std::string& val) {
  this->acEth2Mac = val;
}

void CMfg_t::__set_acEth3Mac(const std::string& val) {
  this->acEth3Mac = val;
}

void CMfg_t::__set_acEth4Mac(const std::string& val) {
  this->acEth4Mac = val;
}

void CMfg_t::__set_acEth5Mac(const std::string& val) {
  this->acEth5Mac = val;
}

void CMfg_t::__set_acEth6Mac(const std::string& val) {
  this->acEth6Mac = val;
}

void CMfg_t::__set_acEth7Mac(const std::string& val) {
  this->acEth7Mac = val;
}

void CMfg_t::__set_acEth8Mac(const std::string& val) {
  this->acEth8Mac = val;
}

void CMfg_t::__set_acEth9Mac(const std::string& val) {
  this->acEth9Mac = val;
}

void CMfg_t::__set_acUnitName(const std::string& val) {
  this->acUnitName = val;
}

void CMfg_t::__set_acFCPN(const std::string& val) {
  this->acFCPN = val;
}

void CMfg_t::__set_acFCIss(const std::string& val) {
  this->acFCIss = val;
}

void CMfg_t::__set_acFujitsuPN(const std::string& val) {
  this->acFujitsuPN = val;
}

void CMfg_t::__set_acConfigType(const std::string& val) {
  this->acConfigType = val;
}

void CMfg_t::__set_acFjtSn(const std::string& val) {
  this->acFjtSn = val;
}

void CMfg_t::__set_acResv(const std::string& val) {
  this->acResv = val;
}
std::ostream& operator<<(std::ostream& out, const CMfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acManufacturer);
          this->__isset.acManufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acProductName);
          this->__isset.acProductName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acModuleType);
          this->__isset.acModuleType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acBootVer);
          this->__isset.acBootVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acSwVer);
          this->__isset.acSwVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFwVer);
          this->__isset.acFwVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFpgaRunVer);
          this->__isset.acFpgaRunVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFpga1Ver);
          this->__isset.acFpga1Ver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFpga2Ver);
          this->__isset.acFpga2Ver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acCpldRunVer);
          this->__isset.acCpldRunVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acCpld1Ver);
          this->__isset.acCpld1Ver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acCpld2Ver);
          this->__isset.acCpld2Ver = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acHwVer);
          this->__isset.acHwVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acHwFuncRev);
          this->__isset.acHwFuncRev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acPcbRev);
          this->__isset.acPcbRev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acSN);
          this->__isset.acSN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acPN);
          this->__isset.acPN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acMfgDate);
          this->__isset.acMfgDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acCaliDate);
          this->__isset.acCaliDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acCleiCode);
          this->__isset.acCleiCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acSubBdlVer);
          this->__isset.acSubBdlVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEepromVer);
          this->__isset.acEepromVer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth0Mac);
          this->__isset.acEth0Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth1Mac);
          this->__isset.acEth1Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth2Mac);
          this->__isset.acEth2Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth3Mac);
          this->__isset.acEth3Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth4Mac);
          this->__isset.acEth4Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth5Mac);
          this->__isset.acEth5Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth6Mac);
          this->__isset.acEth6Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth7Mac);
          this->__isset.acEth7Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth8Mac);
          this->__isset.acEth8Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acEth9Mac);
          this->__isset.acEth9Mac = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acUnitName);
          this->__isset.acUnitName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFCPN);
          this->__isset.acFCPN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFCIss);
          this->__isset.acFCIss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFujitsuPN);
          this->__isset.acFujitsuPN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acConfigType);
          this->__isset.acConfigType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acFjtSn);
          this->__isset.acFjtSn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acResv);
          this->__isset.acResv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMfg_t");

  xfer += oprot->writeFieldBegin("acManufacturer", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->acManufacturer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acProductName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->acProductName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acModuleType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->acModuleType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acBootVer", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->acBootVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acSwVer", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->acSwVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFwVer", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->acFwVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFpgaRunVer", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->acFpgaRunVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFpga1Ver", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->acFpga1Ver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFpga2Ver", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->acFpga2Ver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acCpldRunVer", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->acCpldRunVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acCpld1Ver", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->acCpld1Ver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acCpld2Ver", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->acCpld2Ver);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acHwVer", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->acHwVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acHwFuncRev", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->acHwFuncRev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acPcbRev", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->acPcbRev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acSN", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->acSN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acPN", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->acPN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acMfgDate", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->acMfgDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acCaliDate", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->acCaliDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acCleiCode", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->acCleiCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acSubBdlVer", ::apache::thrift::protocol::T_STRING, 21);
  xfer += oprot->writeString(this->acSubBdlVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEepromVer", ::apache::thrift::protocol::T_STRING, 22);
  xfer += oprot->writeString(this->acEepromVer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth0Mac", ::apache::thrift::protocol::T_STRING, 23);
  xfer += oprot->writeString(this->acEth0Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth1Mac", ::apache::thrift::protocol::T_STRING, 24);
  xfer += oprot->writeString(this->acEth1Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth2Mac", ::apache::thrift::protocol::T_STRING, 25);
  xfer += oprot->writeString(this->acEth2Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth3Mac", ::apache::thrift::protocol::T_STRING, 26);
  xfer += oprot->writeString(this->acEth3Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth4Mac", ::apache::thrift::protocol::T_STRING, 27);
  xfer += oprot->writeString(this->acEth4Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth5Mac", ::apache::thrift::protocol::T_STRING, 28);
  xfer += oprot->writeString(this->acEth5Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth6Mac", ::apache::thrift::protocol::T_STRING, 29);
  xfer += oprot->writeString(this->acEth6Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth7Mac", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->acEth7Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth8Mac", ::apache::thrift::protocol::T_STRING, 31);
  xfer += oprot->writeString(this->acEth8Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acEth9Mac", ::apache::thrift::protocol::T_STRING, 32);
  xfer += oprot->writeString(this->acEth9Mac);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acUnitName", ::apache::thrift::protocol::T_STRING, 33);
  xfer += oprot->writeString(this->acUnitName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFCPN", ::apache::thrift::protocol::T_STRING, 34);
  xfer += oprot->writeString(this->acFCPN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFCIss", ::apache::thrift::protocol::T_STRING, 35);
  xfer += oprot->writeString(this->acFCIss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFujitsuPN", ::apache::thrift::protocol::T_STRING, 36);
  xfer += oprot->writeString(this->acFujitsuPN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acConfigType", ::apache::thrift::protocol::T_STRING, 37);
  xfer += oprot->writeString(this->acConfigType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acFjtSn", ::apache::thrift::protocol::T_STRING, 38);
  xfer += oprot->writeString(this->acFjtSn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acResv", ::apache::thrift::protocol::T_STRING, 39);
  xfer += oprot->writeString(this->acResv);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMfg_t &a, CMfg_t &b) {
  using ::std::swap;
  swap(a.acManufacturer, b.acManufacturer);
  swap(a.acProductName, b.acProductName);
  swap(a.acModuleType, b.acModuleType);
  swap(a.acBootVer, b.acBootVer);
  swap(a.acSwVer, b.acSwVer);
  swap(a.acFwVer, b.acFwVer);
  swap(a.acFpgaRunVer, b.acFpgaRunVer);
  swap(a.acFpga1Ver, b.acFpga1Ver);
  swap(a.acFpga2Ver, b.acFpga2Ver);
  swap(a.acCpldRunVer, b.acCpldRunVer);
  swap(a.acCpld1Ver, b.acCpld1Ver);
  swap(a.acCpld2Ver, b.acCpld2Ver);
  swap(a.acHwVer, b.acHwVer);
  swap(a.acHwFuncRev, b.acHwFuncRev);
  swap(a.acPcbRev, b.acPcbRev);
  swap(a.acSN, b.acSN);
  swap(a.acPN, b.acPN);
  swap(a.acMfgDate, b.acMfgDate);
  swap(a.acCaliDate, b.acCaliDate);
  swap(a.acCleiCode, b.acCleiCode);
  swap(a.acSubBdlVer, b.acSubBdlVer);
  swap(a.acEepromVer, b.acEepromVer);
  swap(a.acEth0Mac, b.acEth0Mac);
  swap(a.acEth1Mac, b.acEth1Mac);
  swap(a.acEth2Mac, b.acEth2Mac);
  swap(a.acEth3Mac, b.acEth3Mac);
  swap(a.acEth4Mac, b.acEth4Mac);
  swap(a.acEth5Mac, b.acEth5Mac);
  swap(a.acEth6Mac, b.acEth6Mac);
  swap(a.acEth7Mac, b.acEth7Mac);
  swap(a.acEth8Mac, b.acEth8Mac);
  swap(a.acEth9Mac, b.acEth9Mac);
  swap(a.acUnitName, b.acUnitName);
  swap(a.acFCPN, b.acFCPN);
  swap(a.acFCIss, b.acFCIss);
  swap(a.acFujitsuPN, b.acFujitsuPN);
  swap(a.acConfigType, b.acConfigType);
  swap(a.acFjtSn, b.acFjtSn);
  swap(a.acResv, b.acResv);
  swap(a.__isset, b.__isset);
}

CMfg_t::CMfg_t(const CMfg_t& other4) {
  acManufacturer = other4.acManufacturer;
  acProductName = other4.acProductName;
  acModuleType = other4.acModuleType;
  acBootVer = other4.acBootVer;
  acSwVer = other4.acSwVer;
  acFwVer = other4.acFwVer;
  acFpgaRunVer = other4.acFpgaRunVer;
  acFpga1Ver = other4.acFpga1Ver;
  acFpga2Ver = other4.acFpga2Ver;
  acCpldRunVer = other4.acCpldRunVer;
  acCpld1Ver = other4.acCpld1Ver;
  acCpld2Ver = other4.acCpld2Ver;
  acHwVer = other4.acHwVer;
  acHwFuncRev = other4.acHwFuncRev;
  acPcbRev = other4.acPcbRev;
  acSN = other4.acSN;
  acPN = other4.acPN;
  acMfgDate = other4.acMfgDate;
  acCaliDate = other4.acCaliDate;
  acCleiCode = other4.acCleiCode;
  acSubBdlVer = other4.acSubBdlVer;
  acEepromVer = other4.acEepromVer;
  acEth0Mac = other4.acEth0Mac;
  acEth1Mac = other4.acEth1Mac;
  acEth2Mac = other4.acEth2Mac;
  acEth3Mac = other4.acEth3Mac;
  acEth4Mac = other4.acEth4Mac;
  acEth5Mac = other4.acEth5Mac;
  acEth6Mac = other4.acEth6Mac;
  acEth7Mac = other4.acEth7Mac;
  acEth8Mac = other4.acEth8Mac;
  acEth9Mac = other4.acEth9Mac;
  acUnitName = other4.acUnitName;
  acFCPN = other4.acFCPN;
  acFCIss = other4.acFCIss;
  acFujitsuPN = other4.acFujitsuPN;
  acConfigType = other4.acConfigType;
  acFjtSn = other4.acFjtSn;
  acResv = other4.acResv;
  __isset = other4.__isset;
}
CMfg_t& CMfg_t::operator=(const CMfg_t& other5) {
  acManufacturer = other5.acManufacturer;
  acProductName = other5.acProductName;
  acModuleType = other5.acModuleType;
  acBootVer = other5.acBootVer;
  acSwVer = other5.acSwVer;
  acFwVer = other5.acFwVer;
  acFpgaRunVer = other5.acFpgaRunVer;
  acFpga1Ver = other5.acFpga1Ver;
  acFpga2Ver = other5.acFpga2Ver;
  acCpldRunVer = other5.acCpldRunVer;
  acCpld1Ver = other5.acCpld1Ver;
  acCpld2Ver = other5.acCpld2Ver;
  acHwVer = other5.acHwVer;
  acHwFuncRev = other5.acHwFuncRev;
  acPcbRev = other5.acPcbRev;
  acSN = other5.acSN;
  acPN = other5.acPN;
  acMfgDate = other5.acMfgDate;
  acCaliDate = other5.acCaliDate;
  acCleiCode = other5.acCleiCode;
  acSubBdlVer = other5.acSubBdlVer;
  acEepromVer = other5.acEepromVer;
  acEth0Mac = other5.acEth0Mac;
  acEth1Mac = other5.acEth1Mac;
  acEth2Mac = other5.acEth2Mac;
  acEth3Mac = other5.acEth3Mac;
  acEth4Mac = other5.acEth4Mac;
  acEth5Mac = other5.acEth5Mac;
  acEth6Mac = other5.acEth6Mac;
  acEth7Mac = other5.acEth7Mac;
  acEth8Mac = other5.acEth8Mac;
  acEth9Mac = other5.acEth9Mac;
  acUnitName = other5.acUnitName;
  acFCPN = other5.acFCPN;
  acFCIss = other5.acFCIss;
  acFujitsuPN = other5.acFujitsuPN;
  acConfigType = other5.acConfigType;
  acFjtSn = other5.acFjtSn;
  acResv = other5.acResv;
  __isset = other5.__isset;
  return *this;
}
void CMfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMfg_t(";
  out << "acManufacturer=" << to_string(acManufacturer);
  out << ", " << "acProductName=" << to_string(acProductName);
  out << ", " << "acModuleType=" << to_string(acModuleType);
  out << ", " << "acBootVer=" << to_string(acBootVer);
  out << ", " << "acSwVer=" << to_string(acSwVer);
  out << ", " << "acFwVer=" << to_string(acFwVer);
  out << ", " << "acFpgaRunVer=" << to_string(acFpgaRunVer);
  out << ", " << "acFpga1Ver=" << to_string(acFpga1Ver);
  out << ", " << "acFpga2Ver=" << to_string(acFpga2Ver);
  out << ", " << "acCpldRunVer=" << to_string(acCpldRunVer);
  out << ", " << "acCpld1Ver=" << to_string(acCpld1Ver);
  out << ", " << "acCpld2Ver=" << to_string(acCpld2Ver);
  out << ", " << "acHwVer=" << to_string(acHwVer);
  out << ", " << "acHwFuncRev=" << to_string(acHwFuncRev);
  out << ", " << "acPcbRev=" << to_string(acPcbRev);
  out << ", " << "acSN=" << to_string(acSN);
  out << ", " << "acPN=" << to_string(acPN);
  out << ", " << "acMfgDate=" << to_string(acMfgDate);
  out << ", " << "acCaliDate=" << to_string(acCaliDate);
  out << ", " << "acCleiCode=" << to_string(acCleiCode);
  out << ", " << "acSubBdlVer=" << to_string(acSubBdlVer);
  out << ", " << "acEepromVer=" << to_string(acEepromVer);
  out << ", " << "acEth0Mac=" << to_string(acEth0Mac);
  out << ", " << "acEth1Mac=" << to_string(acEth1Mac);
  out << ", " << "acEth2Mac=" << to_string(acEth2Mac);
  out << ", " << "acEth3Mac=" << to_string(acEth3Mac);
  out << ", " << "acEth4Mac=" << to_string(acEth4Mac);
  out << ", " << "acEth5Mac=" << to_string(acEth5Mac);
  out << ", " << "acEth6Mac=" << to_string(acEth6Mac);
  out << ", " << "acEth7Mac=" << to_string(acEth7Mac);
  out << ", " << "acEth8Mac=" << to_string(acEth8Mac);
  out << ", " << "acEth9Mac=" << to_string(acEth9Mac);
  out << ", " << "acUnitName=" << to_string(acUnitName);
  out << ", " << "acFCPN=" << to_string(acFCPN);
  out << ", " << "acFCIss=" << to_string(acFCIss);
  out << ", " << "acFujitsuPN=" << to_string(acFujitsuPN);
  out << ", " << "acConfigType=" << to_string(acConfigType);
  out << ", " << "acFjtSn=" << to_string(acFjtSn);
  out << ", " << "acResv=" << to_string(acResv);
  out << ")";
}


CCali_t::~CCali_t() noexcept {
}


void CCali_t::__set_sLineInToPaIn(const int16_t val) {
  this->sLineInToPaIn = val;
}

void CCali_t::__set_sLineInToBaIn(const int16_t val) {
  this->sLineInToBaIn = val;
}

void CCali_t::__set_sPaOutToLineOut(const int16_t val) {
  this->sPaOutToLineOut = val;
}

void CCali_t::__set_sBaOutToLineOut(const int16_t val) {
  this->sBaOutToLineOut = val;
}

void CCali_t::__set_asRsv1(const std::vector<int16_t> & val) {
  this->asRsv1 = val;
}

void CCali_t::__set_sPaInToOcm(const int16_t val) {
  this->sPaInToOcm = val;
}

void CCali_t::__set_sPaOutToOcm(const int16_t val) {
  this->sPaOutToOcm = val;
}

void CCali_t::__set_sBaInToOcm(const int16_t val) {
  this->sBaInToOcm = val;
}

void CCali_t::__set_sBaOutToOcm(const int16_t val) {
  this->sBaOutToOcm = val;
}

void CCali_t::__set_sWss1InToOcm(const int16_t val) {
  this->sWss1InToOcm = val;
}

void CCali_t::__set_sWss1OutToOcm(const int16_t val) {
  this->sWss1OutToOcm = val;
}

void CCali_t::__set_sWss2InToOcm(const int16_t val) {
  this->sWss2InToOcm = val;
}

void CCali_t::__set_sWss2OutToOcm(const int16_t val) {
  this->sWss2OutToOcm = val;
}

void CCali_t::__set_sLineInToOsc1Drop(const int16_t val) {
  this->sLineInToOsc1Drop = val;
}

void CCali_t::__set_sOsc1AddToLineOut(const int16_t val) {
  this->sOsc1AddToLineOut = val;
}

void CCali_t::__set_sLineInToOsc1Rx(const int16_t val) {
  this->sLineInToOsc1Rx = val;
}

void CCali_t::__set_sOsc1TxToLineOut(const int16_t val) {
  this->sOsc1TxToLineOut = val;
}

void CCali_t::__set_sLineInToOsc2Drop(const int16_t val) {
  this->sLineInToOsc2Drop = val;
}

void CCali_t::__set_sOsc2AddToLineOut(const int16_t val) {
  this->sOsc2AddToLineOut = val;
}

void CCali_t::__set_sLineInToOsc2Rx(const int16_t val) {
  this->sLineInToOsc2Rx = val;
}

void CCali_t::__set_sOsc2TxToLineOut(const int16_t val) {
  this->sOsc2TxToLineOut = val;
}

void CCali_t::__set_sMirrorTxToMuxIn(const int16_t val) {
  this->sMirrorTxToMuxIn = val;
}

void CCali_t::__set_sMirrorTxToDemuxIn(const int16_t val) {
  this->sMirrorTxToDemuxIn = val;
}

void CCali_t::__set_sMuxInToMirrorRx(const int16_t val) {
  this->sMuxInToMirrorRx = val;
}

void CCali_t::__set_sDemuxInToMirrorRx(const int16_t val) {
  this->sDemuxInToMirrorRx = val;
}

void CCali_t::__set_sOcmPortToOcm(const int16_t val) {
  this->sOcmPortToOcm = val;
}

void CCali_t::__set_asRsv4(const std::vector<int16_t> & val) {
  this->asRsv4 = val;
}

void CCali_t::__set_asExpInToBaIn(const std::vector<int16_t> & val) {
  this->asExpInToBaIn = val;
}

void CCali_t::__set_asRsv5(const std::vector<int16_t> & val) {
  this->asRsv5 = val;
}

void CCali_t::__set_asPaOutToExpOut(const std::vector<int16_t> & val) {
  this->asPaOutToExpOut = val;
}

void CCali_t::__set_asRsv6(const std::vector<int16_t> & val) {
  this->asRsv6 = val;
}

void CCali_t::__set_asRsv7(const std::vector<int16_t> & val) {
  this->asRsv7 = val;
}
std::ostream& operator<<(std::ostream& out, const CCali_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCali_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLineInToPaIn);
          this->__isset.sLineInToPaIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLineInToBaIn);
          this->__isset.sLineInToBaIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sPaOutToLineOut);
          this->__isset.sPaOutToLineOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sBaOutToLineOut);
          this->__isset.sBaOutToLineOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asRsv1.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->asRsv1.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readI16(this->asRsv1[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asRsv1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sPaInToOcm);
          this->__isset.sPaInToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sPaOutToOcm);
          this->__isset.sPaOutToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sBaInToOcm);
          this->__isset.sBaInToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sBaOutToOcm);
          this->__isset.sBaOutToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sWss1InToOcm);
          this->__isset.sWss1InToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sWss1OutToOcm);
          this->__isset.sWss1OutToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sWss2InToOcm);
          this->__isset.sWss2InToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sWss2OutToOcm);
          this->__isset.sWss2OutToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLineInToOsc1Drop);
          this->__isset.sLineInToOsc1Drop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOsc1AddToLineOut);
          this->__isset.sOsc1AddToLineOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLineInToOsc1Rx);
          this->__isset.sLineInToOsc1Rx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOsc1TxToLineOut);
          this->__isset.sOsc1TxToLineOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLineInToOsc2Drop);
          this->__isset.sLineInToOsc2Drop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOsc2AddToLineOut);
          this->__isset.sOsc2AddToLineOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLineInToOsc2Rx);
          this->__isset.sLineInToOsc2Rx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOsc2TxToLineOut);
          this->__isset.sOsc2TxToLineOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMirrorTxToMuxIn);
          this->__isset.sMirrorTxToMuxIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMirrorTxToDemuxIn);
          this->__isset.sMirrorTxToDemuxIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMuxInToMirrorRx);
          this->__isset.sMuxInToMirrorRx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDemuxInToMirrorRx);
          this->__isset.sDemuxInToMirrorRx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOcmPortToOcm);
          this->__isset.sOcmPortToOcm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asRsv4.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->asRsv4.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += iprot->readI16(this->asRsv4[_i15]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asRsv4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asExpInToBaIn.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->asExpInToBaIn.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readI16(this->asExpInToBaIn[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asExpInToBaIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asRsv5.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->asRsv5.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readI16(this->asRsv5[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asRsv5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPaOutToExpOut.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->asPaOutToExpOut.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readI16(this->asPaOutToExpOut[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPaOutToExpOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asRsv6.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->asRsv6.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += iprot->readI16(this->asRsv6[_i35]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asRsv6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asRsv7.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->asRsv7.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readI16(this->asRsv7[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asRsv7 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCali_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCali_t");

  xfer += oprot->writeFieldBegin("sLineInToPaIn", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sLineInToPaIn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sLineInToBaIn", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sLineInToBaIn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sPaOutToLineOut", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sPaOutToLineOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sBaOutToLineOut", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sBaOutToLineOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asRsv1", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asRsv1.size()));
    std::vector<int16_t> ::const_iterator _iter41;
    for (_iter41 = this->asRsv1.begin(); _iter41 != this->asRsv1.end(); ++_iter41)
    {
      xfer += oprot->writeI16((*_iter41));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sPaInToOcm", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->sPaInToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sPaOutToOcm", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->sPaOutToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sBaInToOcm", ::apache::thrift::protocol::T_I16, 8);
  xfer += oprot->writeI16(this->sBaInToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sBaOutToOcm", ::apache::thrift::protocol::T_I16, 9);
  xfer += oprot->writeI16(this->sBaOutToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sWss1InToOcm", ::apache::thrift::protocol::T_I16, 10);
  xfer += oprot->writeI16(this->sWss1InToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sWss1OutToOcm", ::apache::thrift::protocol::T_I16, 11);
  xfer += oprot->writeI16(this->sWss1OutToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sWss2InToOcm", ::apache::thrift::protocol::T_I16, 12);
  xfer += oprot->writeI16(this->sWss2InToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sWss2OutToOcm", ::apache::thrift::protocol::T_I16, 13);
  xfer += oprot->writeI16(this->sWss2OutToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sLineInToOsc1Drop", ::apache::thrift::protocol::T_I16, 14);
  xfer += oprot->writeI16(this->sLineInToOsc1Drop);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOsc1AddToLineOut", ::apache::thrift::protocol::T_I16, 15);
  xfer += oprot->writeI16(this->sOsc1AddToLineOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sLineInToOsc1Rx", ::apache::thrift::protocol::T_I16, 16);
  xfer += oprot->writeI16(this->sLineInToOsc1Rx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOsc1TxToLineOut", ::apache::thrift::protocol::T_I16, 17);
  xfer += oprot->writeI16(this->sOsc1TxToLineOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sLineInToOsc2Drop", ::apache::thrift::protocol::T_I16, 18);
  xfer += oprot->writeI16(this->sLineInToOsc2Drop);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOsc2AddToLineOut", ::apache::thrift::protocol::T_I16, 19);
  xfer += oprot->writeI16(this->sOsc2AddToLineOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sLineInToOsc2Rx", ::apache::thrift::protocol::T_I16, 20);
  xfer += oprot->writeI16(this->sLineInToOsc2Rx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOsc2TxToLineOut", ::apache::thrift::protocol::T_I16, 21);
  xfer += oprot->writeI16(this->sOsc2TxToLineOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMirrorTxToMuxIn", ::apache::thrift::protocol::T_I16, 22);
  xfer += oprot->writeI16(this->sMirrorTxToMuxIn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMirrorTxToDemuxIn", ::apache::thrift::protocol::T_I16, 23);
  xfer += oprot->writeI16(this->sMirrorTxToDemuxIn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMuxInToMirrorRx", ::apache::thrift::protocol::T_I16, 24);
  xfer += oprot->writeI16(this->sMuxInToMirrorRx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDemuxInToMirrorRx", ::apache::thrift::protocol::T_I16, 25);
  xfer += oprot->writeI16(this->sDemuxInToMirrorRx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOcmPortToOcm", ::apache::thrift::protocol::T_I16, 26);
  xfer += oprot->writeI16(this->sOcmPortToOcm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asRsv4", ::apache::thrift::protocol::T_LIST, 27);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asRsv4.size()));
    std::vector<int16_t> ::const_iterator _iter42;
    for (_iter42 = this->asRsv4.begin(); _iter42 != this->asRsv4.end(); ++_iter42)
    {
      xfer += oprot->writeI16((*_iter42));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asExpInToBaIn", ::apache::thrift::protocol::T_LIST, 28);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asExpInToBaIn.size()));
    std::vector<int16_t> ::const_iterator _iter43;
    for (_iter43 = this->asExpInToBaIn.begin(); _iter43 != this->asExpInToBaIn.end(); ++_iter43)
    {
      xfer += oprot->writeI16((*_iter43));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asRsv5", ::apache::thrift::protocol::T_LIST, 29);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asRsv5.size()));
    std::vector<int16_t> ::const_iterator _iter44;
    for (_iter44 = this->asRsv5.begin(); _iter44 != this->asRsv5.end(); ++_iter44)
    {
      xfer += oprot->writeI16((*_iter44));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPaOutToExpOut", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPaOutToExpOut.size()));
    std::vector<int16_t> ::const_iterator _iter45;
    for (_iter45 = this->asPaOutToExpOut.begin(); _iter45 != this->asPaOutToExpOut.end(); ++_iter45)
    {
      xfer += oprot->writeI16((*_iter45));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asRsv6", ::apache::thrift::protocol::T_LIST, 31);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asRsv6.size()));
    std::vector<int16_t> ::const_iterator _iter46;
    for (_iter46 = this->asRsv6.begin(); _iter46 != this->asRsv6.end(); ++_iter46)
    {
      xfer += oprot->writeI16((*_iter46));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asRsv7", ::apache::thrift::protocol::T_LIST, 32);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asRsv7.size()));
    std::vector<int16_t> ::const_iterator _iter47;
    for (_iter47 = this->asRsv7.begin(); _iter47 != this->asRsv7.end(); ++_iter47)
    {
      xfer += oprot->writeI16((*_iter47));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCali_t &a, CCali_t &b) {
  using ::std::swap;
  swap(a.sLineInToPaIn, b.sLineInToPaIn);
  swap(a.sLineInToBaIn, b.sLineInToBaIn);
  swap(a.sPaOutToLineOut, b.sPaOutToLineOut);
  swap(a.sBaOutToLineOut, b.sBaOutToLineOut);
  swap(a.asRsv1, b.asRsv1);
  swap(a.sPaInToOcm, b.sPaInToOcm);
  swap(a.sPaOutToOcm, b.sPaOutToOcm);
  swap(a.sBaInToOcm, b.sBaInToOcm);
  swap(a.sBaOutToOcm, b.sBaOutToOcm);
  swap(a.sWss1InToOcm, b.sWss1InToOcm);
  swap(a.sWss1OutToOcm, b.sWss1OutToOcm);
  swap(a.sWss2InToOcm, b.sWss2InToOcm);
  swap(a.sWss2OutToOcm, b.sWss2OutToOcm);
  swap(a.sLineInToOsc1Drop, b.sLineInToOsc1Drop);
  swap(a.sOsc1AddToLineOut, b.sOsc1AddToLineOut);
  swap(a.sLineInToOsc1Rx, b.sLineInToOsc1Rx);
  swap(a.sOsc1TxToLineOut, b.sOsc1TxToLineOut);
  swap(a.sLineInToOsc2Drop, b.sLineInToOsc2Drop);
  swap(a.sOsc2AddToLineOut, b.sOsc2AddToLineOut);
  swap(a.sLineInToOsc2Rx, b.sLineInToOsc2Rx);
  swap(a.sOsc2TxToLineOut, b.sOsc2TxToLineOut);
  swap(a.sMirrorTxToMuxIn, b.sMirrorTxToMuxIn);
  swap(a.sMirrorTxToDemuxIn, b.sMirrorTxToDemuxIn);
  swap(a.sMuxInToMirrorRx, b.sMuxInToMirrorRx);
  swap(a.sDemuxInToMirrorRx, b.sDemuxInToMirrorRx);
  swap(a.sOcmPortToOcm, b.sOcmPortToOcm);
  swap(a.asRsv4, b.asRsv4);
  swap(a.asExpInToBaIn, b.asExpInToBaIn);
  swap(a.asRsv5, b.asRsv5);
  swap(a.asPaOutToExpOut, b.asPaOutToExpOut);
  swap(a.asRsv6, b.asRsv6);
  swap(a.asRsv7, b.asRsv7);
  swap(a.__isset, b.__isset);
}

CCali_t::CCali_t(const CCali_t& other48) {
  sLineInToPaIn = other48.sLineInToPaIn;
  sLineInToBaIn = other48.sLineInToBaIn;
  sPaOutToLineOut = other48.sPaOutToLineOut;
  sBaOutToLineOut = other48.sBaOutToLineOut;
  asRsv1 = other48.asRsv1;
  sPaInToOcm = other48.sPaInToOcm;
  sPaOutToOcm = other48.sPaOutToOcm;
  sBaInToOcm = other48.sBaInToOcm;
  sBaOutToOcm = other48.sBaOutToOcm;
  sWss1InToOcm = other48.sWss1InToOcm;
  sWss1OutToOcm = other48.sWss1OutToOcm;
  sWss2InToOcm = other48.sWss2InToOcm;
  sWss2OutToOcm = other48.sWss2OutToOcm;
  sLineInToOsc1Drop = other48.sLineInToOsc1Drop;
  sOsc1AddToLineOut = other48.sOsc1AddToLineOut;
  sLineInToOsc1Rx = other48.sLineInToOsc1Rx;
  sOsc1TxToLineOut = other48.sOsc1TxToLineOut;
  sLineInToOsc2Drop = other48.sLineInToOsc2Drop;
  sOsc2AddToLineOut = other48.sOsc2AddToLineOut;
  sLineInToOsc2Rx = other48.sLineInToOsc2Rx;
  sOsc2TxToLineOut = other48.sOsc2TxToLineOut;
  sMirrorTxToMuxIn = other48.sMirrorTxToMuxIn;
  sMirrorTxToDemuxIn = other48.sMirrorTxToDemuxIn;
  sMuxInToMirrorRx = other48.sMuxInToMirrorRx;
  sDemuxInToMirrorRx = other48.sDemuxInToMirrorRx;
  sOcmPortToOcm = other48.sOcmPortToOcm;
  asRsv4 = other48.asRsv4;
  asExpInToBaIn = other48.asExpInToBaIn;
  asRsv5 = other48.asRsv5;
  asPaOutToExpOut = other48.asPaOutToExpOut;
  asRsv6 = other48.asRsv6;
  asRsv7 = other48.asRsv7;
  __isset = other48.__isset;
}
CCali_t& CCali_t::operator=(const CCali_t& other49) {
  sLineInToPaIn = other49.sLineInToPaIn;
  sLineInToBaIn = other49.sLineInToBaIn;
  sPaOutToLineOut = other49.sPaOutToLineOut;
  sBaOutToLineOut = other49.sBaOutToLineOut;
  asRsv1 = other49.asRsv1;
  sPaInToOcm = other49.sPaInToOcm;
  sPaOutToOcm = other49.sPaOutToOcm;
  sBaInToOcm = other49.sBaInToOcm;
  sBaOutToOcm = other49.sBaOutToOcm;
  sWss1InToOcm = other49.sWss1InToOcm;
  sWss1OutToOcm = other49.sWss1OutToOcm;
  sWss2InToOcm = other49.sWss2InToOcm;
  sWss2OutToOcm = other49.sWss2OutToOcm;
  sLineInToOsc1Drop = other49.sLineInToOsc1Drop;
  sOsc1AddToLineOut = other49.sOsc1AddToLineOut;
  sLineInToOsc1Rx = other49.sLineInToOsc1Rx;
  sOsc1TxToLineOut = other49.sOsc1TxToLineOut;
  sLineInToOsc2Drop = other49.sLineInToOsc2Drop;
  sOsc2AddToLineOut = other49.sOsc2AddToLineOut;
  sLineInToOsc2Rx = other49.sLineInToOsc2Rx;
  sOsc2TxToLineOut = other49.sOsc2TxToLineOut;
  sMirrorTxToMuxIn = other49.sMirrorTxToMuxIn;
  sMirrorTxToDemuxIn = other49.sMirrorTxToDemuxIn;
  sMuxInToMirrorRx = other49.sMuxInToMirrorRx;
  sDemuxInToMirrorRx = other49.sDemuxInToMirrorRx;
  sOcmPortToOcm = other49.sOcmPortToOcm;
  asRsv4 = other49.asRsv4;
  asExpInToBaIn = other49.asExpInToBaIn;
  asRsv5 = other49.asRsv5;
  asPaOutToExpOut = other49.asPaOutToExpOut;
  asRsv6 = other49.asRsv6;
  asRsv7 = other49.asRsv7;
  __isset = other49.__isset;
  return *this;
}
void CCali_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCali_t(";
  out << "sLineInToPaIn=" << to_string(sLineInToPaIn);
  out << ", " << "sLineInToBaIn=" << to_string(sLineInToBaIn);
  out << ", " << "sPaOutToLineOut=" << to_string(sPaOutToLineOut);
  out << ", " << "sBaOutToLineOut=" << to_string(sBaOutToLineOut);
  out << ", " << "asRsv1=" << to_string(asRsv1);
  out << ", " << "sPaInToOcm=" << to_string(sPaInToOcm);
  out << ", " << "sPaOutToOcm=" << to_string(sPaOutToOcm);
  out << ", " << "sBaInToOcm=" << to_string(sBaInToOcm);
  out << ", " << "sBaOutToOcm=" << to_string(sBaOutToOcm);
  out << ", " << "sWss1InToOcm=" << to_string(sWss1InToOcm);
  out << ", " << "sWss1OutToOcm=" << to_string(sWss1OutToOcm);
  out << ", " << "sWss2InToOcm=" << to_string(sWss2InToOcm);
  out << ", " << "sWss2OutToOcm=" << to_string(sWss2OutToOcm);
  out << ", " << "sLineInToOsc1Drop=" << to_string(sLineInToOsc1Drop);
  out << ", " << "sOsc1AddToLineOut=" << to_string(sOsc1AddToLineOut);
  out << ", " << "sLineInToOsc1Rx=" << to_string(sLineInToOsc1Rx);
  out << ", " << "sOsc1TxToLineOut=" << to_string(sOsc1TxToLineOut);
  out << ", " << "sLineInToOsc2Drop=" << to_string(sLineInToOsc2Drop);
  out << ", " << "sOsc2AddToLineOut=" << to_string(sOsc2AddToLineOut);
  out << ", " << "sLineInToOsc2Rx=" << to_string(sLineInToOsc2Rx);
  out << ", " << "sOsc2TxToLineOut=" << to_string(sOsc2TxToLineOut);
  out << ", " << "sMirrorTxToMuxIn=" << to_string(sMirrorTxToMuxIn);
  out << ", " << "sMirrorTxToDemuxIn=" << to_string(sMirrorTxToDemuxIn);
  out << ", " << "sMuxInToMirrorRx=" << to_string(sMuxInToMirrorRx);
  out << ", " << "sDemuxInToMirrorRx=" << to_string(sDemuxInToMirrorRx);
  out << ", " << "sOcmPortToOcm=" << to_string(sOcmPortToOcm);
  out << ", " << "asRsv4=" << to_string(asRsv4);
  out << ", " << "asExpInToBaIn=" << to_string(asExpInToBaIn);
  out << ", " << "asRsv5=" << to_string(asRsv5);
  out << ", " << "asPaOutToExpOut=" << to_string(asPaOutToExpOut);
  out << ", " << "asRsv6=" << to_string(asRsv6);
  out << ", " << "asRsv7=" << to_string(asRsv7);
  out << ")";
}


COscCfgData_t::~COscCfgData_t() noexcept {
}


void COscCfgData_t::__set_ucLaserEnable(const int8_t val) {
  this->ucLaserEnable = val;
}

void COscCfgData_t::__set_ucSwitch(const int8_t val) {
  this->ucSwitch = val;
}

void COscCfgData_t::__set_sRxThr(const int16_t val) {
  this->sRxThr = val;
}

void COscCfgData_t::__set_sRxHys(const int16_t val) {
  this->sRxHys = val;
}

void COscCfgData_t::__set_sTxThr(const int16_t val) {
  this->sTxThr = val;
}

void COscCfgData_t::__set_sTxHys(const int16_t val) {
  this->sTxHys = val;
}

void COscCfgData_t::__set_sAddThr(const int16_t val) {
  this->sAddThr = val;
}

void COscCfgData_t::__set_sAddHys(const int16_t val) {
  this->sAddHys = val;
}

void COscCfgData_t::__set_sDropThr(const int16_t val) {
  this->sDropThr = val;
}

void COscCfgData_t::__set_sDropHys(const int16_t val) {
  this->sDropHys = val;
}
std::ostream& operator<<(std::ostream& out, const COscCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucLaserEnable);
          this->__isset.ucLaserEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucSwitch);
          this->__isset.ucSwitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sRxThr);
          this->__isset.sRxThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sRxHys);
          this->__isset.sRxHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTxThr);
          this->__isset.sTxThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTxHys);
          this->__isset.sTxHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAddThr);
          this->__isset.sAddThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAddHys);
          this->__isset.sAddHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDropThr);
          this->__isset.sDropThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDropHys);
          this->__isset.sDropHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscCfgData_t");

  xfer += oprot->writeFieldBegin("ucLaserEnable", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucLaserEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucSwitch", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucSwitch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sRxThr", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sRxThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sRxHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sRxHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTxThr", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->sTxThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTxHys", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->sTxHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAddThr", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->sAddThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAddHys", ::apache::thrift::protocol::T_I16, 8);
  xfer += oprot->writeI16(this->sAddHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDropThr", ::apache::thrift::protocol::T_I16, 9);
  xfer += oprot->writeI16(this->sDropThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDropHys", ::apache::thrift::protocol::T_I16, 10);
  xfer += oprot->writeI16(this->sDropHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscCfgData_t &a, COscCfgData_t &b) {
  using ::std::swap;
  swap(a.ucLaserEnable, b.ucLaserEnable);
  swap(a.ucSwitch, b.ucSwitch);
  swap(a.sRxThr, b.sRxThr);
  swap(a.sRxHys, b.sRxHys);
  swap(a.sTxThr, b.sTxThr);
  swap(a.sTxHys, b.sTxHys);
  swap(a.sAddThr, b.sAddThr);
  swap(a.sAddHys, b.sAddHys);
  swap(a.sDropThr, b.sDropThr);
  swap(a.sDropHys, b.sDropHys);
  swap(a.__isset, b.__isset);
}

COscCfgData_t::COscCfgData_t(const COscCfgData_t& other50) {
  ucLaserEnable = other50.ucLaserEnable;
  ucSwitch = other50.ucSwitch;
  sRxThr = other50.sRxThr;
  sRxHys = other50.sRxHys;
  sTxThr = other50.sTxThr;
  sTxHys = other50.sTxHys;
  sAddThr = other50.sAddThr;
  sAddHys = other50.sAddHys;
  sDropThr = other50.sDropThr;
  sDropHys = other50.sDropHys;
  __isset = other50.__isset;
}
COscCfgData_t& COscCfgData_t::operator=(const COscCfgData_t& other51) {
  ucLaserEnable = other51.ucLaserEnable;
  ucSwitch = other51.ucSwitch;
  sRxThr = other51.sRxThr;
  sRxHys = other51.sRxHys;
  sTxThr = other51.sTxThr;
  sTxHys = other51.sTxHys;
  sAddThr = other51.sAddThr;
  sAddHys = other51.sAddHys;
  sDropThr = other51.sDropThr;
  sDropHys = other51.sDropHys;
  __isset = other51.__isset;
  return *this;
}
void COscCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscCfgData_t(";
  out << "ucLaserEnable=" << to_string(ucLaserEnable);
  out << ", " << "ucSwitch=" << to_string(ucSwitch);
  out << ", " << "sRxThr=" << to_string(sRxThr);
  out << ", " << "sRxHys=" << to_string(sRxHys);
  out << ", " << "sTxThr=" << to_string(sTxThr);
  out << ", " << "sTxHys=" << to_string(sTxHys);
  out << ", " << "sAddThr=" << to_string(sAddThr);
  out << ", " << "sAddHys=" << to_string(sAddHys);
  out << ", " << "sDropThr=" << to_string(sDropThr);
  out << ", " << "sDropHys=" << to_string(sDropHys);
  out << ")";
}


COscStatusData_t::~COscStatusData_t() noexcept {
}


void COscStatusData_t::__set_ucModStatus(const int8_t val) {
  this->ucModStatus = val;
}

void COscStatusData_t::__set_sRxPower(const int16_t val) {
  this->sRxPower = val;
}

void COscStatusData_t::__set_sTxPower(const int16_t val) {
  this->sTxPower = val;
}

void COscStatusData_t::__set_sAddPower(const int16_t val) {
  this->sAddPower = val;
}

void COscStatusData_t::__set_sDropPower(const int16_t val) {
  this->sDropPower = val;
}

void COscStatusData_t::__set_bFailure(const bool val) {
  this->bFailure = val;
}

void COscStatusData_t::__set_bInnerErr(const bool val) {
  this->bInnerErr = val;
}

void COscStatusData_t::__set_bOffLine(const bool val) {
  this->bOffLine = val;
}

void COscStatusData_t::__set_bRxLos(const bool val) {
  this->bRxLos = val;
}

void COscStatusData_t::__set_bTxLos(const bool val) {
  this->bTxLos = val;
}

void COscStatusData_t::__set_bAddLos(const bool val) {
  this->bAddLos = val;
}

void COscStatusData_t::__set_bDropLos(const bool val) {
  this->bDropLos = val;
}

void COscStatusData_t::__set_bLinkDown(const bool val) {
  this->bLinkDown = val;
}

void COscStatusData_t::__set_bMisMatch(const bool val) {
  this->bMisMatch = val;
}

void COscStatusData_t::__set_bRxLow(const bool val) {
  this->bRxLow = val;
}

void COscStatusData_t::__set_bTxLow(const bool val) {
  this->bTxLow = val;
}

void COscStatusData_t::__set_bAddLow(const bool val) {
  this->bAddLow = val;
}

void COscStatusData_t::__set_bDropLow(const bool val) {
  this->bDropLow = val;
}

void COscStatusData_t::__set_bRxHigh(const bool val) {
  this->bRxHigh = val;
}

void COscStatusData_t::__set_bTxHigh(const bool val) {
  this->bTxHigh = val;
}

void COscStatusData_t::__set_bAddHigh(const bool val) {
  this->bAddHigh = val;
}

void COscStatusData_t::__set_bDropHigh(const bool val) {
  this->bDropHigh = val;
}

void COscStatusData_t::__set_bLaserSafety(const bool val) {
  this->bLaserSafety = val;
}
std::ostream& operator<<(std::ostream& out, const COscStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucModStatus);
          this->__isset.ucModStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sRxPower);
          this->__isset.sRxPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTxPower);
          this->__isset.sTxPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAddPower);
          this->__isset.sAddPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDropPower);
          this->__isset.sDropPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bFailure);
          this->__isset.bFailure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bInnerErr);
          this->__isset.bInnerErr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOffLine);
          this->__isset.bOffLine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bRxLos);
          this->__isset.bRxLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bTxLos);
          this->__isset.bTxLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bAddLos);
          this->__isset.bAddLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bDropLos);
          this->__isset.bDropLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bLinkDown);
          this->__isset.bLinkDown = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bMisMatch);
          this->__isset.bMisMatch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bRxLow);
          this->__isset.bRxLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bTxLow);
          this->__isset.bTxLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bAddLow);
          this->__isset.bAddLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bDropLow);
          this->__isset.bDropLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bRxHigh);
          this->__isset.bRxHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bTxHigh);
          this->__isset.bTxHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bAddHigh);
          this->__isset.bAddHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bDropHigh);
          this->__isset.bDropHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bLaserSafety);
          this->__isset.bLaserSafety = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscStatusData_t");

  xfer += oprot->writeFieldBegin("ucModStatus", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucModStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sRxPower", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sRxPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTxPower", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sTxPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAddPower", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sAddPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDropPower", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->sDropPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bFailure", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->bFailure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bInnerErr", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->bInnerErr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOffLine", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->bOffLine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bRxLos", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->bRxLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bTxLos", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->bTxLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bAddLos", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->bAddLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bDropLos", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->bDropLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bLinkDown", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->bLinkDown);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bMisMatch", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->bMisMatch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bRxLow", ::apache::thrift::protocol::T_BOOL, 15);
  xfer += oprot->writeBool(this->bRxLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bTxLow", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->bTxLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bAddLow", ::apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->bAddLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bDropLow", ::apache::thrift::protocol::T_BOOL, 18);
  xfer += oprot->writeBool(this->bDropLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bRxHigh", ::apache::thrift::protocol::T_BOOL, 19);
  xfer += oprot->writeBool(this->bRxHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bTxHigh", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->bTxHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bAddHigh", ::apache::thrift::protocol::T_BOOL, 21);
  xfer += oprot->writeBool(this->bAddHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bDropHigh", ::apache::thrift::protocol::T_BOOL, 22);
  xfer += oprot->writeBool(this->bDropHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bLaserSafety", ::apache::thrift::protocol::T_BOOL, 23);
  xfer += oprot->writeBool(this->bLaserSafety);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscStatusData_t &a, COscStatusData_t &b) {
  using ::std::swap;
  swap(a.ucModStatus, b.ucModStatus);
  swap(a.sRxPower, b.sRxPower);
  swap(a.sTxPower, b.sTxPower);
  swap(a.sAddPower, b.sAddPower);
  swap(a.sDropPower, b.sDropPower);
  swap(a.bFailure, b.bFailure);
  swap(a.bInnerErr, b.bInnerErr);
  swap(a.bOffLine, b.bOffLine);
  swap(a.bRxLos, b.bRxLos);
  swap(a.bTxLos, b.bTxLos);
  swap(a.bAddLos, b.bAddLos);
  swap(a.bDropLos, b.bDropLos);
  swap(a.bLinkDown, b.bLinkDown);
  swap(a.bMisMatch, b.bMisMatch);
  swap(a.bRxLow, b.bRxLow);
  swap(a.bTxLow, b.bTxLow);
  swap(a.bAddLow, b.bAddLow);
  swap(a.bDropLow, b.bDropLow);
  swap(a.bRxHigh, b.bRxHigh);
  swap(a.bTxHigh, b.bTxHigh);
  swap(a.bAddHigh, b.bAddHigh);
  swap(a.bDropHigh, b.bDropHigh);
  swap(a.bLaserSafety, b.bLaserSafety);
  swap(a.__isset, b.__isset);
}

COscStatusData_t::COscStatusData_t(const COscStatusData_t& other52) {
  ucModStatus = other52.ucModStatus;
  sRxPower = other52.sRxPower;
  sTxPower = other52.sTxPower;
  sAddPower = other52.sAddPower;
  sDropPower = other52.sDropPower;
  bFailure = other52.bFailure;
  bInnerErr = other52.bInnerErr;
  bOffLine = other52.bOffLine;
  bRxLos = other52.bRxLos;
  bTxLos = other52.bTxLos;
  bAddLos = other52.bAddLos;
  bDropLos = other52.bDropLos;
  bLinkDown = other52.bLinkDown;
  bMisMatch = other52.bMisMatch;
  bRxLow = other52.bRxLow;
  bTxLow = other52.bTxLow;
  bAddLow = other52.bAddLow;
  bDropLow = other52.bDropLow;
  bRxHigh = other52.bRxHigh;
  bTxHigh = other52.bTxHigh;
  bAddHigh = other52.bAddHigh;
  bDropHigh = other52.bDropHigh;
  bLaserSafety = other52.bLaserSafety;
  __isset = other52.__isset;
}
COscStatusData_t& COscStatusData_t::operator=(const COscStatusData_t& other53) {
  ucModStatus = other53.ucModStatus;
  sRxPower = other53.sRxPower;
  sTxPower = other53.sTxPower;
  sAddPower = other53.sAddPower;
  sDropPower = other53.sDropPower;
  bFailure = other53.bFailure;
  bInnerErr = other53.bInnerErr;
  bOffLine = other53.bOffLine;
  bRxLos = other53.bRxLos;
  bTxLos = other53.bTxLos;
  bAddLos = other53.bAddLos;
  bDropLos = other53.bDropLos;
  bLinkDown = other53.bLinkDown;
  bMisMatch = other53.bMisMatch;
  bRxLow = other53.bRxLow;
  bTxLow = other53.bTxLow;
  bAddLow = other53.bAddLow;
  bDropLow = other53.bDropLow;
  bRxHigh = other53.bRxHigh;
  bTxHigh = other53.bTxHigh;
  bAddHigh = other53.bAddHigh;
  bDropHigh = other53.bDropHigh;
  bLaserSafety = other53.bLaserSafety;
  __isset = other53.__isset;
  return *this;
}
void COscStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscStatusData_t(";
  out << "ucModStatus=" << to_string(ucModStatus);
  out << ", " << "sRxPower=" << to_string(sRxPower);
  out << ", " << "sTxPower=" << to_string(sTxPower);
  out << ", " << "sAddPower=" << to_string(sAddPower);
  out << ", " << "sDropPower=" << to_string(sDropPower);
  out << ", " << "bFailure=" << to_string(bFailure);
  out << ", " << "bInnerErr=" << to_string(bInnerErr);
  out << ", " << "bOffLine=" << to_string(bOffLine);
  out << ", " << "bRxLos=" << to_string(bRxLos);
  out << ", " << "bTxLos=" << to_string(bTxLos);
  out << ", " << "bAddLos=" << to_string(bAddLos);
  out << ", " << "bDropLos=" << to_string(bDropLos);
  out << ", " << "bLinkDown=" << to_string(bLinkDown);
  out << ", " << "bMisMatch=" << to_string(bMisMatch);
  out << ", " << "bRxLow=" << to_string(bRxLow);
  out << ", " << "bTxLow=" << to_string(bTxLow);
  out << ", " << "bAddLow=" << to_string(bAddLow);
  out << ", " << "bDropLow=" << to_string(bDropLow);
  out << ", " << "bRxHigh=" << to_string(bRxHigh);
  out << ", " << "bTxHigh=" << to_string(bTxHigh);
  out << ", " << "bAddHigh=" << to_string(bAddHigh);
  out << ", " << "bDropHigh=" << to_string(bDropHigh);
  out << ", " << "bLaserSafety=" << to_string(bLaserSafety);
  out << ")";
}


COtdrCfgData_t::~COtdrCfgData_t() noexcept {
}


void COtdrCfgData_t::__set_ulScanCtrl(const int32_t val) {
  this->ulScanCtrl = val;
}

void COtdrCfgData_t::__set_ulScanMode(const int32_t val) {
  this->ulScanMode = val;
}

void COtdrCfgData_t::__set_ulExpScanTime(const int32_t val) {
  this->ulExpScanTime = val;
}

void COtdrCfgData_t::__set_ulExpPulseWidth(const int32_t val) {
  this->ulExpPulseWidth = val;
}

void COtdrCfgData_t::__set_ulScanStartPos(const int32_t val) {
  this->ulScanStartPos = val;
}

void COtdrCfgData_t::__set_ulScanEndPos(const int32_t val) {
  this->ulScanEndPos = val;
}

void COtdrCfgData_t::__set_fReflIdx(const double val) {
  this->fReflIdx = val;
}

void COtdrCfgData_t::__set_fReflEventThr(const double val) {
  this->fReflEventThr = val;
}

void COtdrCfgData_t::__set_fNonReflEventThr(const double val) {
  this->fNonReflEventThr = val;
}

void COtdrCfgData_t::__set_fFiberEndThr(const double val) {
  this->fFiberEndThr = val;
}

void COtdrCfgData_t::__set_fBackCoef(const double val) {
  this->fBackCoef = val;
}

void COtdrCfgData_t::__set_fOrlThr(const double val) {
  this->fOrlThr = val;
}

void COtdrCfgData_t::__set_fInputPwrThr(const double val) {
  this->fInputPwrThr = val;
}

void COtdrCfgData_t::__set_fReflEventFhThr(const double val) {
  this->fReflEventFhThr = val;
}

void COtdrCfgData_t::__set_fRamanSetpont(const double val) {
  this->fRamanSetpont = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulScanCtrl);
          this->__isset.ulScanCtrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulScanMode);
          this->__isset.ulScanMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulExpScanTime);
          this->__isset.ulExpScanTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulExpPulseWidth);
          this->__isset.ulExpPulseWidth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulScanStartPos);
          this->__isset.ulScanStartPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulScanEndPos);
          this->__isset.ulScanEndPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fReflIdx);
          this->__isset.fReflIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fReflEventThr);
          this->__isset.fReflEventThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fNonReflEventThr);
          this->__isset.fNonReflEventThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fFiberEndThr);
          this->__isset.fFiberEndThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fBackCoef);
          this->__isset.fBackCoef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fOrlThr);
          this->__isset.fOrlThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fInputPwrThr);
          this->__isset.fInputPwrThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fReflEventFhThr);
          this->__isset.fReflEventFhThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fRamanSetpont);
          this->__isset.fRamanSetpont = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrCfgData_t");

  xfer += oprot->writeFieldBegin("ulScanCtrl", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulScanCtrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulScanMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulScanMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulExpScanTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ulExpScanTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulExpPulseWidth", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->ulExpPulseWidth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulScanStartPos", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->ulScanStartPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulScanEndPos", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->ulScanEndPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fReflIdx", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->fReflIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fReflEventThr", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->fReflEventThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fNonReflEventThr", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->fNonReflEventThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fFiberEndThr", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->fFiberEndThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fBackCoef", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->fBackCoef);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fOrlThr", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->fOrlThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fInputPwrThr", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->fInputPwrThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fReflEventFhThr", ::apache::thrift::protocol::T_DOUBLE, 14);
  xfer += oprot->writeDouble(this->fReflEventFhThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fRamanSetpont", ::apache::thrift::protocol::T_DOUBLE, 15);
  xfer += oprot->writeDouble(this->fRamanSetpont);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrCfgData_t &a, COtdrCfgData_t &b) {
  using ::std::swap;
  swap(a.ulScanCtrl, b.ulScanCtrl);
  swap(a.ulScanMode, b.ulScanMode);
  swap(a.ulExpScanTime, b.ulExpScanTime);
  swap(a.ulExpPulseWidth, b.ulExpPulseWidth);
  swap(a.ulScanStartPos, b.ulScanStartPos);
  swap(a.ulScanEndPos, b.ulScanEndPos);
  swap(a.fReflIdx, b.fReflIdx);
  swap(a.fReflEventThr, b.fReflEventThr);
  swap(a.fNonReflEventThr, b.fNonReflEventThr);
  swap(a.fFiberEndThr, b.fFiberEndThr);
  swap(a.fBackCoef, b.fBackCoef);
  swap(a.fOrlThr, b.fOrlThr);
  swap(a.fInputPwrThr, b.fInputPwrThr);
  swap(a.fReflEventFhThr, b.fReflEventFhThr);
  swap(a.fRamanSetpont, b.fRamanSetpont);
  swap(a.__isset, b.__isset);
}

COtdrCfgData_t::COtdrCfgData_t(const COtdrCfgData_t& other54) {
  ulScanCtrl = other54.ulScanCtrl;
  ulScanMode = other54.ulScanMode;
  ulExpScanTime = other54.ulExpScanTime;
  ulExpPulseWidth = other54.ulExpPulseWidth;
  ulScanStartPos = other54.ulScanStartPos;
  ulScanEndPos = other54.ulScanEndPos;
  fReflIdx = other54.fReflIdx;
  fReflEventThr = other54.fReflEventThr;
  fNonReflEventThr = other54.fNonReflEventThr;
  fFiberEndThr = other54.fFiberEndThr;
  fBackCoef = other54.fBackCoef;
  fOrlThr = other54.fOrlThr;
  fInputPwrThr = other54.fInputPwrThr;
  fReflEventFhThr = other54.fReflEventFhThr;
  fRamanSetpont = other54.fRamanSetpont;
  __isset = other54.__isset;
}
COtdrCfgData_t& COtdrCfgData_t::operator=(const COtdrCfgData_t& other55) {
  ulScanCtrl = other55.ulScanCtrl;
  ulScanMode = other55.ulScanMode;
  ulExpScanTime = other55.ulExpScanTime;
  ulExpPulseWidth = other55.ulExpPulseWidth;
  ulScanStartPos = other55.ulScanStartPos;
  ulScanEndPos = other55.ulScanEndPos;
  fReflIdx = other55.fReflIdx;
  fReflEventThr = other55.fReflEventThr;
  fNonReflEventThr = other55.fNonReflEventThr;
  fFiberEndThr = other55.fFiberEndThr;
  fBackCoef = other55.fBackCoef;
  fOrlThr = other55.fOrlThr;
  fInputPwrThr = other55.fInputPwrThr;
  fReflEventFhThr = other55.fReflEventFhThr;
  fRamanSetpont = other55.fRamanSetpont;
  __isset = other55.__isset;
  return *this;
}
void COtdrCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrCfgData_t(";
  out << "ulScanCtrl=" << to_string(ulScanCtrl);
  out << ", " << "ulScanMode=" << to_string(ulScanMode);
  out << ", " << "ulExpScanTime=" << to_string(ulExpScanTime);
  out << ", " << "ulExpPulseWidth=" << to_string(ulExpPulseWidth);
  out << ", " << "ulScanStartPos=" << to_string(ulScanStartPos);
  out << ", " << "ulScanEndPos=" << to_string(ulScanEndPos);
  out << ", " << "fReflIdx=" << to_string(fReflIdx);
  out << ", " << "fReflEventThr=" << to_string(fReflEventThr);
  out << ", " << "fNonReflEventThr=" << to_string(fNonReflEventThr);
  out << ", " << "fFiberEndThr=" << to_string(fFiberEndThr);
  out << ", " << "fBackCoef=" << to_string(fBackCoef);
  out << ", " << "fOrlThr=" << to_string(fOrlThr);
  out << ", " << "fInputPwrThr=" << to_string(fInputPwrThr);
  out << ", " << "fReflEventFhThr=" << to_string(fReflEventFhThr);
  out << ", " << "fRamanSetpont=" << to_string(fRamanSetpont);
  out << ")";
}


COtdrEventTop_t::~COtdrEventTop_t() noexcept {
}


void COtdrEventTop_t::__set_ulCnt(const int32_t val) {
  this->ulCnt = val;
}

void COtdrEventTop_t::__set_dFiberLen(const double val) {
  this->dFiberLen = val;
}

void COtdrEventTop_t::__set_dTotalLoss(const double val) {
  this->dTotalLoss = val;
}

void COtdrEventTop_t::__set_dReturnLoss(const double val) {
  this->dReturnLoss = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrEventTop_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrEventTop_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulCnt);
          this->__isset.ulCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dFiberLen);
          this->__isset.dFiberLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dTotalLoss);
          this->__isset.dTotalLoss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dReturnLoss);
          this->__isset.dReturnLoss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrEventTop_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrEventTop_t");

  xfer += oprot->writeFieldBegin("ulCnt", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dFiberLen", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->dFiberLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dTotalLoss", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dTotalLoss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dReturnLoss", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->dReturnLoss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrEventTop_t &a, COtdrEventTop_t &b) {
  using ::std::swap;
  swap(a.ulCnt, b.ulCnt);
  swap(a.dFiberLen, b.dFiberLen);
  swap(a.dTotalLoss, b.dTotalLoss);
  swap(a.dReturnLoss, b.dReturnLoss);
  swap(a.__isset, b.__isset);
}

COtdrEventTop_t::COtdrEventTop_t(const COtdrEventTop_t& other56) {
  ulCnt = other56.ulCnt;
  dFiberLen = other56.dFiberLen;
  dTotalLoss = other56.dTotalLoss;
  dReturnLoss = other56.dReturnLoss;
  __isset = other56.__isset;
}
COtdrEventTop_t& COtdrEventTop_t::operator=(const COtdrEventTop_t& other57) {
  ulCnt = other57.ulCnt;
  dFiberLen = other57.dFiberLen;
  dTotalLoss = other57.dTotalLoss;
  dReturnLoss = other57.dReturnLoss;
  __isset = other57.__isset;
  return *this;
}
void COtdrEventTop_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrEventTop_t(";
  out << "ulCnt=" << to_string(ulCnt);
  out << ", " << "dFiberLen=" << to_string(dFiberLen);
  out << ", " << "dTotalLoss=" << to_string(dTotalLoss);
  out << ", " << "dReturnLoss=" << to_string(dReturnLoss);
  out << ")";
}


COtdrEventLine_t::~COtdrEventLine_t() noexcept {
}


void COtdrEventLine_t::__set_ulEventId(const int32_t val) {
  this->ulEventId = val;
}

void COtdrEventLine_t::__set_dLocation(const double val) {
  this->dLocation = val;
}

void COtdrEventLine_t::__set_dEventLoss(const double val) {
  this->dEventLoss = val;
}

void COtdrEventLine_t::__set_dReflectance(const double val) {
  this->dReflectance = val;
}

void COtdrEventLine_t::__set_dTotalLoss(const double val) {
  this->dTotalLoss = val;
}

void COtdrEventLine_t::__set_enEventType(const int32_t val) {
  this->enEventType = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrEventLine_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrEventLine_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulEventId);
          this->__isset.ulEventId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dLocation);
          this->__isset.dLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dEventLoss);
          this->__isset.dEventLoss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dReflectance);
          this->__isset.dReflectance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dTotalLoss);
          this->__isset.dTotalLoss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->enEventType);
          this->__isset.enEventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrEventLine_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrEventLine_t");

  xfer += oprot->writeFieldBegin("ulEventId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulEventId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dLocation", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->dLocation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dEventLoss", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dEventLoss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dReflectance", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->dReflectance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dTotalLoss", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->dTotalLoss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enEventType", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->enEventType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrEventLine_t &a, COtdrEventLine_t &b) {
  using ::std::swap;
  swap(a.ulEventId, b.ulEventId);
  swap(a.dLocation, b.dLocation);
  swap(a.dEventLoss, b.dEventLoss);
  swap(a.dReflectance, b.dReflectance);
  swap(a.dTotalLoss, b.dTotalLoss);
  swap(a.enEventType, b.enEventType);
  swap(a.__isset, b.__isset);
}

COtdrEventLine_t::COtdrEventLine_t(const COtdrEventLine_t& other58) {
  ulEventId = other58.ulEventId;
  dLocation = other58.dLocation;
  dEventLoss = other58.dEventLoss;
  dReflectance = other58.dReflectance;
  dTotalLoss = other58.dTotalLoss;
  enEventType = other58.enEventType;
  __isset = other58.__isset;
}
COtdrEventLine_t& COtdrEventLine_t::operator=(const COtdrEventLine_t& other59) {
  ulEventId = other59.ulEventId;
  dLocation = other59.dLocation;
  dEventLoss = other59.dEventLoss;
  dReflectance = other59.dReflectance;
  dTotalLoss = other59.dTotalLoss;
  enEventType = other59.enEventType;
  __isset = other59.__isset;
  return *this;
}
void COtdrEventLine_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrEventLine_t(";
  out << "ulEventId=" << to_string(ulEventId);
  out << ", " << "dLocation=" << to_string(dLocation);
  out << ", " << "dEventLoss=" << to_string(dEventLoss);
  out << ", " << "dReflectance=" << to_string(dReflectance);
  out << ", " << "dTotalLoss=" << to_string(dTotalLoss);
  out << ", " << "enEventType=" << to_string(enEventType);
  out << ")";
}


COtdrTemp_t::~COtdrTemp_t() noexcept {
}


void COtdrTemp_t::__set_fTecTemp(const double val) {
  this->fTecTemp = val;
}

void COtdrTemp_t::__set_fModuleTemp(const double val) {
  this->fModuleTemp = val;
}

void COtdrTemp_t::__set_fFpgaTemp(const double val) {
  this->fFpgaTemp = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrTemp_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrTemp_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fTecTemp);
          this->__isset.fTecTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fModuleTemp);
          this->__isset.fModuleTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fFpgaTemp);
          this->__isset.fFpgaTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrTemp_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrTemp_t");

  xfer += oprot->writeFieldBegin("fTecTemp", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->fTecTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fModuleTemp", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->fModuleTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fFpgaTemp", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->fFpgaTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrTemp_t &a, COtdrTemp_t &b) {
  using ::std::swap;
  swap(a.fTecTemp, b.fTecTemp);
  swap(a.fModuleTemp, b.fModuleTemp);
  swap(a.fFpgaTemp, b.fFpgaTemp);
  swap(a.__isset, b.__isset);
}

COtdrTemp_t::COtdrTemp_t(const COtdrTemp_t& other60) {
  fTecTemp = other60.fTecTemp;
  fModuleTemp = other60.fModuleTemp;
  fFpgaTemp = other60.fFpgaTemp;
  __isset = other60.__isset;
}
COtdrTemp_t& COtdrTemp_t::operator=(const COtdrTemp_t& other61) {
  fTecTemp = other61.fTecTemp;
  fModuleTemp = other61.fModuleTemp;
  fFpgaTemp = other61.fFpgaTemp;
  __isset = other61.__isset;
  return *this;
}
void COtdrTemp_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrTemp_t(";
  out << "fTecTemp=" << to_string(fTecTemp);
  out << ", " << "fModuleTemp=" << to_string(fModuleTemp);
  out << ", " << "fFpgaTemp=" << to_string(fFpgaTemp);
  out << ")";
}


COtdrStartOffset_t::~COtdrStartOffset_t() noexcept {
}


void COtdrStartOffset_t::__set_uiPositionOffset(const int32_t val) {
  this->uiPositionOffset = val;
}

void COtdrStartOffset_t::__set_fLossOffset(const double val) {
  this->fLossOffset = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStartOffset_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStartOffset_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPositionOffset);
          this->__isset.uiPositionOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fLossOffset);
          this->__isset.fLossOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStartOffset_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStartOffset_t");

  xfer += oprot->writeFieldBegin("uiPositionOffset", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiPositionOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fLossOffset", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->fLossOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStartOffset_t &a, COtdrStartOffset_t &b) {
  using ::std::swap;
  swap(a.uiPositionOffset, b.uiPositionOffset);
  swap(a.fLossOffset, b.fLossOffset);
  swap(a.__isset, b.__isset);
}

COtdrStartOffset_t::COtdrStartOffset_t(const COtdrStartOffset_t& other62) {
  uiPositionOffset = other62.uiPositionOffset;
  fLossOffset = other62.fLossOffset;
  __isset = other62.__isset;
}
COtdrStartOffset_t& COtdrStartOffset_t::operator=(const COtdrStartOffset_t& other63) {
  uiPositionOffset = other63.uiPositionOffset;
  fLossOffset = other63.fLossOffset;
  __isset = other63.__isset;
  return *this;
}
void COtdrStartOffset_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStartOffset_t(";
  out << "uiPositionOffset=" << to_string(uiPositionOffset);
  out << ", " << "fLossOffset=" << to_string(fLossOffset);
  out << ")";
}


COtdrStartOffsetPort_t::~COtdrStartOffsetPort_t() noexcept {
}


void COtdrStartOffsetPort_t::__set_uiPositionOffset(const int32_t val) {
  this->uiPositionOffset = val;
}

void COtdrStartOffsetPort_t::__set_fRev0(const std::vector<double> & val) {
  this->fRev0 = val;
}

void COtdrStartOffsetPort_t::__set_fLossOffset(const double val) {
  this->fLossOffset = val;
}

void COtdrStartOffsetPort_t::__set_fRev1(const std::vector<double> & val) {
  this->fRev1 = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStartOffsetPort_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStartOffsetPort_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPositionOffset);
          this->__isset.uiPositionOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fRev0.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->fRev0.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += iprot->readDouble(this->fRev0[_i68]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fRev0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fLossOffset);
          this->__isset.fLossOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fRev1.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->fRev1.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += iprot->readDouble(this->fRev1[_i73]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fRev1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStartOffsetPort_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStartOffsetPort_t");

  xfer += oprot->writeFieldBegin("uiPositionOffset", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiPositionOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fRev0", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->fRev0.size()));
    std::vector<double> ::const_iterator _iter74;
    for (_iter74 = this->fRev0.begin(); _iter74 != this->fRev0.end(); ++_iter74)
    {
      xfer += oprot->writeDouble((*_iter74));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fLossOffset", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->fLossOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fRev1", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->fRev1.size()));
    std::vector<double> ::const_iterator _iter75;
    for (_iter75 = this->fRev1.begin(); _iter75 != this->fRev1.end(); ++_iter75)
    {
      xfer += oprot->writeDouble((*_iter75));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStartOffsetPort_t &a, COtdrStartOffsetPort_t &b) {
  using ::std::swap;
  swap(a.uiPositionOffset, b.uiPositionOffset);
  swap(a.fRev0, b.fRev0);
  swap(a.fLossOffset, b.fLossOffset);
  swap(a.fRev1, b.fRev1);
  swap(a.__isset, b.__isset);
}

COtdrStartOffsetPort_t::COtdrStartOffsetPort_t(const COtdrStartOffsetPort_t& other76) {
  uiPositionOffset = other76.uiPositionOffset;
  fRev0 = other76.fRev0;
  fLossOffset = other76.fLossOffset;
  fRev1 = other76.fRev1;
  __isset = other76.__isset;
}
COtdrStartOffsetPort_t& COtdrStartOffsetPort_t::operator=(const COtdrStartOffsetPort_t& other77) {
  uiPositionOffset = other77.uiPositionOffset;
  fRev0 = other77.fRev0;
  fLossOffset = other77.fLossOffset;
  fRev1 = other77.fRev1;
  __isset = other77.__isset;
  return *this;
}
void COtdrStartOffsetPort_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStartOffsetPort_t(";
  out << "uiPositionOffset=" << to_string(uiPositionOffset);
  out << ", " << "fRev0=" << to_string(fRev0);
  out << ", " << "fLossOffset=" << to_string(fLossOffset);
  out << ", " << "fRev1=" << to_string(fRev1);
  out << ")";
}


COtdrStartOffsetAll_t::~COtdrStartOffsetAll_t() noexcept {
}


void COtdrStartOffsetAll_t::__set_stOtdrStartOffsetPort(const std::vector<COtdrStartOffsetPort_t> & val) {
  this->stOtdrStartOffsetPort = val;
}

void COtdrStartOffsetAll_t::__set_fRev(const std::vector<double> & val) {
  this->fRev = val;
}

void COtdrStartOffsetAll_t::__set_ulCrc32(const int32_t val) {
  this->ulCrc32 = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStartOffsetAll_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStartOffsetAll_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stOtdrStartOffsetPort.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->stOtdrStartOffsetPort.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->stOtdrStartOffsetPort[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stOtdrStartOffsetPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fRev.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->fRev.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += iprot->readDouble(this->fRev[_i87]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fRev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulCrc32);
          this->__isset.ulCrc32 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStartOffsetAll_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStartOffsetAll_t");

  xfer += oprot->writeFieldBegin("stOtdrStartOffsetPort", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stOtdrStartOffsetPort.size()));
    std::vector<COtdrStartOffsetPort_t> ::const_iterator _iter88;
    for (_iter88 = this->stOtdrStartOffsetPort.begin(); _iter88 != this->stOtdrStartOffsetPort.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fRev", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->fRev.size()));
    std::vector<double> ::const_iterator _iter89;
    for (_iter89 = this->fRev.begin(); _iter89 != this->fRev.end(); ++_iter89)
    {
      xfer += oprot->writeDouble((*_iter89));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulCrc32", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ulCrc32);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStartOffsetAll_t &a, COtdrStartOffsetAll_t &b) {
  using ::std::swap;
  swap(a.stOtdrStartOffsetPort, b.stOtdrStartOffsetPort);
  swap(a.fRev, b.fRev);
  swap(a.ulCrc32, b.ulCrc32);
  swap(a.__isset, b.__isset);
}

COtdrStartOffsetAll_t::COtdrStartOffsetAll_t(const COtdrStartOffsetAll_t& other90) {
  stOtdrStartOffsetPort = other90.stOtdrStartOffsetPort;
  fRev = other90.fRev;
  ulCrc32 = other90.ulCrc32;
  __isset = other90.__isset;
}
COtdrStartOffsetAll_t& COtdrStartOffsetAll_t::operator=(const COtdrStartOffsetAll_t& other91) {
  stOtdrStartOffsetPort = other91.stOtdrStartOffsetPort;
  fRev = other91.fRev;
  ulCrc32 = other91.ulCrc32;
  __isset = other91.__isset;
  return *this;
}
void COtdrStartOffsetAll_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStartOffsetAll_t(";
  out << "stOtdrStartOffsetPort=" << to_string(stOtdrStartOffsetPort);
  out << ", " << "fRev=" << to_string(fRev);
  out << ", " << "ulCrc32=" << to_string(ulCrc32);
  out << ")";
}


COtdrStatusData_t::~COtdrStatusData_t() noexcept {
}


void COtdrStatusData_t::__set_ulScanStatus(const int32_t val) {
  this->ulScanStatus = val;
}

void COtdrStatusData_t::__set_stEventTop(const COtdrEventTop_t& val) {
  this->stEventTop = val;
}

void COtdrStatusData_t::__set_astEventLine(const std::vector<COtdrEventLine_t> & val) {
  this->astEventLine = val;
}

void COtdrStatusData_t::__set_stTemp(const COtdrTemp_t& val) {
  this->stTemp = val;
}

void COtdrStatusData_t::__set_stStartOffset(const COtdrStartOffset_t& val) {
  this->stStartOffset = val;
}

void COtdrStatusData_t::__set_aucDbgBuf(const std::string& val) {
  this->aucDbgBuf = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulScanStatus);
          this->__isset.ulScanStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stEventTop.read(iprot);
          this->__isset.stEventTop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astEventLine.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->astEventLine.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->astEventLine[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astEventLine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stTemp.read(iprot);
          this->__isset.stTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stStartOffset.read(iprot);
          this->__isset.stStartOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucDbgBuf);
          this->__isset.aucDbgBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStatusData_t");

  xfer += oprot->writeFieldBegin("ulScanStatus", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulScanStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stEventTop", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stEventTop.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astEventLine", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astEventLine.size()));
    std::vector<COtdrEventLine_t> ::const_iterator _iter97;
    for (_iter97 = this->astEventLine.begin(); _iter97 != this->astEventLine.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stTemp", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->stTemp.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stStartOffset", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->stStartOffset.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucDbgBuf", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->aucDbgBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStatusData_t &a, COtdrStatusData_t &b) {
  using ::std::swap;
  swap(a.ulScanStatus, b.ulScanStatus);
  swap(a.stEventTop, b.stEventTop);
  swap(a.astEventLine, b.astEventLine);
  swap(a.stTemp, b.stTemp);
  swap(a.stStartOffset, b.stStartOffset);
  swap(a.aucDbgBuf, b.aucDbgBuf);
  swap(a.__isset, b.__isset);
}

COtdrStatusData_t::COtdrStatusData_t(const COtdrStatusData_t& other98) {
  ulScanStatus = other98.ulScanStatus;
  stEventTop = other98.stEventTop;
  astEventLine = other98.astEventLine;
  stTemp = other98.stTemp;
  stStartOffset = other98.stStartOffset;
  aucDbgBuf = other98.aucDbgBuf;
  __isset = other98.__isset;
}
COtdrStatusData_t& COtdrStatusData_t::operator=(const COtdrStatusData_t& other99) {
  ulScanStatus = other99.ulScanStatus;
  stEventTop = other99.stEventTop;
  astEventLine = other99.astEventLine;
  stTemp = other99.stTemp;
  stStartOffset = other99.stStartOffset;
  aucDbgBuf = other99.aucDbgBuf;
  __isset = other99.__isset;
  return *this;
}
void COtdrStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStatusData_t(";
  out << "ulScanStatus=" << to_string(ulScanStatus);
  out << ", " << "stEventTop=" << to_string(stEventTop);
  out << ", " << "astEventLine=" << to_string(astEventLine);
  out << ", " << "stTemp=" << to_string(stTemp);
  out << ", " << "stStartOffset=" << to_string(stStartOffset);
  out << ", " << "aucDbgBuf=" << to_string(aucDbgBuf);
  out << ")";
}


CWavePlan_t::~CWavePlan_t() noexcept {
}


void CWavePlan_t::__set_uiChId(const int32_t val) {
  this->uiChId = val;
}

void CWavePlan_t::__set_uiCenterFreq(const int32_t val) {
  this->uiCenterFreq = val;
}

void CWavePlan_t::__set_usSliceCount(const int16_t val) {
  this->usSliceCount = val;
}
std::ostream& operator<<(std::ostream& out, const CWavePlan_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWavePlan_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiChId);
          this->__isset.uiChId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiCenterFreq);
          this->__isset.uiCenterFreq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usSliceCount);
          this->__isset.usSliceCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWavePlan_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWavePlan_t");

  xfer += oprot->writeFieldBegin("uiChId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiChId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiCenterFreq", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiCenterFreq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usSliceCount", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->usSliceCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWavePlan_t &a, CWavePlan_t &b) {
  using ::std::swap;
  swap(a.uiChId, b.uiChId);
  swap(a.uiCenterFreq, b.uiCenterFreq);
  swap(a.usSliceCount, b.usSliceCount);
  swap(a.__isset, b.__isset);
}

CWavePlan_t::CWavePlan_t(const CWavePlan_t& other100) {
  uiChId = other100.uiChId;
  uiCenterFreq = other100.uiCenterFreq;
  usSliceCount = other100.usSliceCount;
  __isset = other100.__isset;
}
CWavePlan_t& CWavePlan_t::operator=(const CWavePlan_t& other101) {
  uiChId = other101.uiChId;
  uiCenterFreq = other101.uiCenterFreq;
  usSliceCount = other101.usSliceCount;
  __isset = other101.__isset;
  return *this;
}
void CWavePlan_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWavePlan_t(";
  out << "uiChId=" << to_string(uiChId);
  out << ", " << "uiCenterFreq=" << to_string(uiCenterFreq);
  out << ", " << "usSliceCount=" << to_string(usSliceCount);
  out << ")";
}


CWssCfg_t::~CWssCfg_t() noexcept {
}


void CWssCfg_t::__set_uiId(const int32_t val) {
  this->uiId = val;
}

void CWssCfg_t::__set_uiComPort(const int32_t val) {
  this->uiComPort = val;
}

void CWssCfg_t::__set_uiExpPort(const int32_t val) {
  this->uiExpPort = val;
}

void CWssCfg_t::__set_uiAtten(const int32_t val) {
  this->uiAtten = val;
}
std::ostream& operator<<(std::ostream& out, const CWssCfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssCfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiId);
          this->__isset.uiId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiComPort);
          this->__isset.uiComPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiExpPort);
          this->__isset.uiExpPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiAtten);
          this->__isset.uiAtten = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssCfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssCfg_t");

  xfer += oprot->writeFieldBegin("uiId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiComPort", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiComPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiExpPort", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiExpPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiAtten", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiAtten);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssCfg_t &a, CWssCfg_t &b) {
  using ::std::swap;
  swap(a.uiId, b.uiId);
  swap(a.uiComPort, b.uiComPort);
  swap(a.uiExpPort, b.uiExpPort);
  swap(a.uiAtten, b.uiAtten);
  swap(a.__isset, b.__isset);
}

CWssCfg_t::CWssCfg_t(const CWssCfg_t& other102) {
  uiId = other102.uiId;
  uiComPort = other102.uiComPort;
  uiExpPort = other102.uiExpPort;
  uiAtten = other102.uiAtten;
  __isset = other102.__isset;
}
CWssCfg_t& CWssCfg_t::operator=(const CWssCfg_t& other103) {
  uiId = other103.uiId;
  uiComPort = other103.uiComPort;
  uiExpPort = other103.uiExpPort;
  uiAtten = other103.uiAtten;
  __isset = other103.__isset;
  return *this;
}
void CWssCfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssCfg_t(";
  out << "uiId=" << to_string(uiId);
  out << ", " << "uiComPort=" << to_string(uiComPort);
  out << ", " << "uiExpPort=" << to_string(uiExpPort);
  out << ", " << "uiAtten=" << to_string(uiAtten);
  out << ")";
}


CWssAllCfg_t::~CWssAllCfg_t() noexcept {
}


void CWssAllCfg_t::__set_astWavePlan(const std::vector<CWavePlan_t> & val) {
  this->astWavePlan = val;
}

void CWssAllCfg_t::__set_astWssChCfgAdd(const std::vector<CWssCfg_t> & val) {
  this->astWssChCfgAdd = val;
}

void CWssAllCfg_t::__set_astWssChCfgDrop(const std::vector<CWssCfg_t> & val) {
  this->astWssChCfgDrop = val;
}
std::ostream& operator<<(std::ostream& out, const CWssAllCfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssAllCfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astWavePlan.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->astWavePlan.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->astWavePlan[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astWavePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astWssChCfgAdd.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _etype112;
            xfer += iprot->readListBegin(_etype112, _size109);
            this->astWssChCfgAdd.resize(_size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              xfer += this->astWssChCfgAdd[_i113].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astWssChCfgAdd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astWssChCfgDrop.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            xfer += iprot->readListBegin(_etype117, _size114);
            this->astWssChCfgDrop.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += this->astWssChCfgDrop[_i118].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astWssChCfgDrop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssAllCfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssAllCfg_t");

  xfer += oprot->writeFieldBegin("astWavePlan", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astWavePlan.size()));
    std::vector<CWavePlan_t> ::const_iterator _iter119;
    for (_iter119 = this->astWavePlan.begin(); _iter119 != this->astWavePlan.end(); ++_iter119)
    {
      xfer += (*_iter119).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astWssChCfgAdd", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astWssChCfgAdd.size()));
    std::vector<CWssCfg_t> ::const_iterator _iter120;
    for (_iter120 = this->astWssChCfgAdd.begin(); _iter120 != this->astWssChCfgAdd.end(); ++_iter120)
    {
      xfer += (*_iter120).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astWssChCfgDrop", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astWssChCfgDrop.size()));
    std::vector<CWssCfg_t> ::const_iterator _iter121;
    for (_iter121 = this->astWssChCfgDrop.begin(); _iter121 != this->astWssChCfgDrop.end(); ++_iter121)
    {
      xfer += (*_iter121).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssAllCfg_t &a, CWssAllCfg_t &b) {
  using ::std::swap;
  swap(a.astWavePlan, b.astWavePlan);
  swap(a.astWssChCfgAdd, b.astWssChCfgAdd);
  swap(a.astWssChCfgDrop, b.astWssChCfgDrop);
  swap(a.__isset, b.__isset);
}

CWssAllCfg_t::CWssAllCfg_t(const CWssAllCfg_t& other122) {
  astWavePlan = other122.astWavePlan;
  astWssChCfgAdd = other122.astWssChCfgAdd;
  astWssChCfgDrop = other122.astWssChCfgDrop;
  __isset = other122.__isset;
}
CWssAllCfg_t& CWssAllCfg_t::operator=(const CWssAllCfg_t& other123) {
  astWavePlan = other123.astWavePlan;
  astWssChCfgAdd = other123.astWssChCfgAdd;
  astWssChCfgDrop = other123.astWssChCfgDrop;
  __isset = other123.__isset;
  return *this;
}
void CWssAllCfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssAllCfg_t(";
  out << "astWavePlan=" << to_string(astWavePlan);
  out << ", " << "astWssChCfgAdd=" << to_string(astWssChCfgAdd);
  out << ", " << "astWssChCfgDrop=" << to_string(astWssChCfgDrop);
  out << ")";
}


CWssPortPowerHistory_t::~CWssPortPowerHistory_t() noexcept {
}


void CWssPortPowerHistory_t::__set_asPortPower(const std::vector<std::vector<int16_t> > & val) {
  this->asPortPower = val;
}
std::ostream& operator<<(std::ostream& out, const CWssPortPowerHistory_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssPortPowerHistory_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPower.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->asPortPower.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              {
                this->asPortPower[_i128].clear();
                uint32_t _size129;
                ::apache::thrift::protocol::TType _etype132;
                xfer += iprot->readListBegin(_etype132, _size129);
                this->asPortPower[_i128].resize(_size129);
                uint32_t _i133;
                for (_i133 = 0; _i133 < _size129; ++_i133)
                {
                  xfer += iprot->readI16(this->asPortPower[_i128][_i133]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssPortPowerHistory_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssPortPowerHistory_t");

  xfer += oprot->writeFieldBegin("asPortPower", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->asPortPower.size()));
    std::vector<std::vector<int16_t> > ::const_iterator _iter134;
    for (_iter134 = this->asPortPower.begin(); _iter134 != this->asPortPower.end(); ++_iter134)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*_iter134).size()));
        std::vector<int16_t> ::const_iterator _iter135;
        for (_iter135 = (*_iter134).begin(); _iter135 != (*_iter134).end(); ++_iter135)
        {
          xfer += oprot->writeI16((*_iter135));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssPortPowerHistory_t &a, CWssPortPowerHistory_t &b) {
  using ::std::swap;
  swap(a.asPortPower, b.asPortPower);
  swap(a.__isset, b.__isset);
}

CWssPortPowerHistory_t::CWssPortPowerHistory_t(const CWssPortPowerHistory_t& other136) {
  asPortPower = other136.asPortPower;
  __isset = other136.__isset;
}
CWssPortPowerHistory_t& CWssPortPowerHistory_t::operator=(const CWssPortPowerHistory_t& other137) {
  asPortPower = other137.asPortPower;
  __isset = other137.__isset;
  return *this;
}
void CWssPortPowerHistory_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssPortPowerHistory_t(";
  out << "asPortPower=" << to_string(asPortPower);
  out << ")";
}


CWssCurData_t::~CWssCurData_t() noexcept {
}


void CWssCurData_t::__set_asPortPower(const std::vector<int16_t> & val) {
  this->asPortPower = val;
}

void CWssCurData_t::__set_asPortPowerOut(const std::vector<int16_t> & val) {
  this->asPortPowerOut = val;
}
std::ostream& operator<<(std::ostream& out, const CWssCurData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssCurData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPower.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _etype141;
            xfer += iprot->readListBegin(_etype141, _size138);
            this->asPortPower.resize(_size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              xfer += iprot->readI16(this->asPortPower[_i142]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerOut.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->asPortPowerOut.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += iprot->readI16(this->asPortPowerOut[_i147]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssCurData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssCurData_t");

  xfer += oprot->writeFieldBegin("asPortPower", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPower.size()));
    std::vector<int16_t> ::const_iterator _iter148;
    for (_iter148 = this->asPortPower.begin(); _iter148 != this->asPortPower.end(); ++_iter148)
    {
      xfer += oprot->writeI16((*_iter148));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPowerOut", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPowerOut.size()));
    std::vector<int16_t> ::const_iterator _iter149;
    for (_iter149 = this->asPortPowerOut.begin(); _iter149 != this->asPortPowerOut.end(); ++_iter149)
    {
      xfer += oprot->writeI16((*_iter149));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssCurData_t &a, CWssCurData_t &b) {
  using ::std::swap;
  swap(a.asPortPower, b.asPortPower);
  swap(a.asPortPowerOut, b.asPortPowerOut);
  swap(a.__isset, b.__isset);
}

CWssCurData_t::CWssCurData_t(const CWssCurData_t& other150) {
  asPortPower = other150.asPortPower;
  asPortPowerOut = other150.asPortPowerOut;
  __isset = other150.__isset;
}
CWssCurData_t& CWssCurData_t::operator=(const CWssCurData_t& other151) {
  asPortPower = other151.asPortPower;
  asPortPowerOut = other151.asPortPowerOut;
  __isset = other151.__isset;
  return *this;
}
void CWssCurData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssCurData_t(";
  out << "asPortPower=" << to_string(asPortPower);
  out << ", " << "asPortPowerOut=" << to_string(asPortPowerOut);
  out << ")";
}


CWssAlarm_t::~CWssAlarm_t() noexcept {
}


void CWssAlarm_t::__set_abPortPower(const std::vector<std::vector<bool> > & val) {
  this->abPortPower = val;
}

void CWssAlarm_t::__set_auiDuration(const std::vector<std::vector<int32_t> > & val) {
  this->auiDuration = val;
}
std::ostream& operator<<(std::ostream& out, const CWssAlarm_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssAlarm_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abPortPower.clear();
            uint32_t _size152;
            ::apache::thrift::protocol::TType _etype155;
            xfer += iprot->readListBegin(_etype155, _size152);
            this->abPortPower.resize(_size152);
            uint32_t _i156;
            for (_i156 = 0; _i156 < _size152; ++_i156)
            {
              {
                this->abPortPower[_i156].clear();
                uint32_t _size157;
                ::apache::thrift::protocol::TType _etype160;
                xfer += iprot->readListBegin(_etype160, _size157);
                this->abPortPower[_i156].resize(_size157);
                uint32_t _i161;
                for (_i161 = 0; _i161 < _size157; ++_i161)
                {
                  xfer += iprot->readBool(this->abPortPower[_i156][_i161]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abPortPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->auiDuration.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->auiDuration.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              {
                this->auiDuration[_i166].clear();
                uint32_t _size167;
                ::apache::thrift::protocol::TType _etype170;
                xfer += iprot->readListBegin(_etype170, _size167);
                this->auiDuration[_i166].resize(_size167);
                uint32_t _i171;
                for (_i171 = 0; _i171 < _size167; ++_i171)
                {
                  xfer += iprot->readI32(this->auiDuration[_i166][_i171]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.auiDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssAlarm_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssAlarm_t");

  xfer += oprot->writeFieldBegin("abPortPower", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->abPortPower.size()));
    std::vector<std::vector<bool> > ::const_iterator _iter172;
    for (_iter172 = this->abPortPower.begin(); _iter172 != this->abPortPower.end(); ++_iter172)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*_iter172).size()));
        std::vector<bool> ::const_iterator _iter173;
        for (_iter173 = (*_iter172).begin(); _iter173 != (*_iter172).end(); ++_iter173)
        {
          xfer += oprot->writeBool((*_iter173));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("auiDuration", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->auiDuration.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter174;
    for (_iter174 = this->auiDuration.begin(); _iter174 != this->auiDuration.end(); ++_iter174)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter174).size()));
        std::vector<int32_t> ::const_iterator _iter175;
        for (_iter175 = (*_iter174).begin(); _iter175 != (*_iter174).end(); ++_iter175)
        {
          xfer += oprot->writeI32((*_iter175));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssAlarm_t &a, CWssAlarm_t &b) {
  using ::std::swap;
  swap(a.abPortPower, b.abPortPower);
  swap(a.auiDuration, b.auiDuration);
  swap(a.__isset, b.__isset);
}

CWssAlarm_t::CWssAlarm_t(const CWssAlarm_t& other176) {
  abPortPower = other176.abPortPower;
  auiDuration = other176.auiDuration;
  __isset = other176.__isset;
}
CWssAlarm_t& CWssAlarm_t::operator=(const CWssAlarm_t& other177) {
  abPortPower = other177.abPortPower;
  auiDuration = other177.auiDuration;
  __isset = other177.__isset;
  return *this;
}
void CWssAlarm_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssAlarm_t(";
  out << "abPortPower=" << to_string(abPortPower);
  out << ", " << "auiDuration=" << to_string(auiDuration);
  out << ")";
}


CWssStatusData_t::~CWssStatusData_t() noexcept {
}


void CWssStatusData_t::__set_stCurData(const CWssCurData_t& val) {
  this->stCurData = val;
}

void CWssStatusData_t::__set_stAlarm(const CWssAlarm_t& val) {
  this->stAlarm = val;
}
std::ostream& operator<<(std::ostream& out, const CWssStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stCurData.read(iprot);
          this->__isset.stCurData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stAlarm.read(iprot);
          this->__isset.stAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssStatusData_t");

  xfer += oprot->writeFieldBegin("stCurData", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stCurData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stAlarm", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stAlarm.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssStatusData_t &a, CWssStatusData_t &b) {
  using ::std::swap;
  swap(a.stCurData, b.stCurData);
  swap(a.stAlarm, b.stAlarm);
  swap(a.__isset, b.__isset);
}

CWssStatusData_t::CWssStatusData_t(const CWssStatusData_t& other178) {
  stCurData = other178.stCurData;
  stAlarm = other178.stAlarm;
  __isset = other178.__isset;
}
CWssStatusData_t& CWssStatusData_t::operator=(const CWssStatusData_t& other179) {
  stCurData = other179.stCurData;
  stAlarm = other179.stAlarm;
  __isset = other179.__isset;
  return *this;
}
void CWssStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssStatusData_t(";
  out << "stCurData=" << to_string(stCurData);
  out << ", " << "stAlarm=" << to_string(stAlarm);
  out << ")";
}


CPortPowerCfg_t::~CPortPowerCfg_t() noexcept {
}


void CPortPowerCfg_t::__set_asPortPowerThrLos(const std::vector<int16_t> & val) {
  this->asPortPowerThrLos = val;
}

void CPortPowerCfg_t::__set_asPortPowerHysLos(const std::vector<int16_t> & val) {
  this->asPortPowerHysLos = val;
}

void CPortPowerCfg_t::__set_asPortPowerThrLow(const std::vector<int16_t> & val) {
  this->asPortPowerThrLow = val;
}

void CPortPowerCfg_t::__set_asPortPowerHysLow(const std::vector<int16_t> & val) {
  this->asPortPowerHysLow = val;
}

void CPortPowerCfg_t::__set_asPortPowerThrHigh(const std::vector<int16_t> & val) {
  this->asPortPowerThrHigh = val;
}

void CPortPowerCfg_t::__set_asPortPowerHysHigh(const std::vector<int16_t> & val) {
  this->asPortPowerHysHigh = val;
}
std::ostream& operator<<(std::ostream& out, const CPortPowerCfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPortPowerCfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerThrLos.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->asPortPowerThrLos.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += iprot->readI16(this->asPortPowerThrLos[_i184]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerThrLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerHysLos.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->asPortPowerHysLos.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += iprot->readI16(this->asPortPowerHysLos[_i189]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerHysLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerThrLow.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->asPortPowerThrLow.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += iprot->readI16(this->asPortPowerThrLow[_i194]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerThrLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerHysLow.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _etype198;
            xfer += iprot->readListBegin(_etype198, _size195);
            this->asPortPowerHysLow.resize(_size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              xfer += iprot->readI16(this->asPortPowerHysLow[_i199]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerHysLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerThrHigh.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->asPortPowerThrHigh.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += iprot->readI16(this->asPortPowerThrHigh[_i204]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerThrHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerHysHigh.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readListBegin(_etype208, _size205);
            this->asPortPowerHysHigh.resize(_size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              xfer += iprot->readI16(this->asPortPowerHysHigh[_i209]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerHysHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPortPowerCfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPortPowerCfg_t");

  xfer += oprot->writeFieldBegin("asPortPowerThrLos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPowerThrLos.size()));
    std::vector<int16_t> ::const_iterator _iter210;
    for (_iter210 = this->asPortPowerThrLos.begin(); _iter210 != this->asPortPowerThrLos.end(); ++_iter210)
    {
      xfer += oprot->writeI16((*_iter210));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPowerHysLos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPowerHysLos.size()));
    std::vector<int16_t> ::const_iterator _iter211;
    for (_iter211 = this->asPortPowerHysLos.begin(); _iter211 != this->asPortPowerHysLos.end(); ++_iter211)
    {
      xfer += oprot->writeI16((*_iter211));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPowerThrLow", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPowerThrLow.size()));
    std::vector<int16_t> ::const_iterator _iter212;
    for (_iter212 = this->asPortPowerThrLow.begin(); _iter212 != this->asPortPowerThrLow.end(); ++_iter212)
    {
      xfer += oprot->writeI16((*_iter212));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPowerHysLow", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPowerHysLow.size()));
    std::vector<int16_t> ::const_iterator _iter213;
    for (_iter213 = this->asPortPowerHysLow.begin(); _iter213 != this->asPortPowerHysLow.end(); ++_iter213)
    {
      xfer += oprot->writeI16((*_iter213));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPowerThrHigh", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPowerThrHigh.size()));
    std::vector<int16_t> ::const_iterator _iter214;
    for (_iter214 = this->asPortPowerThrHigh.begin(); _iter214 != this->asPortPowerThrHigh.end(); ++_iter214)
    {
      xfer += oprot->writeI16((*_iter214));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPowerHysHigh", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPowerHysHigh.size()));
    std::vector<int16_t> ::const_iterator _iter215;
    for (_iter215 = this->asPortPowerHysHigh.begin(); _iter215 != this->asPortPowerHysHigh.end(); ++_iter215)
    {
      xfer += oprot->writeI16((*_iter215));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPortPowerCfg_t &a, CPortPowerCfg_t &b) {
  using ::std::swap;
  swap(a.asPortPowerThrLos, b.asPortPowerThrLos);
  swap(a.asPortPowerHysLos, b.asPortPowerHysLos);
  swap(a.asPortPowerThrLow, b.asPortPowerThrLow);
  swap(a.asPortPowerHysLow, b.asPortPowerHysLow);
  swap(a.asPortPowerThrHigh, b.asPortPowerThrHigh);
  swap(a.asPortPowerHysHigh, b.asPortPowerHysHigh);
  swap(a.__isset, b.__isset);
}

CPortPowerCfg_t::CPortPowerCfg_t(const CPortPowerCfg_t& other216) {
  asPortPowerThrLos = other216.asPortPowerThrLos;
  asPortPowerHysLos = other216.asPortPowerHysLos;
  asPortPowerThrLow = other216.asPortPowerThrLow;
  asPortPowerHysLow = other216.asPortPowerHysLow;
  asPortPowerThrHigh = other216.asPortPowerThrHigh;
  asPortPowerHysHigh = other216.asPortPowerHysHigh;
  __isset = other216.__isset;
}
CPortPowerCfg_t& CPortPowerCfg_t::operator=(const CPortPowerCfg_t& other217) {
  asPortPowerThrLos = other217.asPortPowerThrLos;
  asPortPowerHysLos = other217.asPortPowerHysLos;
  asPortPowerThrLow = other217.asPortPowerThrLow;
  asPortPowerHysLow = other217.asPortPowerHysLow;
  asPortPowerThrHigh = other217.asPortPowerThrHigh;
  asPortPowerHysHigh = other217.asPortPowerHysHigh;
  __isset = other217.__isset;
  return *this;
}
void CPortPowerCfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPortPowerCfg_t(";
  out << "asPortPowerThrLos=" << to_string(asPortPowerThrLos);
  out << ", " << "asPortPowerHysLos=" << to_string(asPortPowerHysLos);
  out << ", " << "asPortPowerThrLow=" << to_string(asPortPowerThrLow);
  out << ", " << "asPortPowerHysLow=" << to_string(asPortPowerHysLow);
  out << ", " << "asPortPowerThrHigh=" << to_string(asPortPowerThrHigh);
  out << ", " << "asPortPowerHysHigh=" << to_string(asPortPowerHysHigh);
  out << ")";
}


CWavePlanSlice_t::~CWavePlanSlice_t() noexcept {
}


void CWavePlanSlice_t::__set_ucChId(const int8_t val) {
  this->ucChId = val;
}

void CWavePlanSlice_t::__set_usStartSlice(const int16_t val) {
  this->usStartSlice = val;
}

void CWavePlanSlice_t::__set_usEndSlice(const int16_t val) {
  this->usEndSlice = val;
}
std::ostream& operator<<(std::ostream& out, const CWavePlanSlice_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWavePlanSlice_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucChId);
          this->__isset.ucChId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usStartSlice);
          this->__isset.usStartSlice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usEndSlice);
          this->__isset.usEndSlice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWavePlanSlice_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWavePlanSlice_t");

  xfer += oprot->writeFieldBegin("ucChId", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucChId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usStartSlice", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->usStartSlice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usEndSlice", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->usEndSlice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWavePlanSlice_t &a, CWavePlanSlice_t &b) {
  using ::std::swap;
  swap(a.ucChId, b.ucChId);
  swap(a.usStartSlice, b.usStartSlice);
  swap(a.usEndSlice, b.usEndSlice);
  swap(a.__isset, b.__isset);
}

CWavePlanSlice_t::CWavePlanSlice_t(const CWavePlanSlice_t& other218) {
  ucChId = other218.ucChId;
  usStartSlice = other218.usStartSlice;
  usEndSlice = other218.usEndSlice;
  __isset = other218.__isset;
}
CWavePlanSlice_t& CWavePlanSlice_t::operator=(const CWavePlanSlice_t& other219) {
  ucChId = other219.ucChId;
  usStartSlice = other219.usStartSlice;
  usEndSlice = other219.usEndSlice;
  __isset = other219.__isset;
  return *this;
}
void CWavePlanSlice_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWavePlanSlice_t(";
  out << "ucChId=" << to_string(ucChId);
  out << ", " << "usStartSlice=" << to_string(usStartSlice);
  out << ", " << "usEndSlice=" << to_string(usEndSlice);
  out << ")";
}


STChannelGrid_t::~STChannelGrid_t() noexcept {
}


void STChannelGrid_t::__set_uCentralFreq(const int32_t val) {
  this->uCentralFreq = val;
}

void STChannelGrid_t::__set_uBandwidth(const int32_t val) {
  this->uBandwidth = val;
}
std::ostream& operator<<(std::ostream& out, const STChannelGrid_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t STChannelGrid_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uCentralFreq);
          this->__isset.uCentralFreq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uBandwidth);
          this->__isset.uBandwidth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t STChannelGrid_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("STChannelGrid_t");

  xfer += oprot->writeFieldBegin("uCentralFreq", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uCentralFreq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uBandwidth", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uBandwidth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(STChannelGrid_t &a, STChannelGrid_t &b) {
  using ::std::swap;
  swap(a.uCentralFreq, b.uCentralFreq);
  swap(a.uBandwidth, b.uBandwidth);
  swap(a.__isset, b.__isset);
}

STChannelGrid_t::STChannelGrid_t(const STChannelGrid_t& other220) {
  uCentralFreq = other220.uCentralFreq;
  uBandwidth = other220.uBandwidth;
  __isset = other220.__isset;
}
STChannelGrid_t& STChannelGrid_t::operator=(const STChannelGrid_t& other221) {
  uCentralFreq = other221.uCentralFreq;
  uBandwidth = other221.uBandwidth;
  __isset = other221.__isset;
  return *this;
}
void STChannelGrid_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "STChannelGrid_t(";
  out << "uCentralFreq=" << to_string(uCentralFreq);
  out << ", " << "uBandwidth=" << to_string(uBandwidth);
  out << ")";
}


COcmCfgData_t::~COcmCfgData_t() noexcept {
}


void COcmCfgData_t::__set_aastWavePlan(const std::vector<std::vector<CWavePlan_t> > & val) {
  this->aastWavePlan = val;
}

void COcmCfgData_t::__set_auiSchdlList(const std::vector<int32_t> & val) {
  this->auiSchdlList = val;
}
std::ostream& operator<<(std::ostream& out, const COcmCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aastWavePlan.clear();
            uint32_t _size222;
            ::apache::thrift::protocol::TType _etype225;
            xfer += iprot->readListBegin(_etype225, _size222);
            this->aastWavePlan.resize(_size222);
            uint32_t _i226;
            for (_i226 = 0; _i226 < _size222; ++_i226)
            {
              {
                this->aastWavePlan[_i226].clear();
                uint32_t _size227;
                ::apache::thrift::protocol::TType _etype230;
                xfer += iprot->readListBegin(_etype230, _size227);
                this->aastWavePlan[_i226].resize(_size227);
                uint32_t _i231;
                for (_i231 = 0; _i231 < _size227; ++_i231)
                {
                  xfer += this->aastWavePlan[_i226][_i231].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aastWavePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->auiSchdlList.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->auiSchdlList.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236)
            {
              xfer += iprot->readI32(this->auiSchdlList[_i236]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.auiSchdlList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmCfgData_t");

  xfer += oprot->writeFieldBegin("aastWavePlan", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->aastWavePlan.size()));
    std::vector<std::vector<CWavePlan_t> > ::const_iterator _iter237;
    for (_iter237 = this->aastWavePlan.begin(); _iter237 != this->aastWavePlan.end(); ++_iter237)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter237).size()));
        std::vector<CWavePlan_t> ::const_iterator _iter238;
        for (_iter238 = (*_iter237).begin(); _iter238 != (*_iter237).end(); ++_iter238)
        {
          xfer += (*_iter238).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("auiSchdlList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->auiSchdlList.size()));
    std::vector<int32_t> ::const_iterator _iter239;
    for (_iter239 = this->auiSchdlList.begin(); _iter239 != this->auiSchdlList.end(); ++_iter239)
    {
      xfer += oprot->writeI32((*_iter239));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmCfgData_t &a, COcmCfgData_t &b) {
  using ::std::swap;
  swap(a.aastWavePlan, b.aastWavePlan);
  swap(a.auiSchdlList, b.auiSchdlList);
  swap(a.__isset, b.__isset);
}

COcmCfgData_t::COcmCfgData_t(const COcmCfgData_t& other240) {
  aastWavePlan = other240.aastWavePlan;
  auiSchdlList = other240.auiSchdlList;
  __isset = other240.__isset;
}
COcmCfgData_t& COcmCfgData_t::operator=(const COcmCfgData_t& other241) {
  aastWavePlan = other241.aastWavePlan;
  auiSchdlList = other241.auiSchdlList;
  __isset = other241.__isset;
  return *this;
}
void COcmCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmCfgData_t(";
  out << "aastWavePlan=" << to_string(aastWavePlan);
  out << ", " << "auiSchdlList=" << to_string(auiSchdlList);
  out << ")";
}


COcmChPower_t::~COcmChPower_t() noexcept {
}


void COcmChPower_t::__set_asPower(const std::vector<int16_t> & val) {
  this->asPower = val;
}

void COcmChPower_t::__set_asOsnr(const std::vector<int16_t> & val) {
  this->asOsnr = val;
}
std::ostream& operator<<(std::ostream& out, const COcmChPower_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmChPower_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPower.clear();
            uint32_t _size242;
            ::apache::thrift::protocol::TType _etype245;
            xfer += iprot->readListBegin(_etype245, _size242);
            this->asPower.resize(_size242);
            uint32_t _i246;
            for (_i246 = 0; _i246 < _size242; ++_i246)
            {
              xfer += iprot->readI16(this->asPower[_i246]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asOsnr.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _etype250;
            xfer += iprot->readListBegin(_etype250, _size247);
            this->asOsnr.resize(_size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251)
            {
              xfer += iprot->readI16(this->asOsnr[_i251]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asOsnr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmChPower_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmChPower_t");

  xfer += oprot->writeFieldBegin("asPower", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPower.size()));
    std::vector<int16_t> ::const_iterator _iter252;
    for (_iter252 = this->asPower.begin(); _iter252 != this->asPower.end(); ++_iter252)
    {
      xfer += oprot->writeI16((*_iter252));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asOsnr", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asOsnr.size()));
    std::vector<int16_t> ::const_iterator _iter253;
    for (_iter253 = this->asOsnr.begin(); _iter253 != this->asOsnr.end(); ++_iter253)
    {
      xfer += oprot->writeI16((*_iter253));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmChPower_t &a, COcmChPower_t &b) {
  using ::std::swap;
  swap(a.asPower, b.asPower);
  swap(a.asOsnr, b.asOsnr);
  swap(a.__isset, b.__isset);
}

COcmChPower_t::COcmChPower_t(const COcmChPower_t& other254) {
  asPower = other254.asPower;
  asOsnr = other254.asOsnr;
  __isset = other254.__isset;
}
COcmChPower_t& COcmChPower_t::operator=(const COcmChPower_t& other255) {
  asPower = other255.asPower;
  asOsnr = other255.asOsnr;
  __isset = other255.__isset;
  return *this;
}
void COcmChPower_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmChPower_t(";
  out << "asPower=" << to_string(asPower);
  out << ", " << "asOsnr=" << to_string(asOsnr);
  out << ")";
}


COcmOsa_t::~COcmOsa_t() noexcept {
}


void COcmOsa_t::__set_asOsa(const std::vector<int16_t> & val) {
  this->asOsa = val;
}
std::ostream& operator<<(std::ostream& out, const COcmOsa_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmOsa_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asOsa.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _etype259;
            xfer += iprot->readListBegin(_etype259, _size256);
            this->asOsa.resize(_size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              xfer += iprot->readI16(this->asOsa[_i260]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asOsa = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmOsa_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmOsa_t");

  xfer += oprot->writeFieldBegin("asOsa", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asOsa.size()));
    std::vector<int16_t> ::const_iterator _iter261;
    for (_iter261 = this->asOsa.begin(); _iter261 != this->asOsa.end(); ++_iter261)
    {
      xfer += oprot->writeI16((*_iter261));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmOsa_t &a, COcmOsa_t &b) {
  using ::std::swap;
  swap(a.asOsa, b.asOsa);
  swap(a.__isset, b.__isset);
}

COcmOsa_t::COcmOsa_t(const COcmOsa_t& other262) {
  asOsa = other262.asOsa;
  __isset = other262.__isset;
}
COcmOsa_t& COcmOsa_t::operator=(const COcmOsa_t& other263) {
  asOsa = other263.asOsa;
  __isset = other263.__isset;
  return *this;
}
void COcmOsa_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmOsa_t(";
  out << "asOsa=" << to_string(asOsa);
  out << ")";
}


COcmStatusData_t::~COcmStatusData_t() noexcept {
}


void COcmStatusData_t::__set_aucAlm(const std::string& val) {
  this->aucAlm = val;
}

void COcmStatusData_t::__set_aucEvent(const std::string& val) {
  this->aucEvent = val;
}

void COcmStatusData_t::__set_iCvPower(const int32_t val) {
  this->iCvPower = val;
}
std::ostream& operator<<(std::ostream& out, const COcmStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucAlm);
          this->__isset.aucAlm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucEvent);
          this->__isset.aucEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCvPower);
          this->__isset.iCvPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmStatusData_t");

  xfer += oprot->writeFieldBegin("aucAlm", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->aucAlm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucEvent", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->aucEvent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iCvPower", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iCvPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmStatusData_t &a, COcmStatusData_t &b) {
  using ::std::swap;
  swap(a.aucAlm, b.aucAlm);
  swap(a.aucEvent, b.aucEvent);
  swap(a.iCvPower, b.iCvPower);
  swap(a.__isset, b.__isset);
}

COcmStatusData_t::COcmStatusData_t(const COcmStatusData_t& other264) {
  aucAlm = other264.aucAlm;
  aucEvent = other264.aucEvent;
  iCvPower = other264.iCvPower;
  __isset = other264.__isset;
}
COcmStatusData_t& COcmStatusData_t::operator=(const COcmStatusData_t& other265) {
  aucAlm = other265.aucAlm;
  aucEvent = other265.aucEvent;
  iCvPower = other265.iCvPower;
  __isset = other265.__isset;
  return *this;
}
void COcmStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmStatusData_t(";
  out << "aucAlm=" << to_string(aucAlm);
  out << ", " << "aucEvent=" << to_string(aucEvent);
  out << ", " << "iCvPower=" << to_string(iCvPower);
  out << ")";
}


COcmMode_t::~COcmMode_t() noexcept {
}


void COcmMode_t::__set_uiPortId(const int32_t val) {
  this->uiPortId = val;
}

void COcmMode_t::__set_uiMode(const int32_t val) {
  this->uiMode = val;
}
std::ostream& operator<<(std::ostream& out, const COcmMode_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmMode_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMode);
          this->__isset.uiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmMode_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmMode_t");

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmMode_t &a, COcmMode_t &b) {
  using ::std::swap;
  swap(a.uiPortId, b.uiPortId);
  swap(a.uiMode, b.uiMode);
  swap(a.__isset, b.__isset);
}

COcmMode_t::COcmMode_t(const COcmMode_t& other266) {
  uiPortId = other266.uiPortId;
  uiMode = other266.uiMode;
  __isset = other266.__isset;
}
COcmMode_t& COcmMode_t::operator=(const COcmMode_t& other267) {
  uiPortId = other267.uiPortId;
  uiMode = other267.uiMode;
  __isset = other267.__isset;
  return *this;
}
void COcmMode_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmMode_t(";
  out << "uiPortId=" << to_string(uiPortId);
  out << ", " << "uiMode=" << to_string(uiMode);
  out << ")";
}


COcmPortCali_t::~COcmPortCali_t() noexcept {
}


void COcmPortCali_t::__set_dRevL(const double val) {
  this->dRevL = val;
}

void COcmPortCali_t::__set_dK3L(const double val) {
  this->dK3L = val;
}

void COcmPortCali_t::__set_dK2L(const double val) {
  this->dK2L = val;
}

void COcmPortCali_t::__set_dK1L(const double val) {
  this->dK1L = val;
}

void COcmPortCali_t::__set_dCL(const double val) {
  this->dCL = val;
}

void COcmPortCali_t::__set_dRevN(const double val) {
  this->dRevN = val;
}

void COcmPortCali_t::__set_dK3N(const double val) {
  this->dK3N = val;
}

void COcmPortCali_t::__set_dK2N(const double val) {
  this->dK2N = val;
}

void COcmPortCali_t::__set_dK1N(const double val) {
  this->dK1N = val;
}

void COcmPortCali_t::__set_dCN(const double val) {
  this->dCN = val;
}

void COcmPortCali_t::__set_dRevH(const double val) {
  this->dRevH = val;
}

void COcmPortCali_t::__set_dK3H(const double val) {
  this->dK3H = val;
}

void COcmPortCali_t::__set_dK2H(const double val) {
  this->dK2H = val;
}

void COcmPortCali_t::__set_dK1H(const double val) {
  this->dK1H = val;
}

void COcmPortCali_t::__set_dCH(const double val) {
  this->dCH = val;
}
std::ostream& operator<<(std::ostream& out, const COcmPortCali_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmPortCali_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dRevL);
          this->__isset.dRevL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK3L);
          this->__isset.dK3L = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK2L);
          this->__isset.dK2L = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK1L);
          this->__isset.dK1L = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dCL);
          this->__isset.dCL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dRevN);
          this->__isset.dRevN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK3N);
          this->__isset.dK3N = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK2N);
          this->__isset.dK2N = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK1N);
          this->__isset.dK1N = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dCN);
          this->__isset.dCN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dRevH);
          this->__isset.dRevH = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK3H);
          this->__isset.dK3H = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK2H);
          this->__isset.dK2H = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK1H);
          this->__isset.dK1H = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dCH);
          this->__isset.dCH = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmPortCali_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmPortCali_t");

  xfer += oprot->writeFieldBegin("dRevL", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->dRevL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK3L", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->dK3L);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK2L", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dK2L);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK1L", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->dK1L);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dCL", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->dCL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dRevN", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->dRevN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK3N", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->dK3N);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK2N", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->dK2N);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK1N", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->dK1N);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dCN", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->dCN);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dRevH", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->dRevH);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK3H", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->dK3H);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK2H", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->dK2H);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK1H", ::apache::thrift::protocol::T_DOUBLE, 14);
  xfer += oprot->writeDouble(this->dK1H);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dCH", ::apache::thrift::protocol::T_DOUBLE, 15);
  xfer += oprot->writeDouble(this->dCH);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmPortCali_t &a, COcmPortCali_t &b) {
  using ::std::swap;
  swap(a.dRevL, b.dRevL);
  swap(a.dK3L, b.dK3L);
  swap(a.dK2L, b.dK2L);
  swap(a.dK1L, b.dK1L);
  swap(a.dCL, b.dCL);
  swap(a.dRevN, b.dRevN);
  swap(a.dK3N, b.dK3N);
  swap(a.dK2N, b.dK2N);
  swap(a.dK1N, b.dK1N);
  swap(a.dCN, b.dCN);
  swap(a.dRevH, b.dRevH);
  swap(a.dK3H, b.dK3H);
  swap(a.dK2H, b.dK2H);
  swap(a.dK1H, b.dK1H);
  swap(a.dCH, b.dCH);
  swap(a.__isset, b.__isset);
}

COcmPortCali_t::COcmPortCali_t(const COcmPortCali_t& other268) {
  dRevL = other268.dRevL;
  dK3L = other268.dK3L;
  dK2L = other268.dK2L;
  dK1L = other268.dK1L;
  dCL = other268.dCL;
  dRevN = other268.dRevN;
  dK3N = other268.dK3N;
  dK2N = other268.dK2N;
  dK1N = other268.dK1N;
  dCN = other268.dCN;
  dRevH = other268.dRevH;
  dK3H = other268.dK3H;
  dK2H = other268.dK2H;
  dK1H = other268.dK1H;
  dCH = other268.dCH;
  __isset = other268.__isset;
}
COcmPortCali_t& COcmPortCali_t::operator=(const COcmPortCali_t& other269) {
  dRevL = other269.dRevL;
  dK3L = other269.dK3L;
  dK2L = other269.dK2L;
  dK1L = other269.dK1L;
  dCL = other269.dCL;
  dRevN = other269.dRevN;
  dK3N = other269.dK3N;
  dK2N = other269.dK2N;
  dK1N = other269.dK1N;
  dCN = other269.dCN;
  dRevH = other269.dRevH;
  dK3H = other269.dK3H;
  dK2H = other269.dK2H;
  dK1H = other269.dK1H;
  dCH = other269.dCH;
  __isset = other269.__isset;
  return *this;
}
void COcmPortCali_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmPortCali_t(";
  out << "dRevL=" << to_string(dRevL);
  out << ", " << "dK3L=" << to_string(dK3L);
  out << ", " << "dK2L=" << to_string(dK2L);
  out << ", " << "dK1L=" << to_string(dK1L);
  out << ", " << "dCL=" << to_string(dCL);
  out << ", " << "dRevN=" << to_string(dRevN);
  out << ", " << "dK3N=" << to_string(dK3N);
  out << ", " << "dK2N=" << to_string(dK2N);
  out << ", " << "dK1N=" << to_string(dK1N);
  out << ", " << "dCN=" << to_string(dCN);
  out << ", " << "dRevH=" << to_string(dRevH);
  out << ", " << "dK3H=" << to_string(dK3H);
  out << ", " << "dK2H=" << to_string(dK2H);
  out << ", " << "dK1H=" << to_string(dK1H);
  out << ", " << "dCH=" << to_string(dCH);
  out << ")";
}


COcmCali_t::~COcmCali_t() noexcept {
}


void COcmCali_t::__set_stOcmPortCali(const std::vector<COcmPortCali_t> & val) {
  this->stOcmPortCali = val;
}

void COcmCali_t::__set_aucRev(const std::string& val) {
  this->aucRev = val;
}

void COcmCali_t::__set_ulCrc32(const int32_t val) {
  this->ulCrc32 = val;
}
std::ostream& operator<<(std::ostream& out, const COcmCali_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmCali_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stOcmPortCali.clear();
            uint32_t _size270;
            ::apache::thrift::protocol::TType _etype273;
            xfer += iprot->readListBegin(_etype273, _size270);
            this->stOcmPortCali.resize(_size270);
            uint32_t _i274;
            for (_i274 = 0; _i274 < _size270; ++_i274)
            {
              xfer += this->stOcmPortCali[_i274].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stOcmPortCali = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucRev);
          this->__isset.aucRev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulCrc32);
          this->__isset.ulCrc32 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmCali_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmCali_t");

  xfer += oprot->writeFieldBegin("stOcmPortCali", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stOcmPortCali.size()));
    std::vector<COcmPortCali_t> ::const_iterator _iter275;
    for (_iter275 = this->stOcmPortCali.begin(); _iter275 != this->stOcmPortCali.end(); ++_iter275)
    {
      xfer += (*_iter275).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucRev", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->aucRev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulCrc32", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ulCrc32);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmCali_t &a, COcmCali_t &b) {
  using ::std::swap;
  swap(a.stOcmPortCali, b.stOcmPortCali);
  swap(a.aucRev, b.aucRev);
  swap(a.ulCrc32, b.ulCrc32);
  swap(a.__isset, b.__isset);
}

COcmCali_t::COcmCali_t(const COcmCali_t& other276) {
  stOcmPortCali = other276.stOcmPortCali;
  aucRev = other276.aucRev;
  ulCrc32 = other276.ulCrc32;
  __isset = other276.__isset;
}
COcmCali_t& COcmCali_t::operator=(const COcmCali_t& other277) {
  stOcmPortCali = other277.stOcmPortCali;
  aucRev = other277.aucRev;
  ulCrc32 = other277.ulCrc32;
  __isset = other277.__isset;
  return *this;
}
void COcmCali_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmCali_t(";
  out << "stOcmPortCali=" << to_string(stOcmPortCali);
  out << ", " << "aucRev=" << to_string(aucRev);
  out << ", " << "ulCrc32=" << to_string(ulCrc32);
  out << ")";
}


COaCaliData_t::~COaCaliData_t() noexcept {
}


void COaCaliData_t::__set_stOtdrCaliInfo(const COtdrStartOffsetAll_t& val) {
  this->stOtdrCaliInfo = val;
}

void COaCaliData_t::__set_stOcmCaliInfo(const COcmCali_t& val) {
  this->stOcmCaliInfo = val;
}
std::ostream& operator<<(std::ostream& out, const COaCaliData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaCaliData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOtdrCaliInfo.read(iprot);
          this->__isset.stOtdrCaliInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOcmCaliInfo.read(iprot);
          this->__isset.stOcmCaliInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaCaliData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaCaliData_t");

  xfer += oprot->writeFieldBegin("stOtdrCaliInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stOtdrCaliInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stOcmCaliInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stOcmCaliInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaCaliData_t &a, COaCaliData_t &b) {
  using ::std::swap;
  swap(a.stOtdrCaliInfo, b.stOtdrCaliInfo);
  swap(a.stOcmCaliInfo, b.stOcmCaliInfo);
  swap(a.__isset, b.__isset);
}

COaCaliData_t::COaCaliData_t(const COaCaliData_t& other278) {
  stOtdrCaliInfo = other278.stOtdrCaliInfo;
  stOcmCaliInfo = other278.stOcmCaliInfo;
  __isset = other278.__isset;
}
COaCaliData_t& COaCaliData_t::operator=(const COaCaliData_t& other279) {
  stOtdrCaliInfo = other279.stOtdrCaliInfo;
  stOcmCaliInfo = other279.stOcmCaliInfo;
  __isset = other279.__isset;
  return *this;
}
void COaCaliData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaCaliData_t(";
  out << "stOtdrCaliInfo=" << to_string(stOtdrCaliInfo);
  out << ", " << "stOcmCaliInfo=" << to_string(stOcmCaliInfo);
  out << ")";
}


COaCfgData_t::~COaCfgData_t() noexcept {
}


void COaCfgData_t::__set_ucMode(const int8_t val) {
  this->ucMode = val;
}

void COaCfgData_t::__set_ucGainRange(const int8_t val) {
  this->ucGainRange = val;
}

void COaCfgData_t::__set_ucRflAlmEnable(const int8_t val) {
  this->ucRflAlmEnable = val;
}

void COaCfgData_t::__set_ucLosAlmMode(const int8_t val) {
  this->ucLosAlmMode = val;
}

void COaCfgData_t::__set_ucMute(const int8_t val) {
  this->ucMute = val;
}

void COaCfgData_t::__set_ucMuteMode(const int8_t val) {
  this->ucMuteMode = val;
}

void COaCfgData_t::__set_bPumpEnable(const bool val) {
  this->bPumpEnable = val;
}

void COaCfgData_t::__set_bAlsEnable(const bool val) {
  this->bAlsEnable = val;
}

void COaCfgData_t::__set_bSafeEnable(const bool val) {
  this->bSafeEnable = val;
}

void COaCfgData_t::__set_bAprEnable(const bool val) {
  this->bAprEnable = val;
}

void COaCfgData_t::__set_ucBandType(const int8_t val) {
  this->ucBandType = val;
}

void COaCfgData_t::__set_aucPortStatus(const std::string& val) {
  this->aucPortStatus = val;
}

void COaCfgData_t::__set_sGain(const int16_t val) {
  this->sGain = val;
}

void COaCfgData_t::__set_sApcTarget(const int16_t val) {
  this->sApcTarget = val;
}

void COaCfgData_t::__set_sTilt(const int16_t val) {
  this->sTilt = val;
}

void COaCfgData_t::__set_sAprPower(const int16_t val) {
  this->sAprPower = val;
}

void COaCfgData_t::__set_asPumpCurrent(const std::vector<int16_t> & val) {
  this->asPumpCurrent = val;
}

void COaCfgData_t::__set_sInThr(const int16_t val) {
  this->sInThr = val;
}

void COaCfgData_t::__set_sInHys(const int16_t val) {
  this->sInHys = val;
}

void COaCfgData_t::__set_sOutThr(const int16_t val) {
  this->sOutThr = val;
}

void COaCfgData_t::__set_sOutHys(const int16_t val) {
  this->sOutHys = val;
}

void COaCfgData_t::__set_sMsaInThr(const int16_t val) {
  this->sMsaInThr = val;
}

void COaCfgData_t::__set_sMsaInHys(const int16_t val) {
  this->sMsaInHys = val;
}

void COaCfgData_t::__set_sMsaOutThr(const int16_t val) {
  this->sMsaOutThr = val;
}

void COaCfgData_t::__set_sMsaOutHys(const int16_t val) {
  this->sMsaOutHys = val;
}

void COaCfgData_t::__set_sAttn(const int16_t val) {
  this->sAttn = val;
}

void COaCfgData_t::__set_stCaliData(const COaCaliData_t& val) {
  this->stCaliData = val;
}
std::ostream& operator<<(std::ostream& out, const COaCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucMode);
          this->__isset.ucMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucGainRange);
          this->__isset.ucGainRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucRflAlmEnable);
          this->__isset.ucRflAlmEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucLosAlmMode);
          this->__isset.ucLosAlmMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucMute);
          this->__isset.ucMute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucMuteMode);
          this->__isset.ucMuteMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bPumpEnable);
          this->__isset.bPumpEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bAlsEnable);
          this->__isset.bAlsEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bSafeEnable);
          this->__isset.bSafeEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bAprEnable);
          this->__isset.bAprEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucBandType);
          this->__isset.ucBandType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucPortStatus);
          this->__isset.aucPortStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sGain);
          this->__isset.sGain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sApcTarget);
          this->__isset.sApcTarget = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTilt);
          this->__isset.sTilt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAprPower);
          this->__isset.sAprPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPumpCurrent.clear();
            uint32_t _size280;
            ::apache::thrift::protocol::TType _etype283;
            xfer += iprot->readListBegin(_etype283, _size280);
            this->asPumpCurrent.resize(_size280);
            uint32_t _i284;
            for (_i284 = 0; _i284 < _size280; ++_i284)
            {
              xfer += iprot->readI16(this->asPumpCurrent[_i284]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPumpCurrent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sInThr);
          this->__isset.sInThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sInHys);
          this->__isset.sInHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutThr);
          this->__isset.sOutThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutHys);
          this->__isset.sOutHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMsaInThr);
          this->__isset.sMsaInThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMsaInHys);
          this->__isset.sMsaInHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMsaOutThr);
          this->__isset.sMsaOutThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMsaOutHys);
          this->__isset.sMsaOutHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAttn);
          this->__isset.sAttn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stCaliData.read(iprot);
          this->__isset.stCaliData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaCfgData_t");

  xfer += oprot->writeFieldBegin("ucMode", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucGainRange", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucGainRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucRflAlmEnable", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->ucRflAlmEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucLosAlmMode", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->ucLosAlmMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucMute", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->ucMute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucMuteMode", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->ucMuteMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bPumpEnable", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->bPumpEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bAlsEnable", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->bAlsEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bSafeEnable", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->bSafeEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bAprEnable", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->bAprEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucBandType", ::apache::thrift::protocol::T_BYTE, 11);
  xfer += oprot->writeByte(this->ucBandType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucPortStatus", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeBinary(this->aucPortStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sGain", ::apache::thrift::protocol::T_I16, 13);
  xfer += oprot->writeI16(this->sGain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sApcTarget", ::apache::thrift::protocol::T_I16, 14);
  xfer += oprot->writeI16(this->sApcTarget);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTilt", ::apache::thrift::protocol::T_I16, 15);
  xfer += oprot->writeI16(this->sTilt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAprPower", ::apache::thrift::protocol::T_I16, 16);
  xfer += oprot->writeI16(this->sAprPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPumpCurrent", ::apache::thrift::protocol::T_LIST, 17);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPumpCurrent.size()));
    std::vector<int16_t> ::const_iterator _iter285;
    for (_iter285 = this->asPumpCurrent.begin(); _iter285 != this->asPumpCurrent.end(); ++_iter285)
    {
      xfer += oprot->writeI16((*_iter285));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sInThr", ::apache::thrift::protocol::T_I16, 18);
  xfer += oprot->writeI16(this->sInThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sInHys", ::apache::thrift::protocol::T_I16, 19);
  xfer += oprot->writeI16(this->sInHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutThr", ::apache::thrift::protocol::T_I16, 20);
  xfer += oprot->writeI16(this->sOutThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutHys", ::apache::thrift::protocol::T_I16, 21);
  xfer += oprot->writeI16(this->sOutHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMsaInThr", ::apache::thrift::protocol::T_I16, 22);
  xfer += oprot->writeI16(this->sMsaInThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMsaInHys", ::apache::thrift::protocol::T_I16, 23);
  xfer += oprot->writeI16(this->sMsaInHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMsaOutThr", ::apache::thrift::protocol::T_I16, 24);
  xfer += oprot->writeI16(this->sMsaOutThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMsaOutHys", ::apache::thrift::protocol::T_I16, 25);
  xfer += oprot->writeI16(this->sMsaOutHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAttn", ::apache::thrift::protocol::T_I16, 26);
  xfer += oprot->writeI16(this->sAttn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stCaliData", ::apache::thrift::protocol::T_STRUCT, 27);
  xfer += this->stCaliData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaCfgData_t &a, COaCfgData_t &b) {
  using ::std::swap;
  swap(a.ucMode, b.ucMode);
  swap(a.ucGainRange, b.ucGainRange);
  swap(a.ucRflAlmEnable, b.ucRflAlmEnable);
  swap(a.ucLosAlmMode, b.ucLosAlmMode);
  swap(a.ucMute, b.ucMute);
  swap(a.ucMuteMode, b.ucMuteMode);
  swap(a.bPumpEnable, b.bPumpEnable);
  swap(a.bAlsEnable, b.bAlsEnable);
  swap(a.bSafeEnable, b.bSafeEnable);
  swap(a.bAprEnable, b.bAprEnable);
  swap(a.ucBandType, b.ucBandType);
  swap(a.aucPortStatus, b.aucPortStatus);
  swap(a.sGain, b.sGain);
  swap(a.sApcTarget, b.sApcTarget);
  swap(a.sTilt, b.sTilt);
  swap(a.sAprPower, b.sAprPower);
  swap(a.asPumpCurrent, b.asPumpCurrent);
  swap(a.sInThr, b.sInThr);
  swap(a.sInHys, b.sInHys);
  swap(a.sOutThr, b.sOutThr);
  swap(a.sOutHys, b.sOutHys);
  swap(a.sMsaInThr, b.sMsaInThr);
  swap(a.sMsaInHys, b.sMsaInHys);
  swap(a.sMsaOutThr, b.sMsaOutThr);
  swap(a.sMsaOutHys, b.sMsaOutHys);
  swap(a.sAttn, b.sAttn);
  swap(a.stCaliData, b.stCaliData);
  swap(a.__isset, b.__isset);
}

COaCfgData_t::COaCfgData_t(const COaCfgData_t& other286) {
  ucMode = other286.ucMode;
  ucGainRange = other286.ucGainRange;
  ucRflAlmEnable = other286.ucRflAlmEnable;
  ucLosAlmMode = other286.ucLosAlmMode;
  ucMute = other286.ucMute;
  ucMuteMode = other286.ucMuteMode;
  bPumpEnable = other286.bPumpEnable;
  bAlsEnable = other286.bAlsEnable;
  bSafeEnable = other286.bSafeEnable;
  bAprEnable = other286.bAprEnable;
  ucBandType = other286.ucBandType;
  aucPortStatus = other286.aucPortStatus;
  sGain = other286.sGain;
  sApcTarget = other286.sApcTarget;
  sTilt = other286.sTilt;
  sAprPower = other286.sAprPower;
  asPumpCurrent = other286.asPumpCurrent;
  sInThr = other286.sInThr;
  sInHys = other286.sInHys;
  sOutThr = other286.sOutThr;
  sOutHys = other286.sOutHys;
  sMsaInThr = other286.sMsaInThr;
  sMsaInHys = other286.sMsaInHys;
  sMsaOutThr = other286.sMsaOutThr;
  sMsaOutHys = other286.sMsaOutHys;
  sAttn = other286.sAttn;
  stCaliData = other286.stCaliData;
  __isset = other286.__isset;
}
COaCfgData_t& COaCfgData_t::operator=(const COaCfgData_t& other287) {
  ucMode = other287.ucMode;
  ucGainRange = other287.ucGainRange;
  ucRflAlmEnable = other287.ucRflAlmEnable;
  ucLosAlmMode = other287.ucLosAlmMode;
  ucMute = other287.ucMute;
  ucMuteMode = other287.ucMuteMode;
  bPumpEnable = other287.bPumpEnable;
  bAlsEnable = other287.bAlsEnable;
  bSafeEnable = other287.bSafeEnable;
  bAprEnable = other287.bAprEnable;
  ucBandType = other287.ucBandType;
  aucPortStatus = other287.aucPortStatus;
  sGain = other287.sGain;
  sApcTarget = other287.sApcTarget;
  sTilt = other287.sTilt;
  sAprPower = other287.sAprPower;
  asPumpCurrent = other287.asPumpCurrent;
  sInThr = other287.sInThr;
  sInHys = other287.sInHys;
  sOutThr = other287.sOutThr;
  sOutHys = other287.sOutHys;
  sMsaInThr = other287.sMsaInThr;
  sMsaInHys = other287.sMsaInHys;
  sMsaOutThr = other287.sMsaOutThr;
  sMsaOutHys = other287.sMsaOutHys;
  sAttn = other287.sAttn;
  stCaliData = other287.stCaliData;
  __isset = other287.__isset;
  return *this;
}
void COaCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaCfgData_t(";
  out << "ucMode=" << to_string(ucMode);
  out << ", " << "ucGainRange=" << to_string(ucGainRange);
  out << ", " << "ucRflAlmEnable=" << to_string(ucRflAlmEnable);
  out << ", " << "ucLosAlmMode=" << to_string(ucLosAlmMode);
  out << ", " << "ucMute=" << to_string(ucMute);
  out << ", " << "ucMuteMode=" << to_string(ucMuteMode);
  out << ", " << "bPumpEnable=" << to_string(bPumpEnable);
  out << ", " << "bAlsEnable=" << to_string(bAlsEnable);
  out << ", " << "bSafeEnable=" << to_string(bSafeEnable);
  out << ", " << "bAprEnable=" << to_string(bAprEnable);
  out << ", " << "ucBandType=" << to_string(ucBandType);
  out << ", " << "aucPortStatus=" << to_string(aucPortStatus);
  out << ", " << "sGain=" << to_string(sGain);
  out << ", " << "sApcTarget=" << to_string(sApcTarget);
  out << ", " << "sTilt=" << to_string(sTilt);
  out << ", " << "sAprPower=" << to_string(sAprPower);
  out << ", " << "asPumpCurrent=" << to_string(asPumpCurrent);
  out << ", " << "sInThr=" << to_string(sInThr);
  out << ", " << "sInHys=" << to_string(sInHys);
  out << ", " << "sOutThr=" << to_string(sOutThr);
  out << ", " << "sOutHys=" << to_string(sOutHys);
  out << ", " << "sMsaInThr=" << to_string(sMsaInThr);
  out << ", " << "sMsaInHys=" << to_string(sMsaInHys);
  out << ", " << "sMsaOutThr=" << to_string(sMsaOutThr);
  out << ", " << "sMsaOutHys=" << to_string(sMsaOutHys);
  out << ", " << "sAttn=" << to_string(sAttn);
  out << ", " << "stCaliData=" << to_string(stCaliData);
  out << ")";
}


COaAlarm_t::~COaAlarm_t() noexcept {
}


void COaAlarm_t::__set_bFailure(const bool val) {
  this->bFailure = val;
}

void COaAlarm_t::__set_bDisable(const bool val) {
  this->bDisable = val;
}

void COaAlarm_t::__set_bInnerErr(const bool val) {
  this->bInnerErr = val;
}

void COaAlarm_t::__set_bInLos(const bool val) {
  this->bInLos = val;
}

void COaAlarm_t::__set_bOutLos(const bool val) {
  this->bOutLos = val;
}

void COaAlarm_t::__set_bMsaInLos(const bool val) {
  this->bMsaInLos = val;
}

void COaAlarm_t::__set_bMsaOutLos(const bool val) {
  this->bMsaOutLos = val;
}

void COaAlarm_t::__set_bRFL(const bool val) {
  this->bRFL = val;
}

void COaAlarm_t::__set_bOOG(const bool val) {
  this->bOOG = val;
}

void COaAlarm_t::__set_bOOP(const bool val) {
  this->bOOP = val;
}

void COaAlarm_t::__set_abPumpEOL(const std::vector<bool> & val) {
  this->abPumpEOL = val;
}

void COaAlarm_t::__set_abPumpTemp(const std::vector<bool> & val) {
  this->abPumpTemp = val;
}

void COaAlarm_t::__set_bCaseTemp(const bool val) {
  this->bCaseTemp = val;
}

void COaAlarm_t::__set_bPumpTempHigh(const bool val) {
  this->bPumpTempHigh = val;
}

void COaAlarm_t::__set_bPumpTempLow(const bool val) {
  this->bPumpTempLow = val;
}

void COaAlarm_t::__set_bLimited(const bool val) {
  this->bLimited = val;
}

void COaAlarm_t::__set_bApsd(const bool val) {
  this->bApsd = val;
}

void COaAlarm_t::__set_bInLow(const bool val) {
  this->bInLow = val;
}

void COaAlarm_t::__set_bOutLow(const bool val) {
  this->bOutLow = val;
}

void COaAlarm_t::__set_bInHigh(const bool val) {
  this->bInHigh = val;
}

void COaAlarm_t::__set_bOutHigh(const bool val) {
  this->bOutHigh = val;
}

void COaAlarm_t::__set_bFiberTemp(const bool val) {
  this->bFiberTemp = val;
}

void COaAlarm_t::__set_bHeaterTemp(const bool val) {
  this->bHeaterTemp = val;
}

void COaAlarm_t::__set_bApr(const bool val) {
  this->bApr = val;
}
std::ostream& operator<<(std::ostream& out, const COaAlarm_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaAlarm_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bFailure);
          this->__isset.bFailure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bDisable);
          this->__isset.bDisable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bInnerErr);
          this->__isset.bInnerErr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bInLos);
          this->__isset.bInLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOutLos);
          this->__isset.bOutLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bMsaInLos);
          this->__isset.bMsaInLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bMsaOutLos);
          this->__isset.bMsaOutLos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bRFL);
          this->__isset.bRFL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOOG);
          this->__isset.bOOG = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOOP);
          this->__isset.bOOP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abPumpEOL.clear();
            uint32_t _size288;
            ::apache::thrift::protocol::TType _etype291;
            xfer += iprot->readListBegin(_etype291, _size288);
            this->abPumpEOL.resize(_size288);
            uint32_t _i292;
            for (_i292 = 0; _i292 < _size288; ++_i292)
            {
              xfer += iprot->readBool(this->abPumpEOL[_i292]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abPumpEOL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abPumpTemp.clear();
            uint32_t _size293;
            ::apache::thrift::protocol::TType _etype296;
            xfer += iprot->readListBegin(_etype296, _size293);
            this->abPumpTemp.resize(_size293);
            uint32_t _i297;
            for (_i297 = 0; _i297 < _size293; ++_i297)
            {
              xfer += iprot->readBool(this->abPumpTemp[_i297]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abPumpTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bCaseTemp);
          this->__isset.bCaseTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bPumpTempHigh);
          this->__isset.bPumpTempHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bPumpTempLow);
          this->__isset.bPumpTempLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bLimited);
          this->__isset.bLimited = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bApsd);
          this->__isset.bApsd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bInLow);
          this->__isset.bInLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOutLow);
          this->__isset.bOutLow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bInHigh);
          this->__isset.bInHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOutHigh);
          this->__isset.bOutHigh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bFiberTemp);
          this->__isset.bFiberTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bHeaterTemp);
          this->__isset.bHeaterTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bApr);
          this->__isset.bApr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaAlarm_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaAlarm_t");

  xfer += oprot->writeFieldBegin("bFailure", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bFailure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bDisable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bDisable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bInnerErr", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->bInnerErr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bInLos", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bInLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOutLos", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->bOutLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bMsaInLos", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->bMsaInLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bMsaOutLos", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->bMsaOutLos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bRFL", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->bRFL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOOG", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->bOOG);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOOP", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->bOOP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abPumpEOL", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abPumpEOL.size()));
    std::vector<bool> ::const_iterator _iter298;
    for (_iter298 = this->abPumpEOL.begin(); _iter298 != this->abPumpEOL.end(); ++_iter298)
    {
      xfer += oprot->writeBool((*_iter298));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abPumpTemp", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abPumpTemp.size()));
    std::vector<bool> ::const_iterator _iter299;
    for (_iter299 = this->abPumpTemp.begin(); _iter299 != this->abPumpTemp.end(); ++_iter299)
    {
      xfer += oprot->writeBool((*_iter299));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bCaseTemp", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->bCaseTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bPumpTempHigh", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->bPumpTempHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bPumpTempLow", ::apache::thrift::protocol::T_BOOL, 15);
  xfer += oprot->writeBool(this->bPumpTempLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bLimited", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->bLimited);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bApsd", ::apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->bApsd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bInLow", ::apache::thrift::protocol::T_BOOL, 18);
  xfer += oprot->writeBool(this->bInLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOutLow", ::apache::thrift::protocol::T_BOOL, 19);
  xfer += oprot->writeBool(this->bOutLow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bInHigh", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->bInHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOutHigh", ::apache::thrift::protocol::T_BOOL, 21);
  xfer += oprot->writeBool(this->bOutHigh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bFiberTemp", ::apache::thrift::protocol::T_BOOL, 22);
  xfer += oprot->writeBool(this->bFiberTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bHeaterTemp", ::apache::thrift::protocol::T_BOOL, 23);
  xfer += oprot->writeBool(this->bHeaterTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bApr", ::apache::thrift::protocol::T_BOOL, 24);
  xfer += oprot->writeBool(this->bApr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaAlarm_t &a, COaAlarm_t &b) {
  using ::std::swap;
  swap(a.bFailure, b.bFailure);
  swap(a.bDisable, b.bDisable);
  swap(a.bInnerErr, b.bInnerErr);
  swap(a.bInLos, b.bInLos);
  swap(a.bOutLos, b.bOutLos);
  swap(a.bMsaInLos, b.bMsaInLos);
  swap(a.bMsaOutLos, b.bMsaOutLos);
  swap(a.bRFL, b.bRFL);
  swap(a.bOOG, b.bOOG);
  swap(a.bOOP, b.bOOP);
  swap(a.abPumpEOL, b.abPumpEOL);
  swap(a.abPumpTemp, b.abPumpTemp);
  swap(a.bCaseTemp, b.bCaseTemp);
  swap(a.bPumpTempHigh, b.bPumpTempHigh);
  swap(a.bPumpTempLow, b.bPumpTempLow);
  swap(a.bLimited, b.bLimited);
  swap(a.bApsd, b.bApsd);
  swap(a.bInLow, b.bInLow);
  swap(a.bOutLow, b.bOutLow);
  swap(a.bInHigh, b.bInHigh);
  swap(a.bOutHigh, b.bOutHigh);
  swap(a.bFiberTemp, b.bFiberTemp);
  swap(a.bHeaterTemp, b.bHeaterTemp);
  swap(a.bApr, b.bApr);
  swap(a.__isset, b.__isset);
}

COaAlarm_t::COaAlarm_t(const COaAlarm_t& other300) {
  bFailure = other300.bFailure;
  bDisable = other300.bDisable;
  bInnerErr = other300.bInnerErr;
  bInLos = other300.bInLos;
  bOutLos = other300.bOutLos;
  bMsaInLos = other300.bMsaInLos;
  bMsaOutLos = other300.bMsaOutLos;
  bRFL = other300.bRFL;
  bOOG = other300.bOOG;
  bOOP = other300.bOOP;
  abPumpEOL = other300.abPumpEOL;
  abPumpTemp = other300.abPumpTemp;
  bCaseTemp = other300.bCaseTemp;
  bPumpTempHigh = other300.bPumpTempHigh;
  bPumpTempLow = other300.bPumpTempLow;
  bLimited = other300.bLimited;
  bApsd = other300.bApsd;
  bInLow = other300.bInLow;
  bOutLow = other300.bOutLow;
  bInHigh = other300.bInHigh;
  bOutHigh = other300.bOutHigh;
  bFiberTemp = other300.bFiberTemp;
  bHeaterTemp = other300.bHeaterTemp;
  bApr = other300.bApr;
  __isset = other300.__isset;
}
COaAlarm_t& COaAlarm_t::operator=(const COaAlarm_t& other301) {
  bFailure = other301.bFailure;
  bDisable = other301.bDisable;
  bInnerErr = other301.bInnerErr;
  bInLos = other301.bInLos;
  bOutLos = other301.bOutLos;
  bMsaInLos = other301.bMsaInLos;
  bMsaOutLos = other301.bMsaOutLos;
  bRFL = other301.bRFL;
  bOOG = other301.bOOG;
  bOOP = other301.bOOP;
  abPumpEOL = other301.abPumpEOL;
  abPumpTemp = other301.abPumpTemp;
  bCaseTemp = other301.bCaseTemp;
  bPumpTempHigh = other301.bPumpTempHigh;
  bPumpTempLow = other301.bPumpTempLow;
  bLimited = other301.bLimited;
  bApsd = other301.bApsd;
  bInLow = other301.bInLow;
  bOutLow = other301.bOutLow;
  bInHigh = other301.bInHigh;
  bOutHigh = other301.bOutHigh;
  bFiberTemp = other301.bFiberTemp;
  bHeaterTemp = other301.bHeaterTemp;
  bApr = other301.bApr;
  __isset = other301.__isset;
  return *this;
}
void COaAlarm_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaAlarm_t(";
  out << "bFailure=" << to_string(bFailure);
  out << ", " << "bDisable=" << to_string(bDisable);
  out << ", " << "bInnerErr=" << to_string(bInnerErr);
  out << ", " << "bInLos=" << to_string(bInLos);
  out << ", " << "bOutLos=" << to_string(bOutLos);
  out << ", " << "bMsaInLos=" << to_string(bMsaInLos);
  out << ", " << "bMsaOutLos=" << to_string(bMsaOutLos);
  out << ", " << "bRFL=" << to_string(bRFL);
  out << ", " << "bOOG=" << to_string(bOOG);
  out << ", " << "bOOP=" << to_string(bOOP);
  out << ", " << "abPumpEOL=" << to_string(abPumpEOL);
  out << ", " << "abPumpTemp=" << to_string(abPumpTemp);
  out << ", " << "bCaseTemp=" << to_string(bCaseTemp);
  out << ", " << "bPumpTempHigh=" << to_string(bPumpTempHigh);
  out << ", " << "bPumpTempLow=" << to_string(bPumpTempLow);
  out << ", " << "bLimited=" << to_string(bLimited);
  out << ", " << "bApsd=" << to_string(bApsd);
  out << ", " << "bInLow=" << to_string(bInLow);
  out << ", " << "bOutLow=" << to_string(bOutLow);
  out << ", " << "bInHigh=" << to_string(bInHigh);
  out << ", " << "bOutHigh=" << to_string(bOutHigh);
  out << ", " << "bFiberTemp=" << to_string(bFiberTemp);
  out << ", " << "bHeaterTemp=" << to_string(bHeaterTemp);
  out << ", " << "bApr=" << to_string(bApr);
  out << ")";
}


CMN_THR_HYS_INFO_ST_t::~CMN_THR_HYS_INFO_ST_t() noexcept {
}


void CMN_THR_HYS_INFO_ST_t::__set_iThr(const int32_t val) {
  this->iThr = val;
}

void CMN_THR_HYS_INFO_ST_t::__set_iHys(const int32_t val) {
  this->iHys = val;
}
std::ostream& operator<<(std::ostream& out, const CMN_THR_HYS_INFO_ST_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMN_THR_HYS_INFO_ST_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iThr);
          this->__isset.iThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iHys);
          this->__isset.iHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMN_THR_HYS_INFO_ST_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMN_THR_HYS_INFO_ST_t");

  xfer += oprot->writeFieldBegin("iThr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iHys", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMN_THR_HYS_INFO_ST_t &a, CMN_THR_HYS_INFO_ST_t &b) {
  using ::std::swap;
  swap(a.iThr, b.iThr);
  swap(a.iHys, b.iHys);
  swap(a.__isset, b.__isset);
}

CMN_THR_HYS_INFO_ST_t::CMN_THR_HYS_INFO_ST_t(const CMN_THR_HYS_INFO_ST_t& other302) {
  iThr = other302.iThr;
  iHys = other302.iHys;
  __isset = other302.__isset;
}
CMN_THR_HYS_INFO_ST_t& CMN_THR_HYS_INFO_ST_t::operator=(const CMN_THR_HYS_INFO_ST_t& other303) {
  iThr = other303.iThr;
  iHys = other303.iHys;
  __isset = other303.__isset;
  return *this;
}
void CMN_THR_HYS_INFO_ST_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMN_THR_HYS_INFO_ST_t(";
  out << "iThr=" << to_string(iThr);
  out << ", " << "iHys=" << to_string(iHys);
  out << ")";
}


EDFA_LASER_SAFETY_ST_t::~EDFA_LASER_SAFETY_ST_t() noexcept {
}


void EDFA_LASER_SAFETY_ST_t::__set_stPinIn(const int32_t val) {
  this->stPinIn = val;
}

void EDFA_LASER_SAFETY_ST_t::__set_stPinOut(const int32_t val) {
  this->stPinOut = val;
}
std::ostream& operator<<(std::ostream& out, const EDFA_LASER_SAFETY_ST_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EDFA_LASER_SAFETY_ST_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stPinIn);
          this->__isset.stPinIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stPinOut);
          this->__isset.stPinOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EDFA_LASER_SAFETY_ST_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EDFA_LASER_SAFETY_ST_t");

  xfer += oprot->writeFieldBegin("stPinIn", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stPinIn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stPinOut", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->stPinOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EDFA_LASER_SAFETY_ST_t &a, EDFA_LASER_SAFETY_ST_t &b) {
  using ::std::swap;
  swap(a.stPinIn, b.stPinIn);
  swap(a.stPinOut, b.stPinOut);
  swap(a.__isset, b.__isset);
}

EDFA_LASER_SAFETY_ST_t::EDFA_LASER_SAFETY_ST_t(const EDFA_LASER_SAFETY_ST_t& other304) {
  stPinIn = other304.stPinIn;
  stPinOut = other304.stPinOut;
  __isset = other304.__isset;
}
EDFA_LASER_SAFETY_ST_t& EDFA_LASER_SAFETY_ST_t::operator=(const EDFA_LASER_SAFETY_ST_t& other305) {
  stPinIn = other305.stPinIn;
  stPinOut = other305.stPinOut;
  __isset = other305.__isset;
  return *this;
}
void EDFA_LASER_SAFETY_ST_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EDFA_LASER_SAFETY_ST_t(";
  out << "stPinIn=" << to_string(stPinIn);
  out << ", " << "stPinOut=" << to_string(stPinOut);
  out << ")";
}


COaCurData_t::~COaCurData_t() noexcept {
}


void COaCurData_t::__set_bIsInService(const bool val) {
  this->bIsInService = val;
}

void COaCurData_t::__set_ucModeActual(const int8_t val) {
  this->ucModeActual = val;
}

void COaCurData_t::__set_sInPower(const int16_t val) {
  this->sInPower = val;
}

void COaCurData_t::__set_sOutSigCPower(const int16_t val) {
  this->sOutSigCPower = val;
}

void COaCurData_t::__set_sOutSigLPower(const int16_t val) {
  this->sOutSigLPower = val;
}

void COaCurData_t::__set_sOutTotalPower(const int16_t val) {
  this->sOutTotalPower = val;
}

void COaCurData_t::__set_sPortOutSigCPower(const int16_t val) {
  this->sPortOutSigCPower = val;
}

void COaCurData_t::__set_sPortOutSigLPower(const int16_t val) {
  this->sPortOutSigLPower = val;
}

void COaCurData_t::__set_sPortOutTotalPower(const int16_t val) {
  this->sPortOutTotalPower = val;
}

void COaCurData_t::__set_sMsaInPower(const int16_t val) {
  this->sMsaInPower = val;
}

void COaCurData_t::__set_sMsaOutPower(const int16_t val) {
  this->sMsaOutPower = val;
}

void COaCurData_t::__set_sBackRefPower(const int16_t val) {
  this->sBackRefPower = val;
}

void COaCurData_t::__set_sBackRefRatio(const int16_t val) {
  this->sBackRefRatio = val;
}

void COaCurData_t::__set_sGainActual(const int16_t val) {
  this->sGainActual = val;
}

void COaCurData_t::__set_sTiltActual(const int16_t val) {
  this->sTiltActual = val;
}

void COaCurData_t::__set_asVoaAttnActual(const std::vector<int16_t> & val) {
  this->asVoaAttnActual = val;
}

void COaCurData_t::__set_asCaseTemp(const std::vector<int16_t> & val) {
  this->asCaseTemp = val;
}

void COaCurData_t::__set_asHeaterTemp(const std::vector<int16_t> & val) {
  this->asHeaterTemp = val;
}

void COaCurData_t::__set_asPumpTemp(const std::vector<int16_t> & val) {
  this->asPumpTemp = val;
}

void COaCurData_t::__set_asPumpCurrent(const std::vector<int32_t> & val) {
  this->asPumpCurrent = val;
}

void COaCurData_t::__set_asExtPdPower(const std::vector<int16_t> & val) {
  this->asExtPdPower = val;
}

void COaCurData_t::__set_abDfbEnable(const bool val) {
  this->abDfbEnable = val;
}

void COaCurData_t::__set_abApsdStatus(const bool val) {
  this->abApsdStatus = val;
}

void COaCurData_t::__set_abApsdEvent(const bool val) {
  this->abApsdEvent = val;
}

void COaCurData_t::__set_abApsdEnable(const bool val) {
  this->abApsdEnable = val;
}

void COaCurData_t::__set_uiOtdrSwitchInEx(const int16_t val) {
  this->uiOtdrSwitchInEx = val;
}

void COaCurData_t::__set_uiOtdrSwitch(const int16_t val) {
  this->uiOtdrSwitch = val;
}

void COaCurData_t::__set_uiDFBPwr(const int32_t val) {
  this->uiDFBPwr = val;
}

void COaCurData_t::__set_sDfbInPower2(const int16_t val) {
  this->sDfbInPower2 = val;
}

void COaCurData_t::__set_sDfbOutPower2(const int16_t val) {
  this->sDfbOutPower2 = val;
}

void COaCurData_t::__set_sDfbInPower1(const int16_t val) {
  this->sDfbInPower1 = val;
}

void COaCurData_t::__set_sDfbOutPower1(const int16_t val) {
  this->sDfbOutPower1 = val;
}

void COaCurData_t::__set_sLaserSafetyTxPower(const int16_t val) {
  this->sLaserSafetyTxPower = val;
}

void COaCurData_t::__set_sLaserSafetyRxPower(const int16_t val) {
  this->sLaserSafetyRxPower = val;
}

void COaCurData_t::__set_stLaserSafety(const EDFA_LASER_SAFETY_ST_t& val) {
  this->stLaserSafety = val;
}

void COaCurData_t::__set_astThrHys(const std::vector<std::vector<CMN_THR_HYS_INFO_ST_t> > & val) {
  this->astThrHys = val;
}
std::ostream& operator<<(std::ostream& out, const COaCurData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaCurData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsInService);
          this->__isset.bIsInService = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucModeActual);
          this->__isset.ucModeActual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sInPower);
          this->__isset.sInPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutSigCPower);
          this->__isset.sOutSigCPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutSigLPower);
          this->__isset.sOutSigLPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutTotalPower);
          this->__isset.sOutTotalPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sPortOutSigCPower);
          this->__isset.sPortOutSigCPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sPortOutSigLPower);
          this->__isset.sPortOutSigLPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sPortOutTotalPower);
          this->__isset.sPortOutTotalPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMsaInPower);
          this->__isset.sMsaInPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMsaOutPower);
          this->__isset.sMsaOutPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sBackRefPower);
          this->__isset.sBackRefPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sBackRefRatio);
          this->__isset.sBackRefRatio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sGainActual);
          this->__isset.sGainActual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTiltActual);
          this->__isset.sTiltActual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asVoaAttnActual.clear();
            uint32_t _size306;
            ::apache::thrift::protocol::TType _etype309;
            xfer += iprot->readListBegin(_etype309, _size306);
            this->asVoaAttnActual.resize(_size306);
            uint32_t _i310;
            for (_i310 = 0; _i310 < _size306; ++_i310)
            {
              xfer += iprot->readI16(this->asVoaAttnActual[_i310]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asVoaAttnActual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asCaseTemp.clear();
            uint32_t _size311;
            ::apache::thrift::protocol::TType _etype314;
            xfer += iprot->readListBegin(_etype314, _size311);
            this->asCaseTemp.resize(_size311);
            uint32_t _i315;
            for (_i315 = 0; _i315 < _size311; ++_i315)
            {
              xfer += iprot->readI16(this->asCaseTemp[_i315]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asCaseTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asHeaterTemp.clear();
            uint32_t _size316;
            ::apache::thrift::protocol::TType _etype319;
            xfer += iprot->readListBegin(_etype319, _size316);
            this->asHeaterTemp.resize(_size316);
            uint32_t _i320;
            for (_i320 = 0; _i320 < _size316; ++_i320)
            {
              xfer += iprot->readI16(this->asHeaterTemp[_i320]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asHeaterTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPumpTemp.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->asPumpTemp.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += iprot->readI16(this->asPumpTemp[_i325]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPumpTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPumpCurrent.clear();
            uint32_t _size326;
            ::apache::thrift::protocol::TType _etype329;
            xfer += iprot->readListBegin(_etype329, _size326);
            this->asPumpCurrent.resize(_size326);
            uint32_t _i330;
            for (_i330 = 0; _i330 < _size326; ++_i330)
            {
              xfer += iprot->readI32(this->asPumpCurrent[_i330]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPumpCurrent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asExtPdPower.clear();
            uint32_t _size331;
            ::apache::thrift::protocol::TType _etype334;
            xfer += iprot->readListBegin(_etype334, _size331);
            this->asExtPdPower.resize(_size331);
            uint32_t _i335;
            for (_i335 = 0; _i335 < _size331; ++_i335)
            {
              xfer += iprot->readI16(this->asExtPdPower[_i335]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asExtPdPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abDfbEnable);
          this->__isset.abDfbEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abApsdStatus);
          this->__isset.abApsdStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abApsdEvent);
          this->__isset.abApsdEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->abApsdEnable);
          this->__isset.abApsdEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->uiOtdrSwitchInEx);
          this->__isset.uiOtdrSwitchInEx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->uiOtdrSwitch);
          this->__isset.uiOtdrSwitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDFBPwr);
          this->__isset.uiDFBPwr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDfbInPower2);
          this->__isset.sDfbInPower2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDfbOutPower2);
          this->__isset.sDfbOutPower2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDfbInPower1);
          this->__isset.sDfbInPower1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDfbOutPower1);
          this->__isset.sDfbOutPower1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLaserSafetyTxPower);
          this->__isset.sLaserSafetyTxPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sLaserSafetyRxPower);
          this->__isset.sLaserSafetyRxPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stLaserSafety.read(iprot);
          this->__isset.stLaserSafety = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astThrHys.clear();
            uint32_t _size336;
            ::apache::thrift::protocol::TType _etype339;
            xfer += iprot->readListBegin(_etype339, _size336);
            this->astThrHys.resize(_size336);
            uint32_t _i340;
            for (_i340 = 0; _i340 < _size336; ++_i340)
            {
              {
                this->astThrHys[_i340].clear();
                uint32_t _size341;
                ::apache::thrift::protocol::TType _etype344;
                xfer += iprot->readListBegin(_etype344, _size341);
                this->astThrHys[_i340].resize(_size341);
                uint32_t _i345;
                for (_i345 = 0; _i345 < _size341; ++_i345)
                {
                  xfer += this->astThrHys[_i340][_i345].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astThrHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaCurData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaCurData_t");

  xfer += oprot->writeFieldBegin("bIsInService", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bIsInService);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucModeActual", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucModeActual);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sInPower", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sInPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutSigCPower", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sOutSigCPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutSigLPower", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->sOutSigLPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutTotalPower", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->sOutTotalPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sPortOutSigCPower", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->sPortOutSigCPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sPortOutSigLPower", ::apache::thrift::protocol::T_I16, 8);
  xfer += oprot->writeI16(this->sPortOutSigLPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sPortOutTotalPower", ::apache::thrift::protocol::T_I16, 9);
  xfer += oprot->writeI16(this->sPortOutTotalPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMsaInPower", ::apache::thrift::protocol::T_I16, 10);
  xfer += oprot->writeI16(this->sMsaInPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMsaOutPower", ::apache::thrift::protocol::T_I16, 11);
  xfer += oprot->writeI16(this->sMsaOutPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sBackRefPower", ::apache::thrift::protocol::T_I16, 12);
  xfer += oprot->writeI16(this->sBackRefPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sBackRefRatio", ::apache::thrift::protocol::T_I16, 13);
  xfer += oprot->writeI16(this->sBackRefRatio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sGainActual", ::apache::thrift::protocol::T_I16, 14);
  xfer += oprot->writeI16(this->sGainActual);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTiltActual", ::apache::thrift::protocol::T_I16, 15);
  xfer += oprot->writeI16(this->sTiltActual);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asVoaAttnActual", ::apache::thrift::protocol::T_LIST, 16);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asVoaAttnActual.size()));
    std::vector<int16_t> ::const_iterator _iter346;
    for (_iter346 = this->asVoaAttnActual.begin(); _iter346 != this->asVoaAttnActual.end(); ++_iter346)
    {
      xfer += oprot->writeI16((*_iter346));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asCaseTemp", ::apache::thrift::protocol::T_LIST, 17);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asCaseTemp.size()));
    std::vector<int16_t> ::const_iterator _iter347;
    for (_iter347 = this->asCaseTemp.begin(); _iter347 != this->asCaseTemp.end(); ++_iter347)
    {
      xfer += oprot->writeI16((*_iter347));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asHeaterTemp", ::apache::thrift::protocol::T_LIST, 18);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asHeaterTemp.size()));
    std::vector<int16_t> ::const_iterator _iter348;
    for (_iter348 = this->asHeaterTemp.begin(); _iter348 != this->asHeaterTemp.end(); ++_iter348)
    {
      xfer += oprot->writeI16((*_iter348));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPumpTemp", ::apache::thrift::protocol::T_LIST, 19);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPumpTemp.size()));
    std::vector<int16_t> ::const_iterator _iter349;
    for (_iter349 = this->asPumpTemp.begin(); _iter349 != this->asPumpTemp.end(); ++_iter349)
    {
      xfer += oprot->writeI16((*_iter349));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPumpCurrent", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->asPumpCurrent.size()));
    std::vector<int32_t> ::const_iterator _iter350;
    for (_iter350 = this->asPumpCurrent.begin(); _iter350 != this->asPumpCurrent.end(); ++_iter350)
    {
      xfer += oprot->writeI32((*_iter350));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asExtPdPower", ::apache::thrift::protocol::T_LIST, 21);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asExtPdPower.size()));
    std::vector<int16_t> ::const_iterator _iter351;
    for (_iter351 = this->asExtPdPower.begin(); _iter351 != this->asExtPdPower.end(); ++_iter351)
    {
      xfer += oprot->writeI16((*_iter351));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abDfbEnable", ::apache::thrift::protocol::T_BOOL, 22);
  xfer += oprot->writeBool(this->abDfbEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abApsdStatus", ::apache::thrift::protocol::T_BOOL, 23);
  xfer += oprot->writeBool(this->abApsdStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abApsdEvent", ::apache::thrift::protocol::T_BOOL, 24);
  xfer += oprot->writeBool(this->abApsdEvent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abApsdEnable", ::apache::thrift::protocol::T_BOOL, 25);
  xfer += oprot->writeBool(this->abApsdEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiOtdrSwitchInEx", ::apache::thrift::protocol::T_I16, 26);
  xfer += oprot->writeI16(this->uiOtdrSwitchInEx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiOtdrSwitch", ::apache::thrift::protocol::T_I16, 27);
  xfer += oprot->writeI16(this->uiOtdrSwitch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiDFBPwr", ::apache::thrift::protocol::T_I32, 28);
  xfer += oprot->writeI32(this->uiDFBPwr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDfbInPower2", ::apache::thrift::protocol::T_I16, 29);
  xfer += oprot->writeI16(this->sDfbInPower2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDfbOutPower2", ::apache::thrift::protocol::T_I16, 30);
  xfer += oprot->writeI16(this->sDfbOutPower2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDfbInPower1", ::apache::thrift::protocol::T_I16, 31);
  xfer += oprot->writeI16(this->sDfbInPower1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDfbOutPower1", ::apache::thrift::protocol::T_I16, 32);
  xfer += oprot->writeI16(this->sDfbOutPower1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sLaserSafetyTxPower", ::apache::thrift::protocol::T_I16, 33);
  xfer += oprot->writeI16(this->sLaserSafetyTxPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sLaserSafetyRxPower", ::apache::thrift::protocol::T_I16, 34);
  xfer += oprot->writeI16(this->sLaserSafetyRxPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stLaserSafety", ::apache::thrift::protocol::T_STRUCT, 35);
  xfer += this->stLaserSafety.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astThrHys", ::apache::thrift::protocol::T_LIST, 36);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->astThrHys.size()));
    std::vector<std::vector<CMN_THR_HYS_INFO_ST_t> > ::const_iterator _iter352;
    for (_iter352 = this->astThrHys.begin(); _iter352 != this->astThrHys.end(); ++_iter352)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter352).size()));
        std::vector<CMN_THR_HYS_INFO_ST_t> ::const_iterator _iter353;
        for (_iter353 = (*_iter352).begin(); _iter353 != (*_iter352).end(); ++_iter353)
        {
          xfer += (*_iter353).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaCurData_t &a, COaCurData_t &b) {
  using ::std::swap;
  swap(a.bIsInService, b.bIsInService);
  swap(a.ucModeActual, b.ucModeActual);
  swap(a.sInPower, b.sInPower);
  swap(a.sOutSigCPower, b.sOutSigCPower);
  swap(a.sOutSigLPower, b.sOutSigLPower);
  swap(a.sOutTotalPower, b.sOutTotalPower);
  swap(a.sPortOutSigCPower, b.sPortOutSigCPower);
  swap(a.sPortOutSigLPower, b.sPortOutSigLPower);
  swap(a.sPortOutTotalPower, b.sPortOutTotalPower);
  swap(a.sMsaInPower, b.sMsaInPower);
  swap(a.sMsaOutPower, b.sMsaOutPower);
  swap(a.sBackRefPower, b.sBackRefPower);
  swap(a.sBackRefRatio, b.sBackRefRatio);
  swap(a.sGainActual, b.sGainActual);
  swap(a.sTiltActual, b.sTiltActual);
  swap(a.asVoaAttnActual, b.asVoaAttnActual);
  swap(a.asCaseTemp, b.asCaseTemp);
  swap(a.asHeaterTemp, b.asHeaterTemp);
  swap(a.asPumpTemp, b.asPumpTemp);
  swap(a.asPumpCurrent, b.asPumpCurrent);
  swap(a.asExtPdPower, b.asExtPdPower);
  swap(a.abDfbEnable, b.abDfbEnable);
  swap(a.abApsdStatus, b.abApsdStatus);
  swap(a.abApsdEvent, b.abApsdEvent);
  swap(a.abApsdEnable, b.abApsdEnable);
  swap(a.uiOtdrSwitchInEx, b.uiOtdrSwitchInEx);
  swap(a.uiOtdrSwitch, b.uiOtdrSwitch);
  swap(a.uiDFBPwr, b.uiDFBPwr);
  swap(a.sDfbInPower2, b.sDfbInPower2);
  swap(a.sDfbOutPower2, b.sDfbOutPower2);
  swap(a.sDfbInPower1, b.sDfbInPower1);
  swap(a.sDfbOutPower1, b.sDfbOutPower1);
  swap(a.sLaserSafetyTxPower, b.sLaserSafetyTxPower);
  swap(a.sLaserSafetyRxPower, b.sLaserSafetyRxPower);
  swap(a.stLaserSafety, b.stLaserSafety);
  swap(a.astThrHys, b.astThrHys);
  swap(a.__isset, b.__isset);
}

COaCurData_t::COaCurData_t(const COaCurData_t& other354) {
  bIsInService = other354.bIsInService;
  ucModeActual = other354.ucModeActual;
  sInPower = other354.sInPower;
  sOutSigCPower = other354.sOutSigCPower;
  sOutSigLPower = other354.sOutSigLPower;
  sOutTotalPower = other354.sOutTotalPower;
  sPortOutSigCPower = other354.sPortOutSigCPower;
  sPortOutSigLPower = other354.sPortOutSigLPower;
  sPortOutTotalPower = other354.sPortOutTotalPower;
  sMsaInPower = other354.sMsaInPower;
  sMsaOutPower = other354.sMsaOutPower;
  sBackRefPower = other354.sBackRefPower;
  sBackRefRatio = other354.sBackRefRatio;
  sGainActual = other354.sGainActual;
  sTiltActual = other354.sTiltActual;
  asVoaAttnActual = other354.asVoaAttnActual;
  asCaseTemp = other354.asCaseTemp;
  asHeaterTemp = other354.asHeaterTemp;
  asPumpTemp = other354.asPumpTemp;
  asPumpCurrent = other354.asPumpCurrent;
  asExtPdPower = other354.asExtPdPower;
  abDfbEnable = other354.abDfbEnable;
  abApsdStatus = other354.abApsdStatus;
  abApsdEvent = other354.abApsdEvent;
  abApsdEnable = other354.abApsdEnable;
  uiOtdrSwitchInEx = other354.uiOtdrSwitchInEx;
  uiOtdrSwitch = other354.uiOtdrSwitch;
  uiDFBPwr = other354.uiDFBPwr;
  sDfbInPower2 = other354.sDfbInPower2;
  sDfbOutPower2 = other354.sDfbOutPower2;
  sDfbInPower1 = other354.sDfbInPower1;
  sDfbOutPower1 = other354.sDfbOutPower1;
  sLaserSafetyTxPower = other354.sLaserSafetyTxPower;
  sLaserSafetyRxPower = other354.sLaserSafetyRxPower;
  stLaserSafety = other354.stLaserSafety;
  astThrHys = other354.astThrHys;
  __isset = other354.__isset;
}
COaCurData_t& COaCurData_t::operator=(const COaCurData_t& other355) {
  bIsInService = other355.bIsInService;
  ucModeActual = other355.ucModeActual;
  sInPower = other355.sInPower;
  sOutSigCPower = other355.sOutSigCPower;
  sOutSigLPower = other355.sOutSigLPower;
  sOutTotalPower = other355.sOutTotalPower;
  sPortOutSigCPower = other355.sPortOutSigCPower;
  sPortOutSigLPower = other355.sPortOutSigLPower;
  sPortOutTotalPower = other355.sPortOutTotalPower;
  sMsaInPower = other355.sMsaInPower;
  sMsaOutPower = other355.sMsaOutPower;
  sBackRefPower = other355.sBackRefPower;
  sBackRefRatio = other355.sBackRefRatio;
  sGainActual = other355.sGainActual;
  sTiltActual = other355.sTiltActual;
  asVoaAttnActual = other355.asVoaAttnActual;
  asCaseTemp = other355.asCaseTemp;
  asHeaterTemp = other355.asHeaterTemp;
  asPumpTemp = other355.asPumpTemp;
  asPumpCurrent = other355.asPumpCurrent;
  asExtPdPower = other355.asExtPdPower;
  abDfbEnable = other355.abDfbEnable;
  abApsdStatus = other355.abApsdStatus;
  abApsdEvent = other355.abApsdEvent;
  abApsdEnable = other355.abApsdEnable;
  uiOtdrSwitchInEx = other355.uiOtdrSwitchInEx;
  uiOtdrSwitch = other355.uiOtdrSwitch;
  uiDFBPwr = other355.uiDFBPwr;
  sDfbInPower2 = other355.sDfbInPower2;
  sDfbOutPower2 = other355.sDfbOutPower2;
  sDfbInPower1 = other355.sDfbInPower1;
  sDfbOutPower1 = other355.sDfbOutPower1;
  sLaserSafetyTxPower = other355.sLaserSafetyTxPower;
  sLaserSafetyRxPower = other355.sLaserSafetyRxPower;
  stLaserSafety = other355.stLaserSafety;
  astThrHys = other355.astThrHys;
  __isset = other355.__isset;
  return *this;
}
void COaCurData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaCurData_t(";
  out << "bIsInService=" << to_string(bIsInService);
  out << ", " << "ucModeActual=" << to_string(ucModeActual);
  out << ", " << "sInPower=" << to_string(sInPower);
  out << ", " << "sOutSigCPower=" << to_string(sOutSigCPower);
  out << ", " << "sOutSigLPower=" << to_string(sOutSigLPower);
  out << ", " << "sOutTotalPower=" << to_string(sOutTotalPower);
  out << ", " << "sPortOutSigCPower=" << to_string(sPortOutSigCPower);
  out << ", " << "sPortOutSigLPower=" << to_string(sPortOutSigLPower);
  out << ", " << "sPortOutTotalPower=" << to_string(sPortOutTotalPower);
  out << ", " << "sMsaInPower=" << to_string(sMsaInPower);
  out << ", " << "sMsaOutPower=" << to_string(sMsaOutPower);
  out << ", " << "sBackRefPower=" << to_string(sBackRefPower);
  out << ", " << "sBackRefRatio=" << to_string(sBackRefRatio);
  out << ", " << "sGainActual=" << to_string(sGainActual);
  out << ", " << "sTiltActual=" << to_string(sTiltActual);
  out << ", " << "asVoaAttnActual=" << to_string(asVoaAttnActual);
  out << ", " << "asCaseTemp=" << to_string(asCaseTemp);
  out << ", " << "asHeaterTemp=" << to_string(asHeaterTemp);
  out << ", " << "asPumpTemp=" << to_string(asPumpTemp);
  out << ", " << "asPumpCurrent=" << to_string(asPumpCurrent);
  out << ", " << "asExtPdPower=" << to_string(asExtPdPower);
  out << ", " << "abDfbEnable=" << to_string(abDfbEnable);
  out << ", " << "abApsdStatus=" << to_string(abApsdStatus);
  out << ", " << "abApsdEvent=" << to_string(abApsdEvent);
  out << ", " << "abApsdEnable=" << to_string(abApsdEnable);
  out << ", " << "uiOtdrSwitchInEx=" << to_string(uiOtdrSwitchInEx);
  out << ", " << "uiOtdrSwitch=" << to_string(uiOtdrSwitch);
  out << ", " << "uiDFBPwr=" << to_string(uiDFBPwr);
  out << ", " << "sDfbInPower2=" << to_string(sDfbInPower2);
  out << ", " << "sDfbOutPower2=" << to_string(sDfbOutPower2);
  out << ", " << "sDfbInPower1=" << to_string(sDfbInPower1);
  out << ", " << "sDfbOutPower1=" << to_string(sDfbOutPower1);
  out << ", " << "sLaserSafetyTxPower=" << to_string(sLaserSafetyTxPower);
  out << ", " << "sLaserSafetyRxPower=" << to_string(sLaserSafetyRxPower);
  out << ", " << "stLaserSafety=" << to_string(stLaserSafety);
  out << ", " << "astThrHys=" << to_string(astThrHys);
  out << ")";
}


COaAnnexData_t::~COaAnnexData_t() noexcept {
}


void COaAnnexData_t::__set_uiSccUpgSta(const int32_t val) {
  this->uiSccUpgSta = val;
}

void COaAnnexData_t::__set_uiTestLedSta(const int32_t val) {
  this->uiTestLedSta = val;
}

void COaAnnexData_t::__set_uiLedAlmSta(const int32_t val) {
  this->uiLedAlmSta = val;
}

void COaAnnexData_t::__set_aucLedSta(const std::string& val) {
  this->aucLedSta = val;
}

void COaAnnexData_t::__set_aucAlmMask(const std::vector<int32_t> & val) {
  this->aucAlmMask = val;
}

void COaAnnexData_t::__set_ucShutterSta(const int8_t val) {
  this->ucShutterSta = val;
}

void COaAnnexData_t::__set_reserve(const std::string& val) {
  this->reserve = val;
}
std::ostream& operator<<(std::ostream& out, const COaAnnexData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaAnnexData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSccUpgSta);
          this->__isset.uiSccUpgSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiTestLedSta);
          this->__isset.uiTestLedSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLedAlmSta);
          this->__isset.uiLedAlmSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucLedSta);
          this->__isset.aucLedSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aucAlmMask.clear();
            uint32_t _size356;
            ::apache::thrift::protocol::TType _etype359;
            xfer += iprot->readListBegin(_etype359, _size356);
            this->aucAlmMask.resize(_size356);
            uint32_t _i360;
            for (_i360 = 0; _i360 < _size356; ++_i360)
            {
              xfer += iprot->readI32(this->aucAlmMask[_i360]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aucAlmMask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucShutterSta);
          this->__isset.ucShutterSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->reserve);
          this->__isset.reserve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaAnnexData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaAnnexData_t");

  xfer += oprot->writeFieldBegin("uiSccUpgSta", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSccUpgSta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiTestLedSta", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiTestLedSta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedAlmSta", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiLedAlmSta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucLedSta", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->aucLedSta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucAlmMask", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->aucAlmMask.size()));
    std::vector<int32_t> ::const_iterator _iter361;
    for (_iter361 = this->aucAlmMask.begin(); _iter361 != this->aucAlmMask.end(); ++_iter361)
    {
      xfer += oprot->writeI32((*_iter361));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucShutterSta", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->ucShutterSta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reserve", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->reserve);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaAnnexData_t &a, COaAnnexData_t &b) {
  using ::std::swap;
  swap(a.uiSccUpgSta, b.uiSccUpgSta);
  swap(a.uiTestLedSta, b.uiTestLedSta);
  swap(a.uiLedAlmSta, b.uiLedAlmSta);
  swap(a.aucLedSta, b.aucLedSta);
  swap(a.aucAlmMask, b.aucAlmMask);
  swap(a.ucShutterSta, b.ucShutterSta);
  swap(a.reserve, b.reserve);
  swap(a.__isset, b.__isset);
}

COaAnnexData_t::COaAnnexData_t(const COaAnnexData_t& other362) {
  uiSccUpgSta = other362.uiSccUpgSta;
  uiTestLedSta = other362.uiTestLedSta;
  uiLedAlmSta = other362.uiLedAlmSta;
  aucLedSta = other362.aucLedSta;
  aucAlmMask = other362.aucAlmMask;
  ucShutterSta = other362.ucShutterSta;
  reserve = other362.reserve;
  __isset = other362.__isset;
}
COaAnnexData_t& COaAnnexData_t::operator=(const COaAnnexData_t& other363) {
  uiSccUpgSta = other363.uiSccUpgSta;
  uiTestLedSta = other363.uiTestLedSta;
  uiLedAlmSta = other363.uiLedAlmSta;
  aucLedSta = other363.aucLedSta;
  aucAlmMask = other363.aucAlmMask;
  ucShutterSta = other363.ucShutterSta;
  reserve = other363.reserve;
  __isset = other363.__isset;
  return *this;
}
void COaAnnexData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaAnnexData_t(";
  out << "uiSccUpgSta=" << to_string(uiSccUpgSta);
  out << ", " << "uiTestLedSta=" << to_string(uiTestLedSta);
  out << ", " << "uiLedAlmSta=" << to_string(uiLedAlmSta);
  out << ", " << "aucLedSta=" << to_string(aucLedSta);
  out << ", " << "aucAlmMask=" << to_string(aucAlmMask);
  out << ", " << "ucShutterSta=" << to_string(ucShutterSta);
  out << ", " << "reserve=" << to_string(reserve);
  out << ")";
}


COaStatusData_t::~COaStatusData_t() noexcept {
}


void COaStatusData_t::__set_stOaAlm(const COaAlarm_t& val) {
  this->stOaAlm = val;
}

void COaStatusData_t::__set_stOaCurData(const COaCurData_t& val) {
  this->stOaCurData = val;
}

void COaStatusData_t::__set_stOscCurData(const COscStatusData_t& val) {
  this->stOscCurData = val;
}

void COaStatusData_t::__set_aucDbgBuf(const std::string& val) {
  this->aucDbgBuf = val;
}

void COaStatusData_t::__set_stOaAnnexData(const COaAnnexData_t& val) {
  this->stOaAnnexData = val;
}
std::ostream& operator<<(std::ostream& out, const COaStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOaAlm.read(iprot);
          this->__isset.stOaAlm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOaCurData.read(iprot);
          this->__isset.stOaCurData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOscCurData.read(iprot);
          this->__isset.stOscCurData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucDbgBuf);
          this->__isset.aucDbgBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOaAnnexData.read(iprot);
          this->__isset.stOaAnnexData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaStatusData_t");

  xfer += oprot->writeFieldBegin("stOaAlm", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stOaAlm.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stOaCurData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stOaCurData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stOscCurData", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->stOscCurData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucDbgBuf", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->aucDbgBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stOaAnnexData", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->stOaAnnexData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaStatusData_t &a, COaStatusData_t &b) {
  using ::std::swap;
  swap(a.stOaAlm, b.stOaAlm);
  swap(a.stOaCurData, b.stOaCurData);
  swap(a.stOscCurData, b.stOscCurData);
  swap(a.aucDbgBuf, b.aucDbgBuf);
  swap(a.stOaAnnexData, b.stOaAnnexData);
  swap(a.__isset, b.__isset);
}

COaStatusData_t::COaStatusData_t(const COaStatusData_t& other364) {
  stOaAlm = other364.stOaAlm;
  stOaCurData = other364.stOaCurData;
  stOscCurData = other364.stOscCurData;
  aucDbgBuf = other364.aucDbgBuf;
  stOaAnnexData = other364.stOaAnnexData;
  __isset = other364.__isset;
}
COaStatusData_t& COaStatusData_t::operator=(const COaStatusData_t& other365) {
  stOaAlm = other365.stOaAlm;
  stOaCurData = other365.stOaCurData;
  stOscCurData = other365.stOscCurData;
  aucDbgBuf = other365.aucDbgBuf;
  stOaAnnexData = other365.stOaAnnexData;
  __isset = other365.__isset;
  return *this;
}
void COaStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaStatusData_t(";
  out << "stOaAlm=" << to_string(stOaAlm);
  out << ", " << "stOaCurData=" << to_string(stOaCurData);
  out << ", " << "stOscCurData=" << to_string(stOscCurData);
  out << ", " << "aucDbgBuf=" << to_string(aucDbgBuf);
  out << ", " << "stOaAnnexData=" << to_string(stOaAnnexData);
  out << ")";
}


COaEventLogData_t::~COaEventLogData_t() noexcept {
}


void COaEventLogData_t::__set_uiLostTimeCount(const int32_t val) {
  this->uiLostTimeCount = val;
}

void COaEventLogData_t::__set_uiLostPD(const int32_t val) {
  this->uiLostPD = val;
}

void COaEventLogData_t::__set_uiLinkDownTimeCount(const int32_t val) {
  this->uiLinkDownTimeCount = val;
}

void COaEventLogData_t::__set_uiApsdTimeCount(const int32_t val) {
  this->uiApsdTimeCount = val;
}
std::ostream& operator<<(std::ostream& out, const COaEventLogData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaEventLogData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLostTimeCount);
          this->__isset.uiLostTimeCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLostPD);
          this->__isset.uiLostPD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLinkDownTimeCount);
          this->__isset.uiLinkDownTimeCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiApsdTimeCount);
          this->__isset.uiApsdTimeCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaEventLogData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaEventLogData_t");

  xfer += oprot->writeFieldBegin("uiLostTimeCount", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiLostTimeCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLostPD", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiLostPD);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLinkDownTimeCount", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiLinkDownTimeCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiApsdTimeCount", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiApsdTimeCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaEventLogData_t &a, COaEventLogData_t &b) {
  using ::std::swap;
  swap(a.uiLostTimeCount, b.uiLostTimeCount);
  swap(a.uiLostPD, b.uiLostPD);
  swap(a.uiLinkDownTimeCount, b.uiLinkDownTimeCount);
  swap(a.uiApsdTimeCount, b.uiApsdTimeCount);
  swap(a.__isset, b.__isset);
}

COaEventLogData_t::COaEventLogData_t(const COaEventLogData_t& other366) {
  uiLostTimeCount = other366.uiLostTimeCount;
  uiLostPD = other366.uiLostPD;
  uiLinkDownTimeCount = other366.uiLinkDownTimeCount;
  uiApsdTimeCount = other366.uiApsdTimeCount;
  __isset = other366.__isset;
}
COaEventLogData_t& COaEventLogData_t::operator=(const COaEventLogData_t& other367) {
  uiLostTimeCount = other367.uiLostTimeCount;
  uiLostPD = other367.uiLostPD;
  uiLinkDownTimeCount = other367.uiLinkDownTimeCount;
  uiApsdTimeCount = other367.uiApsdTimeCount;
  __isset = other367.__isset;
  return *this;
}
void COaEventLogData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaEventLogData_t(";
  out << "uiLostTimeCount=" << to_string(uiLostTimeCount);
  out << ", " << "uiLostPD=" << to_string(uiLostPD);
  out << ", " << "uiLinkDownTimeCount=" << to_string(uiLinkDownTimeCount);
  out << ", " << "uiApsdTimeCount=" << to_string(uiApsdTimeCount);
  out << ")";
}


COaEventLogAllData_t::~COaEventLogAllData_t() noexcept {
}


void COaEventLogAllData_t::__set_stOaEventLogData(const std::vector<COaEventLogData_t> & val) {
  this->stOaEventLogData = val;
}

void COaEventLogAllData_t::__set_uiBaLostTimeCount(const int32_t val) {
  this->uiBaLostTimeCount = val;
}

void COaEventLogAllData_t::__set_rev(const std::string& val) {
  this->rev = val;
}
std::ostream& operator<<(std::ostream& out, const COaEventLogAllData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaEventLogAllData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stOaEventLogData.clear();
            uint32_t _size368;
            ::apache::thrift::protocol::TType _etype371;
            xfer += iprot->readListBegin(_etype371, _size368);
            this->stOaEventLogData.resize(_size368);
            uint32_t _i372;
            for (_i372 = 0; _i372 < _size368; ++_i372)
            {
              xfer += this->stOaEventLogData[_i372].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stOaEventLogData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiBaLostTimeCount);
          this->__isset.uiBaLostTimeCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rev);
          this->__isset.rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaEventLogAllData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaEventLogAllData_t");

  xfer += oprot->writeFieldBegin("stOaEventLogData", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stOaEventLogData.size()));
    std::vector<COaEventLogData_t> ::const_iterator _iter373;
    for (_iter373 = this->stOaEventLogData.begin(); _iter373 != this->stOaEventLogData.end(); ++_iter373)
    {
      xfer += (*_iter373).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiBaLostTimeCount", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiBaLostTimeCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rev", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->rev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaEventLogAllData_t &a, COaEventLogAllData_t &b) {
  using ::std::swap;
  swap(a.stOaEventLogData, b.stOaEventLogData);
  swap(a.uiBaLostTimeCount, b.uiBaLostTimeCount);
  swap(a.rev, b.rev);
  swap(a.__isset, b.__isset);
}

COaEventLogAllData_t::COaEventLogAllData_t(const COaEventLogAllData_t& other374) {
  stOaEventLogData = other374.stOaEventLogData;
  uiBaLostTimeCount = other374.uiBaLostTimeCount;
  rev = other374.rev;
  __isset = other374.__isset;
}
COaEventLogAllData_t& COaEventLogAllData_t::operator=(const COaEventLogAllData_t& other375) {
  stOaEventLogData = other375.stOaEventLogData;
  uiBaLostTimeCount = other375.uiBaLostTimeCount;
  rev = other375.rev;
  __isset = other375.__isset;
  return *this;
}
void COaEventLogAllData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaEventLogAllData_t(";
  out << "stOaEventLogData=" << to_string(stOaEventLogData);
  out << ", " << "uiBaLostTimeCount=" << to_string(uiBaLostTimeCount);
  out << ", " << "rev=" << to_string(rev);
  out << ")";
}


CExtendCfgData_t::~CExtendCfgData_t() noexcept {
}


void CExtendCfgData_t::__set_asSwitchPos(const std::vector<int16_t> & val) {
  this->asSwitchPos = val;
}

void CExtendCfgData_t::__set_asVoaAttn(const std::vector<int16_t> & val) {
  this->asVoaAttn = val;
}
std::ostream& operator<<(std::ostream& out, const CExtendCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CExtendCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asSwitchPos.clear();
            uint32_t _size376;
            ::apache::thrift::protocol::TType _etype379;
            xfer += iprot->readListBegin(_etype379, _size376);
            this->asSwitchPos.resize(_size376);
            uint32_t _i380;
            for (_i380 = 0; _i380 < _size376; ++_i380)
            {
              xfer += iprot->readI16(this->asSwitchPos[_i380]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asSwitchPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asVoaAttn.clear();
            uint32_t _size381;
            ::apache::thrift::protocol::TType _etype384;
            xfer += iprot->readListBegin(_etype384, _size381);
            this->asVoaAttn.resize(_size381);
            uint32_t _i385;
            for (_i385 = 0; _i385 < _size381; ++_i385)
            {
              xfer += iprot->readI16(this->asVoaAttn[_i385]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asVoaAttn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CExtendCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CExtendCfgData_t");

  xfer += oprot->writeFieldBegin("asSwitchPos", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asSwitchPos.size()));
    std::vector<int16_t> ::const_iterator _iter386;
    for (_iter386 = this->asSwitchPos.begin(); _iter386 != this->asSwitchPos.end(); ++_iter386)
    {
      xfer += oprot->writeI16((*_iter386));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asVoaAttn", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asVoaAttn.size()));
    std::vector<int16_t> ::const_iterator _iter387;
    for (_iter387 = this->asVoaAttn.begin(); _iter387 != this->asVoaAttn.end(); ++_iter387)
    {
      xfer += oprot->writeI16((*_iter387));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CExtendCfgData_t &a, CExtendCfgData_t &b) {
  using ::std::swap;
  swap(a.asSwitchPos, b.asSwitchPos);
  swap(a.asVoaAttn, b.asVoaAttn);
  swap(a.__isset, b.__isset);
}

CExtendCfgData_t::CExtendCfgData_t(const CExtendCfgData_t& other388) {
  asSwitchPos = other388.asSwitchPos;
  asVoaAttn = other388.asVoaAttn;
  __isset = other388.__isset;
}
CExtendCfgData_t& CExtendCfgData_t::operator=(const CExtendCfgData_t& other389) {
  asSwitchPos = other389.asSwitchPos;
  asVoaAttn = other389.asVoaAttn;
  __isset = other389.__isset;
  return *this;
}
void CExtendCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CExtendCfgData_t(";
  out << "asSwitchPos=" << to_string(asSwitchPos);
  out << ", " << "asVoaAttn=" << to_string(asVoaAttn);
  out << ")";
}


CExtendStatusData_t::~CExtendStatusData_t() noexcept {
}


void CExtendStatusData_t::__set_asPD(const std::vector<int16_t> & val) {
  this->asPD = val;
}

void CExtendStatusData_t::__set_asSwitchPosActual(const std::vector<int16_t> & val) {
  this->asSwitchPosActual = val;
}

void CExtendStatusData_t::__set_asVoaAttnActual(const std::vector<int16_t> & val) {
  this->asVoaAttnActual = val;
}

void CExtendStatusData_t::__set_aucDbgBuf(const std::string& val) {
  this->aucDbgBuf = val;
}
std::ostream& operator<<(std::ostream& out, const CExtendStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CExtendStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPD.clear();
            uint32_t _size390;
            ::apache::thrift::protocol::TType _etype393;
            xfer += iprot->readListBegin(_etype393, _size390);
            this->asPD.resize(_size390);
            uint32_t _i394;
            for (_i394 = 0; _i394 < _size390; ++_i394)
            {
              xfer += iprot->readI16(this->asPD[_i394]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asSwitchPosActual.clear();
            uint32_t _size395;
            ::apache::thrift::protocol::TType _etype398;
            xfer += iprot->readListBegin(_etype398, _size395);
            this->asSwitchPosActual.resize(_size395);
            uint32_t _i399;
            for (_i399 = 0; _i399 < _size395; ++_i399)
            {
              xfer += iprot->readI16(this->asSwitchPosActual[_i399]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asSwitchPosActual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asVoaAttnActual.clear();
            uint32_t _size400;
            ::apache::thrift::protocol::TType _etype403;
            xfer += iprot->readListBegin(_etype403, _size400);
            this->asVoaAttnActual.resize(_size400);
            uint32_t _i404;
            for (_i404 = 0; _i404 < _size400; ++_i404)
            {
              xfer += iprot->readI16(this->asVoaAttnActual[_i404]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asVoaAttnActual = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucDbgBuf);
          this->__isset.aucDbgBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CExtendStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CExtendStatusData_t");

  xfer += oprot->writeFieldBegin("asPD", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPD.size()));
    std::vector<int16_t> ::const_iterator _iter405;
    for (_iter405 = this->asPD.begin(); _iter405 != this->asPD.end(); ++_iter405)
    {
      xfer += oprot->writeI16((*_iter405));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asSwitchPosActual", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asSwitchPosActual.size()));
    std::vector<int16_t> ::const_iterator _iter406;
    for (_iter406 = this->asSwitchPosActual.begin(); _iter406 != this->asSwitchPosActual.end(); ++_iter406)
    {
      xfer += oprot->writeI16((*_iter406));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asVoaAttnActual", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asVoaAttnActual.size()));
    std::vector<int16_t> ::const_iterator _iter407;
    for (_iter407 = this->asVoaAttnActual.begin(); _iter407 != this->asVoaAttnActual.end(); ++_iter407)
    {
      xfer += oprot->writeI16((*_iter407));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucDbgBuf", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->aucDbgBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CExtendStatusData_t &a, CExtendStatusData_t &b) {
  using ::std::swap;
  swap(a.asPD, b.asPD);
  swap(a.asSwitchPosActual, b.asSwitchPosActual);
  swap(a.asVoaAttnActual, b.asVoaAttnActual);
  swap(a.aucDbgBuf, b.aucDbgBuf);
  swap(a.__isset, b.__isset);
}

CExtendStatusData_t::CExtendStatusData_t(const CExtendStatusData_t& other408) {
  asPD = other408.asPD;
  asSwitchPosActual = other408.asSwitchPosActual;
  asVoaAttnActual = other408.asVoaAttnActual;
  aucDbgBuf = other408.aucDbgBuf;
  __isset = other408.__isset;
}
CExtendStatusData_t& CExtendStatusData_t::operator=(const CExtendStatusData_t& other409) {
  asPD = other409.asPD;
  asSwitchPosActual = other409.asSwitchPosActual;
  asVoaAttnActual = other409.asVoaAttnActual;
  aucDbgBuf = other409.aucDbgBuf;
  __isset = other409.__isset;
  return *this;
}
void CExtendStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CExtendStatusData_t(";
  out << "asPD=" << to_string(asPD);
  out << ", " << "asSwitchPosActual=" << to_string(asSwitchPosActual);
  out << ", " << "asVoaAttnActual=" << to_string(asVoaAttnActual);
  out << ", " << "aucDbgBuf=" << to_string(aucDbgBuf);
  out << ")";
}


CMirrorData_t::~CMirrorData_t() noexcept {
}


void CMirrorData_t::__set_sTxPower(const int16_t val) {
  this->sTxPower = val;
}

void CMirrorData_t::__set_sMuxInPower(const int16_t val) {
  this->sMuxInPower = val;
}

void CMirrorData_t::__set_sDemuxInPower(const int16_t val) {
  this->sDemuxInPower = val;
}
std::ostream& operator<<(std::ostream& out, const CMirrorData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMirrorData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTxPower);
          this->__isset.sTxPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sMuxInPower);
          this->__isset.sMuxInPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDemuxInPower);
          this->__isset.sDemuxInPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMirrorData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMirrorData_t");

  xfer += oprot->writeFieldBegin("sTxPower", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sTxPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sMuxInPower", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sMuxInPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDemuxInPower", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sDemuxInPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMirrorData_t &a, CMirrorData_t &b) {
  using ::std::swap;
  swap(a.sTxPower, b.sTxPower);
  swap(a.sMuxInPower, b.sMuxInPower);
  swap(a.sDemuxInPower, b.sDemuxInPower);
  swap(a.__isset, b.__isset);
}

CMirrorData_t::CMirrorData_t(const CMirrorData_t& other410) {
  sTxPower = other410.sTxPower;
  sMuxInPower = other410.sMuxInPower;
  sDemuxInPower = other410.sDemuxInPower;
  __isset = other410.__isset;
}
CMirrorData_t& CMirrorData_t::operator=(const CMirrorData_t& other411) {
  sTxPower = other411.sTxPower;
  sMuxInPower = other411.sMuxInPower;
  sDemuxInPower = other411.sDemuxInPower;
  __isset = other411.__isset;
  return *this;
}
void CMirrorData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMirrorData_t(";
  out << "sTxPower=" << to_string(sTxPower);
  out << ", " << "sMuxInPower=" << to_string(sMuxInPower);
  out << ", " << "sDemuxInPower=" << to_string(sDemuxInPower);
  out << ")";
}


CMuxCfgData_t::~CMuxCfgData_t() noexcept {
}

std::ostream& operator<<(std::ostream& out, const CMuxCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMuxCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMuxCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMuxCfgData_t");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMuxCfgData_t &a, CMuxCfgData_t &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CMuxCfgData_t::CMuxCfgData_t(const CMuxCfgData_t& other412) {
  (void) other412;
}
CMuxCfgData_t& CMuxCfgData_t::operator=(const CMuxCfgData_t& other413) {
  (void) other413;
  return *this;
}
void CMuxCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMuxCfgData_t(";
  out << ")";
}


CMuxStatusData_t::~CMuxStatusData_t() noexcept {
}


void CMuxStatusData_t::__set_asPdPower(const std::vector<int16_t> & val) {
  this->asPdPower = val;
}
std::ostream& operator<<(std::ostream& out, const CMuxStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMuxStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPdPower.clear();
            uint32_t _size414;
            ::apache::thrift::protocol::TType _etype417;
            xfer += iprot->readListBegin(_etype417, _size414);
            this->asPdPower.resize(_size414);
            uint32_t _i418;
            for (_i418 = 0; _i418 < _size414; ++_i418)
            {
              xfer += iprot->readI16(this->asPdPower[_i418]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPdPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMuxStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMuxStatusData_t");

  xfer += oprot->writeFieldBegin("asPdPower", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPdPower.size()));
    std::vector<int16_t> ::const_iterator _iter419;
    for (_iter419 = this->asPdPower.begin(); _iter419 != this->asPdPower.end(); ++_iter419)
    {
      xfer += oprot->writeI16((*_iter419));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMuxStatusData_t &a, CMuxStatusData_t &b) {
  using ::std::swap;
  swap(a.asPdPower, b.asPdPower);
  swap(a.__isset, b.__isset);
}

CMuxStatusData_t::CMuxStatusData_t(const CMuxStatusData_t& other420) {
  asPdPower = other420.asPdPower;
  __isset = other420.__isset;
}
CMuxStatusData_t& CMuxStatusData_t::operator=(const CMuxStatusData_t& other421) {
  asPdPower = other421.asPdPower;
  __isset = other421.__isset;
  return *this;
}
void CMuxStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMuxStatusData_t(";
  out << "asPdPower=" << to_string(asPdPower);
  out << ")";
}


CMuxCaliData_t::~CMuxCaliData_t() noexcept {
}


void CMuxCaliData_t::__set_dRefMuxTCali(const double val) {
  this->dRefMuxTCali = val;
}

void CMuxCaliData_t::__set_dRefDemuxRCali(const double val) {
  this->dRefDemuxRCali = val;
}
std::ostream& operator<<(std::ostream& out, const CMuxCaliData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMuxCaliData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dRefMuxTCali);
          this->__isset.dRefMuxTCali = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dRefDemuxRCali);
          this->__isset.dRefDemuxRCali = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMuxCaliData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMuxCaliData_t");

  xfer += oprot->writeFieldBegin("dRefMuxTCali", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->dRefMuxTCali);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dRefDemuxRCali", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->dRefDemuxRCali);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMuxCaliData_t &a, CMuxCaliData_t &b) {
  using ::std::swap;
  swap(a.dRefMuxTCali, b.dRefMuxTCali);
  swap(a.dRefDemuxRCali, b.dRefDemuxRCali);
  swap(a.__isset, b.__isset);
}

CMuxCaliData_t::CMuxCaliData_t(const CMuxCaliData_t& other422) {
  dRefMuxTCali = other422.dRefMuxTCali;
  dRefDemuxRCali = other422.dRefDemuxRCali;
  __isset = other422.__isset;
}
CMuxCaliData_t& CMuxCaliData_t::operator=(const CMuxCaliData_t& other423) {
  dRefMuxTCali = other423.dRefMuxTCali;
  dRefDemuxRCali = other423.dRefDemuxRCali;
  __isset = other423.__isset;
  return *this;
}
void CMuxCaliData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMuxCaliData_t(";
  out << "dRefMuxTCali=" << to_string(dRefMuxTCali);
  out << ", " << "dRefDemuxRCali=" << to_string(dRefDemuxRCali);
  out << ")";
}


COpsLedChannel_t::~COpsLedChannel_t() noexcept {
}


void COpsLedChannel_t::__set_ucW(const int8_t val) {
  this->ucW = val;
}

void COpsLedChannel_t::__set_ucP(const int8_t val) {
  this->ucP = val;
}

void COpsLedChannel_t::__set_ucMux(const int8_t val) {
  this->ucMux = val;
}

void COpsLedChannel_t::__set_ucWP(const int8_t val) {
  this->ucWP = val;
}
std::ostream& operator<<(std::ostream& out, const COpsLedChannel_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsLedChannel_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucW);
          this->__isset.ucW = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucP);
          this->__isset.ucP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucMux);
          this->__isset.ucMux = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucWP);
          this->__isset.ucWP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsLedChannel_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsLedChannel_t");

  xfer += oprot->writeFieldBegin("ucW", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucW);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucP", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucMux", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->ucMux);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucWP", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->ucWP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsLedChannel_t &a, COpsLedChannel_t &b) {
  using ::std::swap;
  swap(a.ucW, b.ucW);
  swap(a.ucP, b.ucP);
  swap(a.ucMux, b.ucMux);
  swap(a.ucWP, b.ucWP);
  swap(a.__isset, b.__isset);
}

COpsLedChannel_t::COpsLedChannel_t(const COpsLedChannel_t& other424) {
  ucW = other424.ucW;
  ucP = other424.ucP;
  ucMux = other424.ucMux;
  ucWP = other424.ucWP;
  __isset = other424.__isset;
}
COpsLedChannel_t& COpsLedChannel_t::operator=(const COpsLedChannel_t& other425) {
  ucW = other425.ucW;
  ucP = other425.ucP;
  ucMux = other425.ucMux;
  ucWP = other425.ucWP;
  __isset = other425.__isset;
  return *this;
}
void COpsLedChannel_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsLedChannel_t(";
  out << "ucW=" << to_string(ucW);
  out << ", " << "ucP=" << to_string(ucP);
  out << ", " << "ucMux=" << to_string(ucMux);
  out << ", " << "ucWP=" << to_string(ucWP);
  out << ")";
}


COpsLedAll_t::~COpsLedAll_t() noexcept {
}


void COpsLedAll_t::__set_ucAct(const int8_t val) {
  this->ucAct = val;
}

void COpsLedAll_t::__set_ucAlm(const int8_t val) {
  this->ucAlm = val;
}

void COpsLedAll_t::__set_stOpsLedChannel(const std::vector<COpsLedChannel_t> & val) {
  this->stOpsLedChannel = val;
}
std::ostream& operator<<(std::ostream& out, const COpsLedAll_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsLedAll_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucAct);
          this->__isset.ucAct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucAlm);
          this->__isset.ucAlm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stOpsLedChannel.clear();
            uint32_t _size426;
            ::apache::thrift::protocol::TType _etype429;
            xfer += iprot->readListBegin(_etype429, _size426);
            this->stOpsLedChannel.resize(_size426);
            uint32_t _i430;
            for (_i430 = 0; _i430 < _size426; ++_i430)
            {
              xfer += this->stOpsLedChannel[_i430].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stOpsLedChannel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsLedAll_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsLedAll_t");

  xfer += oprot->writeFieldBegin("ucAct", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucAct);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucAlm", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucAlm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stOpsLedChannel", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stOpsLedChannel.size()));
    std::vector<COpsLedChannel_t> ::const_iterator _iter431;
    for (_iter431 = this->stOpsLedChannel.begin(); _iter431 != this->stOpsLedChannel.end(); ++_iter431)
    {
      xfer += (*_iter431).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsLedAll_t &a, COpsLedAll_t &b) {
  using ::std::swap;
  swap(a.ucAct, b.ucAct);
  swap(a.ucAlm, b.ucAlm);
  swap(a.stOpsLedChannel, b.stOpsLedChannel);
  swap(a.__isset, b.__isset);
}

COpsLedAll_t::COpsLedAll_t(const COpsLedAll_t& other432) {
  ucAct = other432.ucAct;
  ucAlm = other432.ucAlm;
  stOpsLedChannel = other432.stOpsLedChannel;
  __isset = other432.__isset;
}
COpsLedAll_t& COpsLedAll_t::operator=(const COpsLedAll_t& other433) {
  ucAct = other433.ucAct;
  ucAlm = other433.ucAlm;
  stOpsLedChannel = other433.stOpsLedChannel;
  __isset = other433.__isset;
  return *this;
}
void COpsLedAll_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsLedAll_t(";
  out << "ucAct=" << to_string(ucAct);
  out << ", " << "ucAlm=" << to_string(ucAlm);
  out << ", " << "stOpsLedChannel=" << to_string(stOpsLedChannel);
  out << ")";
}


COpsLed_t::~COpsLed_t() noexcept {
}


void COpsLed_t::__set_aucStatus(const std::string& val) {
  this->aucStatus = val;
__isset.aucStatus = true;
}

void COpsLed_t::__set_stOpsLedAll(const COpsLedAll_t& val) {
  this->stOpsLedAll = val;
__isset.stOpsLedAll = true;
}
std::ostream& operator<<(std::ostream& out, const COpsLed_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsLed_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucStatus);
          this->__isset.aucStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOpsLedAll.read(iprot);
          this->__isset.stOpsLedAll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsLed_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsLed_t");

  if (this->__isset.aucStatus) {
    xfer += oprot->writeFieldBegin("aucStatus", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->aucStatus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stOpsLedAll) {
    xfer += oprot->writeFieldBegin("stOpsLedAll", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->stOpsLedAll.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsLed_t &a, COpsLed_t &b) {
  using ::std::swap;
  swap(a.aucStatus, b.aucStatus);
  swap(a.stOpsLedAll, b.stOpsLedAll);
  swap(a.__isset, b.__isset);
}

COpsLed_t::COpsLed_t(const COpsLed_t& other434) {
  aucStatus = other434.aucStatus;
  stOpsLedAll = other434.stOpsLedAll;
  __isset = other434.__isset;
}
COpsLed_t& COpsLed_t::operator=(const COpsLed_t& other435) {
  aucStatus = other435.aucStatus;
  stOpsLedAll = other435.stOpsLedAll;
  __isset = other435.__isset;
  return *this;
}
void COpsLed_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsLed_t(";
  out << "aucStatus="; (__isset.aucStatus ? (out << to_string(aucStatus)) : (out << "<null>"));
  out << ", " << "stOpsLedAll="; (__isset.stOpsLedAll ? (out << to_string(stOpsLedAll)) : (out << "<null>"));
  out << ")";
}


COpsCurData_t::~COpsCurData_t() noexcept {
}


void COpsCurData_t::__set_ucWorkMode(const int8_t val) {
  this->ucWorkMode = val;
}

void COpsCurData_t::__set_ucSwitchPos(const int8_t val) {
  this->ucSwitchPos = val;
}

void COpsCurData_t::__set_ucFswStatus(const int8_t val) {
  this->ucFswStatus = val;
}

void COpsCurData_t::__set_ucSwitchingType(const int8_t val) {
  this->ucSwitchingType = val;
}

void COpsCurData_t::__set_asPortPower(const std::vector<int16_t> & val) {
  this->asPortPower = val;
}

void COpsCurData_t::__set_sTxPower(const int16_t val) {
  this->sTxPower = val;
}

void COpsCurData_t::__set_bFailure(const bool val) {
  this->bFailure = val;
}

void COpsCurData_t::__set_bInnerErr(const bool val) {
  this->bInnerErr = val;
}

void COpsCurData_t::__set_bOffLine(const bool val) {
  this->bOffLine = val;
}
std::ostream& operator<<(std::ostream& out, const COpsCurData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsCurData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucWorkMode);
          this->__isset.ucWorkMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucSwitchPos);
          this->__isset.ucSwitchPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucFswStatus);
          this->__isset.ucFswStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucSwitchingType);
          this->__isset.ucSwitchingType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPower.clear();
            uint32_t _size436;
            ::apache::thrift::protocol::TType _etype439;
            xfer += iprot->readListBegin(_etype439, _size436);
            this->asPortPower.resize(_size436);
            uint32_t _i440;
            for (_i440 = 0; _i440 < _size436; ++_i440)
            {
              xfer += iprot->readI16(this->asPortPower[_i440]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTxPower);
          this->__isset.sTxPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bFailure);
          this->__isset.bFailure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bInnerErr);
          this->__isset.bInnerErr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOffLine);
          this->__isset.bOffLine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsCurData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsCurData_t");

  xfer += oprot->writeFieldBegin("ucWorkMode", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucWorkMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucSwitchPos", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucSwitchPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucFswStatus", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->ucFswStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucSwitchingType", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->ucSwitchingType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPower", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPortPower.size()));
    std::vector<int16_t> ::const_iterator _iter441;
    for (_iter441 = this->asPortPower.begin(); _iter441 != this->asPortPower.end(); ++_iter441)
    {
      xfer += oprot->writeI16((*_iter441));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTxPower", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->sTxPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bFailure", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->bFailure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bInnerErr", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->bInnerErr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOffLine", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->bOffLine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsCurData_t &a, COpsCurData_t &b) {
  using ::std::swap;
  swap(a.ucWorkMode, b.ucWorkMode);
  swap(a.ucSwitchPos, b.ucSwitchPos);
  swap(a.ucFswStatus, b.ucFswStatus);
  swap(a.ucSwitchingType, b.ucSwitchingType);
  swap(a.asPortPower, b.asPortPower);
  swap(a.sTxPower, b.sTxPower);
  swap(a.bFailure, b.bFailure);
  swap(a.bInnerErr, b.bInnerErr);
  swap(a.bOffLine, b.bOffLine);
  swap(a.__isset, b.__isset);
}

COpsCurData_t::COpsCurData_t(const COpsCurData_t& other442) {
  ucWorkMode = other442.ucWorkMode;
  ucSwitchPos = other442.ucSwitchPos;
  ucFswStatus = other442.ucFswStatus;
  ucSwitchingType = other442.ucSwitchingType;
  asPortPower = other442.asPortPower;
  sTxPower = other442.sTxPower;
  bFailure = other442.bFailure;
  bInnerErr = other442.bInnerErr;
  bOffLine = other442.bOffLine;
  __isset = other442.__isset;
}
COpsCurData_t& COpsCurData_t::operator=(const COpsCurData_t& other443) {
  ucWorkMode = other443.ucWorkMode;
  ucSwitchPos = other443.ucSwitchPos;
  ucFswStatus = other443.ucFswStatus;
  ucSwitchingType = other443.ucSwitchingType;
  asPortPower = other443.asPortPower;
  sTxPower = other443.sTxPower;
  bFailure = other443.bFailure;
  bInnerErr = other443.bInnerErr;
  bOffLine = other443.bOffLine;
  __isset = other443.__isset;
  return *this;
}
void COpsCurData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsCurData_t(";
  out << "ucWorkMode=" << to_string(ucWorkMode);
  out << ", " << "ucSwitchPos=" << to_string(ucSwitchPos);
  out << ", " << "ucFswStatus=" << to_string(ucFswStatus);
  out << ", " << "ucSwitchingType=" << to_string(ucSwitchingType);
  out << ", " << "asPortPower=" << to_string(asPortPower);
  out << ", " << "sTxPower=" << to_string(sTxPower);
  out << ", " << "bFailure=" << to_string(bFailure);
  out << ", " << "bInnerErr=" << to_string(bInnerErr);
  out << ", " << "bOffLine=" << to_string(bOffLine);
  out << ")";
}


COpsAlarm_t::~COpsAlarm_t() noexcept {
}


void COpsAlarm_t::__set_aaucPortAlarm(const std::string& val) {
  this->aaucPortAlarm = val;
}

void COpsAlarm_t::__set_ucSwitchFailed(const int8_t val) {
  this->ucSwitchFailed = val;
}

void COpsAlarm_t::__set_ucRelative(const int8_t val) {
  this->ucRelative = val;
}

void COpsAlarm_t::__set_abSwitchAlarm(const std::vector<bool> & val) {
  this->abSwitchAlarm = val;
}

void COpsAlarm_t::__set_ucMfgFailed(const int8_t val) {
  this->ucMfgFailed = val;
}

void COpsAlarm_t::__set_ucComInLoss(const int8_t val) {
  this->ucComInLoss = val;
}

void COpsAlarm_t::__set_ucPowerDiffer(const int8_t val) {
  this->ucPowerDiffer = val;
}

void COpsAlarm_t::__set_auiDuration(const std::vector<std::vector<int32_t> > & val) {
  this->auiDuration = val;
}
std::ostream& operator<<(std::ostream& out, const COpsAlarm_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsAlarm_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aaucPortAlarm);
          this->__isset.aaucPortAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucSwitchFailed);
          this->__isset.ucSwitchFailed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucRelative);
          this->__isset.ucRelative = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abSwitchAlarm.clear();
            uint32_t _size444;
            ::apache::thrift::protocol::TType _etype447;
            xfer += iprot->readListBegin(_etype447, _size444);
            this->abSwitchAlarm.resize(_size444);
            uint32_t _i448;
            for (_i448 = 0; _i448 < _size444; ++_i448)
            {
              xfer += iprot->readBool(this->abSwitchAlarm[_i448]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abSwitchAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucMfgFailed);
          this->__isset.ucMfgFailed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucComInLoss);
          this->__isset.ucComInLoss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucPowerDiffer);
          this->__isset.ucPowerDiffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->auiDuration.clear();
            uint32_t _size449;
            ::apache::thrift::protocol::TType _etype452;
            xfer += iprot->readListBegin(_etype452, _size449);
            this->auiDuration.resize(_size449);
            uint32_t _i453;
            for (_i453 = 0; _i453 < _size449; ++_i453)
            {
              {
                this->auiDuration[_i453].clear();
                uint32_t _size454;
                ::apache::thrift::protocol::TType _etype457;
                xfer += iprot->readListBegin(_etype457, _size454);
                this->auiDuration[_i453].resize(_size454);
                uint32_t _i458;
                for (_i458 = 0; _i458 < _size454; ++_i458)
                {
                  xfer += iprot->readI32(this->auiDuration[_i453][_i458]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.auiDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsAlarm_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsAlarm_t");

  xfer += oprot->writeFieldBegin("aaucPortAlarm", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->aaucPortAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucSwitchFailed", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucSwitchFailed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucRelative", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->ucRelative);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abSwitchAlarm", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abSwitchAlarm.size()));
    std::vector<bool> ::const_iterator _iter459;
    for (_iter459 = this->abSwitchAlarm.begin(); _iter459 != this->abSwitchAlarm.end(); ++_iter459)
    {
      xfer += oprot->writeBool((*_iter459));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucMfgFailed", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->ucMfgFailed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucComInLoss", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->ucComInLoss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucPowerDiffer", ::apache::thrift::protocol::T_BYTE, 7);
  xfer += oprot->writeByte(this->ucPowerDiffer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("auiDuration", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->auiDuration.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter460;
    for (_iter460 = this->auiDuration.begin(); _iter460 != this->auiDuration.end(); ++_iter460)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter460).size()));
        std::vector<int32_t> ::const_iterator _iter461;
        for (_iter461 = (*_iter460).begin(); _iter461 != (*_iter460).end(); ++_iter461)
        {
          xfer += oprot->writeI32((*_iter461));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsAlarm_t &a, COpsAlarm_t &b) {
  using ::std::swap;
  swap(a.aaucPortAlarm, b.aaucPortAlarm);
  swap(a.ucSwitchFailed, b.ucSwitchFailed);
  swap(a.ucRelative, b.ucRelative);
  swap(a.abSwitchAlarm, b.abSwitchAlarm);
  swap(a.ucMfgFailed, b.ucMfgFailed);
  swap(a.ucComInLoss, b.ucComInLoss);
  swap(a.ucPowerDiffer, b.ucPowerDiffer);
  swap(a.auiDuration, b.auiDuration);
  swap(a.__isset, b.__isset);
}

COpsAlarm_t::COpsAlarm_t(const COpsAlarm_t& other462) {
  aaucPortAlarm = other462.aaucPortAlarm;
  ucSwitchFailed = other462.ucSwitchFailed;
  ucRelative = other462.ucRelative;
  abSwitchAlarm = other462.abSwitchAlarm;
  ucMfgFailed = other462.ucMfgFailed;
  ucComInLoss = other462.ucComInLoss;
  ucPowerDiffer = other462.ucPowerDiffer;
  auiDuration = other462.auiDuration;
  __isset = other462.__isset;
}
COpsAlarm_t& COpsAlarm_t::operator=(const COpsAlarm_t& other463) {
  aaucPortAlarm = other463.aaucPortAlarm;
  ucSwitchFailed = other463.ucSwitchFailed;
  ucRelative = other463.ucRelative;
  abSwitchAlarm = other463.abSwitchAlarm;
  ucMfgFailed = other463.ucMfgFailed;
  ucComInLoss = other463.ucComInLoss;
  ucPowerDiffer = other463.ucPowerDiffer;
  auiDuration = other463.auiDuration;
  __isset = other463.__isset;
  return *this;
}
void COpsAlarm_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsAlarm_t(";
  out << "aaucPortAlarm=" << to_string(aaucPortAlarm);
  out << ", " << "ucSwitchFailed=" << to_string(ucSwitchFailed);
  out << ", " << "ucRelative=" << to_string(ucRelative);
  out << ", " << "abSwitchAlarm=" << to_string(abSwitchAlarm);
  out << ", " << "ucMfgFailed=" << to_string(ucMfgFailed);
  out << ", " << "ucComInLoss=" << to_string(ucComInLoss);
  out << ", " << "ucPowerDiffer=" << to_string(ucPowerDiffer);
  out << ", " << "auiDuration=" << to_string(auiDuration);
  out << ")";
}


COpsHistoryUnitData_t::~COpsHistoryUnitData_t() noexcept {
}


void COpsHistoryUnitData_t::__set_uiHour(const int32_t val) {
  this->uiHour = val;
}

void COpsHistoryUnitData_t::__set_uiMinute(const int32_t val) {
  this->uiMinute = val;
}

void COpsHistoryUnitData_t::__set_uiSecond(const int32_t val) {
  this->uiSecond = val;
}

void COpsHistoryUnitData_t::__set_uiMillisecond(const int32_t val) {
  this->uiMillisecond = val;
}

void COpsHistoryUnitData_t::__set_asPortPowerHistory(const std::vector<std::vector<int16_t> > & val) {
  this->asPortPowerHistory = val;
}
std::ostream& operator<<(std::ostream& out, const COpsHistoryUnitData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsHistoryUnitData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiHour);
          this->__isset.uiHour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMinute);
          this->__isset.uiMinute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSecond);
          this->__isset.uiSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMillisecond);
          this->__isset.uiMillisecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPortPowerHistory.clear();
            uint32_t _size464;
            ::apache::thrift::protocol::TType _etype467;
            xfer += iprot->readListBegin(_etype467, _size464);
            this->asPortPowerHistory.resize(_size464);
            uint32_t _i468;
            for (_i468 = 0; _i468 < _size464; ++_i468)
            {
              {
                this->asPortPowerHistory[_i468].clear();
                uint32_t _size469;
                ::apache::thrift::protocol::TType _etype472;
                xfer += iprot->readListBegin(_etype472, _size469);
                this->asPortPowerHistory[_i468].resize(_size469);
                uint32_t _i473;
                for (_i473 = 0; _i473 < _size469; ++_i473)
                {
                  xfer += iprot->readI16(this->asPortPowerHistory[_i468][_i473]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPortPowerHistory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsHistoryUnitData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsHistoryUnitData_t");

  xfer += oprot->writeFieldBegin("uiHour", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiHour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMinute", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiMinute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSecond", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMillisecond", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiMillisecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asPortPowerHistory", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->asPortPowerHistory.size()));
    std::vector<std::vector<int16_t> > ::const_iterator _iter474;
    for (_iter474 = this->asPortPowerHistory.begin(); _iter474 != this->asPortPowerHistory.end(); ++_iter474)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*_iter474).size()));
        std::vector<int16_t> ::const_iterator _iter475;
        for (_iter475 = (*_iter474).begin(); _iter475 != (*_iter474).end(); ++_iter475)
        {
          xfer += oprot->writeI16((*_iter475));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsHistoryUnitData_t &a, COpsHistoryUnitData_t &b) {
  using ::std::swap;
  swap(a.uiHour, b.uiHour);
  swap(a.uiMinute, b.uiMinute);
  swap(a.uiSecond, b.uiSecond);
  swap(a.uiMillisecond, b.uiMillisecond);
  swap(a.asPortPowerHistory, b.asPortPowerHistory);
  swap(a.__isset, b.__isset);
}

COpsHistoryUnitData_t::COpsHistoryUnitData_t(const COpsHistoryUnitData_t& other476) {
  uiHour = other476.uiHour;
  uiMinute = other476.uiMinute;
  uiSecond = other476.uiSecond;
  uiMillisecond = other476.uiMillisecond;
  asPortPowerHistory = other476.asPortPowerHistory;
  __isset = other476.__isset;
}
COpsHistoryUnitData_t& COpsHistoryUnitData_t::operator=(const COpsHistoryUnitData_t& other477) {
  uiHour = other477.uiHour;
  uiMinute = other477.uiMinute;
  uiSecond = other477.uiSecond;
  uiMillisecond = other477.uiMillisecond;
  asPortPowerHistory = other477.asPortPowerHistory;
  __isset = other477.__isset;
  return *this;
}
void COpsHistoryUnitData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsHistoryUnitData_t(";
  out << "uiHour=" << to_string(uiHour);
  out << ", " << "uiMinute=" << to_string(uiMinute);
  out << ", " << "uiSecond=" << to_string(uiSecond);
  out << ", " << "uiMillisecond=" << to_string(uiMillisecond);
  out << ", " << "asPortPowerHistory=" << to_string(asPortPowerHistory);
  out << ")";
}


COpsHistoryData_t::~COpsHistoryData_t() noexcept {
}


void COpsHistoryData_t::__set_uiSwitchTimes(const int32_t val) {
  this->uiSwitchTimes = val;
}

void COpsHistoryData_t::__set_astOpsHisUnitData(const std::vector<COpsHistoryUnitData_t> & val) {
  this->astOpsHisUnitData = val;
}
std::ostream& operator<<(std::ostream& out, const COpsHistoryData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsHistoryData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSwitchTimes);
          this->__isset.uiSwitchTimes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astOpsHisUnitData.clear();
            uint32_t _size478;
            ::apache::thrift::protocol::TType _etype481;
            xfer += iprot->readListBegin(_etype481, _size478);
            this->astOpsHisUnitData.resize(_size478);
            uint32_t _i482;
            for (_i482 = 0; _i482 < _size478; ++_i482)
            {
              xfer += this->astOpsHisUnitData[_i482].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astOpsHisUnitData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsHistoryData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsHistoryData_t");

  xfer += oprot->writeFieldBegin("uiSwitchTimes", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSwitchTimes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astOpsHisUnitData", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astOpsHisUnitData.size()));
    std::vector<COpsHistoryUnitData_t> ::const_iterator _iter483;
    for (_iter483 = this->astOpsHisUnitData.begin(); _iter483 != this->astOpsHisUnitData.end(); ++_iter483)
    {
      xfer += (*_iter483).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsHistoryData_t &a, COpsHistoryData_t &b) {
  using ::std::swap;
  swap(a.uiSwitchTimes, b.uiSwitchTimes);
  swap(a.astOpsHisUnitData, b.astOpsHisUnitData);
  swap(a.__isset, b.__isset);
}

COpsHistoryData_t::COpsHistoryData_t(const COpsHistoryData_t& other484) {
  uiSwitchTimes = other484.uiSwitchTimes;
  astOpsHisUnitData = other484.astOpsHisUnitData;
  __isset = other484.__isset;
}
COpsHistoryData_t& COpsHistoryData_t::operator=(const COpsHistoryData_t& other485) {
  uiSwitchTimes = other485.uiSwitchTimes;
  astOpsHisUnitData = other485.astOpsHisUnitData;
  __isset = other485.__isset;
  return *this;
}
void COpsHistoryData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsHistoryData_t(";
  out << "uiSwitchTimes=" << to_string(uiSwitchTimes);
  out << ", " << "astOpsHisUnitData=" << to_string(astOpsHisUnitData);
  out << ")";
}


COscPd_t::~COscPd_t() noexcept {
}


void COscPd_t::__set_asPd(const std::vector<int16_t> & val) {
  this->asPd = val;
}
std::ostream& operator<<(std::ostream& out, const COscPd_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscPd_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPd.clear();
            uint32_t _size486;
            ::apache::thrift::protocol::TType _etype489;
            xfer += iprot->readListBegin(_etype489, _size486);
            this->asPd.resize(_size486);
            uint32_t _i490;
            for (_i490 = 0; _i490 < _size486; ++_i490)
            {
              xfer += iprot->readI16(this->asPd[_i490]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscPd_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscPd_t");

  xfer += oprot->writeFieldBegin("asPd", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPd.size()));
    std::vector<int16_t> ::const_iterator _iter491;
    for (_iter491 = this->asPd.begin(); _iter491 != this->asPd.end(); ++_iter491)
    {
      xfer += oprot->writeI16((*_iter491));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscPd_t &a, COscPd_t &b) {
  using ::std::swap;
  swap(a.asPd, b.asPd);
  swap(a.__isset, b.__isset);
}

COscPd_t::COscPd_t(const COscPd_t& other492) {
  asPd = other492.asPd;
  __isset = other492.__isset;
}
COscPd_t& COscPd_t::operator=(const COscPd_t& other493) {
  asPd = other493.asPd;
  __isset = other493.__isset;
  return *this;
}
void COscPd_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscPd_t(";
  out << "asPd=" << to_string(asPd);
  out << ")";
}


COscSwitchPos_t::~COscSwitchPos_t() noexcept {
}


void COscSwitchPos_t::__set_uiOut(const int32_t val) {
  this->uiOut = val;
}

void COscSwitchPos_t::__set_uiIn(const int32_t val) {
  this->uiIn = val;
}
std::ostream& operator<<(std::ostream& out, const COscSwitchPos_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscSwitchPos_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiOut);
          this->__isset.uiOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIn);
          this->__isset.uiIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscSwitchPos_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscSwitchPos_t");

  xfer += oprot->writeFieldBegin("uiOut", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiIn", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiIn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscSwitchPos_t &a, COscSwitchPos_t &b) {
  using ::std::swap;
  swap(a.uiOut, b.uiOut);
  swap(a.uiIn, b.uiIn);
  swap(a.__isset, b.__isset);
}

COscSwitchPos_t::COscSwitchPos_t(const COscSwitchPos_t& other494) {
  uiOut = other494.uiOut;
  uiIn = other494.uiIn;
  __isset = other494.__isset;
}
COscSwitchPos_t& COscSwitchPos_t::operator=(const COscSwitchPos_t& other495) {
  uiOut = other495.uiOut;
  uiIn = other495.uiIn;
  __isset = other495.__isset;
  return *this;
}
void COscSwitchPos_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscSwitchPos_t(";
  out << "uiOut=" << to_string(uiOut);
  out << ", " << "uiIn=" << to_string(uiIn);
  out << ")";
}


COscSwitchPosSet_t::~COscSwitchPosSet_t() noexcept {
}


void COscSwitchPosSet_t::__set_uiSwitchIdx(const int32_t val) {
  this->uiSwitchIdx = val;
}

void COscSwitchPosSet_t::__set_uiPos(const int32_t val) {
  this->uiPos = val;
}
std::ostream& operator<<(std::ostream& out, const COscSwitchPosSet_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscSwitchPosSet_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSwitchIdx);
          this->__isset.uiSwitchIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPos);
          this->__isset.uiPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscSwitchPosSet_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscSwitchPosSet_t");

  xfer += oprot->writeFieldBegin("uiSwitchIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSwitchIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscSwitchPosSet_t &a, COscSwitchPosSet_t &b) {
  using ::std::swap;
  swap(a.uiSwitchIdx, b.uiSwitchIdx);
  swap(a.uiPos, b.uiPos);
  swap(a.__isset, b.__isset);
}

COscSwitchPosSet_t::COscSwitchPosSet_t(const COscSwitchPosSet_t& other496) {
  uiSwitchIdx = other496.uiSwitchIdx;
  uiPos = other496.uiPos;
  __isset = other496.__isset;
}
COscSwitchPosSet_t& COscSwitchPosSet_t::operator=(const COscSwitchPosSet_t& other497) {
  uiSwitchIdx = other497.uiSwitchIdx;
  uiPos = other497.uiPos;
  __isset = other497.__isset;
  return *this;
}
void COscSwitchPosSet_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscSwitchPosSet_t(";
  out << "uiSwitchIdx=" << to_string(uiSwitchIdx);
  out << ", " << "uiPos=" << to_string(uiPos);
  out << ")";
}


COpsVoltage_t::~COpsVoltage_t() noexcept {
}


void COpsVoltage_t::__set_asVoltage(const std::vector<int16_t> & val) {
  this->asVoltage = val;
}
std::ostream& operator<<(std::ostream& out, const COpsVoltage_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsVoltage_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asVoltage.clear();
            uint32_t _size498;
            ::apache::thrift::protocol::TType _etype501;
            xfer += iprot->readListBegin(_etype501, _size498);
            this->asVoltage.resize(_size498);
            uint32_t _i502;
            for (_i502 = 0; _i502 < _size498; ++_i502)
            {
              xfer += iprot->readI16(this->asVoltage[_i502]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asVoltage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsVoltage_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsVoltage_t");

  xfer += oprot->writeFieldBegin("asVoltage", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asVoltage.size()));
    std::vector<int16_t> ::const_iterator _iter503;
    for (_iter503 = this->asVoltage.begin(); _iter503 != this->asVoltage.end(); ++_iter503)
    {
      xfer += oprot->writeI16((*_iter503));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsVoltage_t &a, COpsVoltage_t &b) {
  using ::std::swap;
  swap(a.asVoltage, b.asVoltage);
  swap(a.__isset, b.__isset);
}

COpsVoltage_t::COpsVoltage_t(const COpsVoltage_t& other504) {
  asVoltage = other504.asVoltage;
  __isset = other504.__isset;
}
COpsVoltage_t& COpsVoltage_t::operator=(const COpsVoltage_t& other505) {
  asVoltage = other505.asVoltage;
  __isset = other505.__isset;
  return *this;
}
void COpsVoltage_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsVoltage_t(";
  out << "asVoltage=" << to_string(asVoltage);
  out << ")";
}


COpsIL_t::~COpsIL_t() noexcept {
}


void COpsIL_t::__set_asInsertionLoss(const std::vector<int16_t> & val) {
  this->asInsertionLoss = val;
}
std::ostream& operator<<(std::ostream& out, const COpsIL_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsIL_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asInsertionLoss.clear();
            uint32_t _size506;
            ::apache::thrift::protocol::TType _etype509;
            xfer += iprot->readListBegin(_etype509, _size506);
            this->asInsertionLoss.resize(_size506);
            uint32_t _i510;
            for (_i510 = 0; _i510 < _size506; ++_i510)
            {
              xfer += iprot->readI16(this->asInsertionLoss[_i510]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asInsertionLoss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsIL_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsIL_t");

  xfer += oprot->writeFieldBegin("asInsertionLoss", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asInsertionLoss.size()));
    std::vector<int16_t> ::const_iterator _iter511;
    for (_iter511 = this->asInsertionLoss.begin(); _iter511 != this->asInsertionLoss.end(); ++_iter511)
    {
      xfer += oprot->writeI16((*_iter511));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsIL_t &a, COpsIL_t &b) {
  using ::std::swap;
  swap(a.asInsertionLoss, b.asInsertionLoss);
  swap(a.__isset, b.__isset);
}

COpsIL_t::COpsIL_t(const COpsIL_t& other512) {
  asInsertionLoss = other512.asInsertionLoss;
  __isset = other512.__isset;
}
COpsIL_t& COpsIL_t::operator=(const COpsIL_t& other513) {
  asInsertionLoss = other513.asInsertionLoss;
  __isset = other513.__isset;
  return *this;
}
void COpsIL_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsIL_t(";
  out << "asInsertionLoss=" << to_string(asInsertionLoss);
  out << ")";
}


COpsUpgStat_t::~COpsUpgStat_t() noexcept {
}


void COpsUpgStat_t::__set_sStatus(const int16_t val) {
  this->sStatus = val;
}
std::ostream& operator<<(std::ostream& out, const COpsUpgStat_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsUpgStat_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sStatus);
          this->__isset.sStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsUpgStat_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsUpgStat_t");

  xfer += oprot->writeFieldBegin("sStatus", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsUpgStat_t &a, COpsUpgStat_t &b) {
  using ::std::swap;
  swap(a.sStatus, b.sStatus);
  swap(a.__isset, b.__isset);
}

COpsUpgStat_t::COpsUpgStat_t(const COpsUpgStat_t& other514) {
  sStatus = other514.sStatus;
  __isset = other514.__isset;
}
COpsUpgStat_t& COpsUpgStat_t::operator=(const COpsUpgStat_t& other515) {
  sStatus = other515.sStatus;
  __isset = other515.__isset;
  return *this;
}
void COpsUpgStat_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsUpgStat_t(";
  out << "sStatus=" << to_string(sStatus);
  out << ")";
}


COpsConnectionPd_t::~COpsConnectionPd_t() noexcept {
}


void COpsConnectionPd_t::__set_asPd(const std::vector<int16_t> & val) {
  this->asPd = val;
}
std::ostream& operator<<(std::ostream& out, const COpsConnectionPd_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsConnectionPd_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPd.clear();
            uint32_t _size516;
            ::apache::thrift::protocol::TType _etype519;
            xfer += iprot->readListBegin(_etype519, _size516);
            this->asPd.resize(_size516);
            uint32_t _i520;
            for (_i520 = 0; _i520 < _size516; ++_i520)
            {
              xfer += iprot->readI16(this->asPd[_i520]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsConnectionPd_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsConnectionPd_t");

  xfer += oprot->writeFieldBegin("asPd", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPd.size()));
    std::vector<int16_t> ::const_iterator _iter521;
    for (_iter521 = this->asPd.begin(); _iter521 != this->asPd.end(); ++_iter521)
    {
      xfer += oprot->writeI16((*_iter521));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsConnectionPd_t &a, COpsConnectionPd_t &b) {
  using ::std::swap;
  swap(a.asPd, b.asPd);
  swap(a.__isset, b.__isset);
}

COpsConnectionPd_t::COpsConnectionPd_t(const COpsConnectionPd_t& other522) {
  asPd = other522.asPd;
  __isset = other522.__isset;
}
COpsConnectionPd_t& COpsConnectionPd_t::operator=(const COpsConnectionPd_t& other523) {
  asPd = other523.asPd;
  __isset = other523.__isset;
  return *this;
}
void COpsConnectionPd_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsConnectionPd_t(";
  out << "asPd=" << to_string(asPd);
  out << ")";
}


COpsPdAdc_t::~COpsPdAdc_t() noexcept {
}


void COpsPdAdc_t::__set_asPdAdc(const std::vector<int32_t> & val) {
  this->asPdAdc = val;
}
std::ostream& operator<<(std::ostream& out, const COpsPdAdc_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsPdAdc_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPdAdc.clear();
            uint32_t _size524;
            ::apache::thrift::protocol::TType _etype527;
            xfer += iprot->readListBegin(_etype527, _size524);
            this->asPdAdc.resize(_size524);
            uint32_t _i528;
            for (_i528 = 0; _i528 < _size524; ++_i528)
            {
              xfer += iprot->readI32(this->asPdAdc[_i528]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPdAdc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsPdAdc_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsPdAdc_t");

  xfer += oprot->writeFieldBegin("asPdAdc", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->asPdAdc.size()));
    std::vector<int32_t> ::const_iterator _iter529;
    for (_iter529 = this->asPdAdc.begin(); _iter529 != this->asPdAdc.end(); ++_iter529)
    {
      xfer += oprot->writeI32((*_iter529));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsPdAdc_t &a, COpsPdAdc_t &b) {
  using ::std::swap;
  swap(a.asPdAdc, b.asPdAdc);
  swap(a.__isset, b.__isset);
}

COpsPdAdc_t::COpsPdAdc_t(const COpsPdAdc_t& other530) {
  asPdAdc = other530.asPdAdc;
  __isset = other530.__isset;
}
COpsPdAdc_t& COpsPdAdc_t::operator=(const COpsPdAdc_t& other531) {
  asPdAdc = other531.asPdAdc;
  __isset = other531.__isset;
  return *this;
}
void COpsPdAdc_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsPdAdc_t(";
  out << "asPdAdc=" << to_string(asPdAdc);
  out << ")";
}


COpsConnectionPdThr_t::~COpsConnectionPdThr_t() noexcept {
}


void COpsConnectionPdThr_t::__set_asPdThr(const std::vector<int16_t> & val) {
  this->asPdThr = val;
}
std::ostream& operator<<(std::ostream& out, const COpsConnectionPdThr_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsConnectionPdThr_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPdThr.clear();
            uint32_t _size532;
            ::apache::thrift::protocol::TType _etype535;
            xfer += iprot->readListBegin(_etype535, _size532);
            this->asPdThr.resize(_size532);
            uint32_t _i536;
            for (_i536 = 0; _i536 < _size532; ++_i536)
            {
              xfer += iprot->readI16(this->asPdThr[_i536]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPdThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsConnectionPdThr_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsConnectionPdThr_t");

  xfer += oprot->writeFieldBegin("asPdThr", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPdThr.size()));
    std::vector<int16_t> ::const_iterator _iter537;
    for (_iter537 = this->asPdThr.begin(); _iter537 != this->asPdThr.end(); ++_iter537)
    {
      xfer += oprot->writeI16((*_iter537));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsConnectionPdThr_t &a, COpsConnectionPdThr_t &b) {
  using ::std::swap;
  swap(a.asPdThr, b.asPdThr);
  swap(a.__isset, b.__isset);
}

COpsConnectionPdThr_t::COpsConnectionPdThr_t(const COpsConnectionPdThr_t& other538) {
  asPdThr = other538.asPdThr;
  __isset = other538.__isset;
}
COpsConnectionPdThr_t& COpsConnectionPdThr_t::operator=(const COpsConnectionPdThr_t& other539) {
  asPdThr = other539.asPdThr;
  __isset = other539.__isset;
  return *this;
}
void COpsConnectionPdThr_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsConnectionPdThr_t(";
  out << "asPdThr=" << to_string(asPdThr);
  out << ")";
}


COpsConnectionPdHys_t::~COpsConnectionPdHys_t() noexcept {
}


void COpsConnectionPdHys_t::__set_asPdHys(const std::vector<int16_t> & val) {
  this->asPdHys = val;
}
std::ostream& operator<<(std::ostream& out, const COpsConnectionPdHys_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsConnectionPdHys_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asPdHys.clear();
            uint32_t _size540;
            ::apache::thrift::protocol::TType _etype543;
            xfer += iprot->readListBegin(_etype543, _size540);
            this->asPdHys.resize(_size540);
            uint32_t _i544;
            for (_i544 = 0; _i544 < _size540; ++_i544)
            {
              xfer += iprot->readI16(this->asPdHys[_i544]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asPdHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsConnectionPdHys_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsConnectionPdHys_t");

  xfer += oprot->writeFieldBegin("asPdHys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asPdHys.size()));
    std::vector<int16_t> ::const_iterator _iter545;
    for (_iter545 = this->asPdHys.begin(); _iter545 != this->asPdHys.end(); ++_iter545)
    {
      xfer += oprot->writeI16((*_iter545));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsConnectionPdHys_t &a, COpsConnectionPdHys_t &b) {
  using ::std::swap;
  swap(a.asPdHys, b.asPdHys);
  swap(a.__isset, b.__isset);
}

COpsConnectionPdHys_t::COpsConnectionPdHys_t(const COpsConnectionPdHys_t& other546) {
  asPdHys = other546.asPdHys;
  __isset = other546.__isset;
}
COpsConnectionPdHys_t& COpsConnectionPdHys_t::operator=(const COpsConnectionPdHys_t& other547) {
  asPdHys = other547.asPdHys;
  __isset = other547.__isset;
  return *this;
}
void COpsConnectionPdHys_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsConnectionPdHys_t(";
  out << "asPdHys=" << to_string(asPdHys);
  out << ")";
}


COpsReqStatus_t::~COpsReqStatus_t() noexcept {
}


void COpsReqStatus_t::__set_ucProtTypeR(const int8_t val) {
  this->ucProtTypeR = val;
}

void COpsReqStatus_t::__set_ucProtTypeD(const int8_t val) {
  this->ucProtTypeD = val;
}

void COpsReqStatus_t::__set_ucProtTypeB(const int8_t val) {
  this->ucProtTypeB = val;
}

void COpsReqStatus_t::__set_ucProtTypeA(const int8_t val) {
  this->ucProtTypeA = val;
}

void COpsReqStatus_t::__set_ucApsState(const int8_t val) {
  this->ucApsState = val;
}

void COpsReqStatus_t::__set_ucRequestedSignal(const int8_t val) {
  this->ucRequestedSignal = val;
}

void COpsReqStatus_t::__set_ucBridgedSignal(const int8_t val) {
  this->ucBridgedSignal = val;
}

void COpsReqStatus_t::__set_ucReserved(const int8_t val) {
  this->ucReserved = val;
}
std::ostream& operator<<(std::ostream& out, const COpsReqStatus_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsReqStatus_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucProtTypeR);
          this->__isset.ucProtTypeR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucProtTypeD);
          this->__isset.ucProtTypeD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucProtTypeB);
          this->__isset.ucProtTypeB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucProtTypeA);
          this->__isset.ucProtTypeA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucApsState);
          this->__isset.ucApsState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucRequestedSignal);
          this->__isset.ucRequestedSignal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucBridgedSignal);
          this->__isset.ucBridgedSignal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucReserved);
          this->__isset.ucReserved = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsReqStatus_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsReqStatus_t");

  xfer += oprot->writeFieldBegin("ucProtTypeR", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucProtTypeR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucProtTypeD", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucProtTypeD);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucProtTypeB", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->ucProtTypeB);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucProtTypeA", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->ucProtTypeA);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucApsState", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->ucApsState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucRequestedSignal", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->ucRequestedSignal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucBridgedSignal", ::apache::thrift::protocol::T_BYTE, 7);
  xfer += oprot->writeByte(this->ucBridgedSignal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucReserved", ::apache::thrift::protocol::T_BYTE, 8);
  xfer += oprot->writeByte(this->ucReserved);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsReqStatus_t &a, COpsReqStatus_t &b) {
  using ::std::swap;
  swap(a.ucProtTypeR, b.ucProtTypeR);
  swap(a.ucProtTypeD, b.ucProtTypeD);
  swap(a.ucProtTypeB, b.ucProtTypeB);
  swap(a.ucProtTypeA, b.ucProtTypeA);
  swap(a.ucApsState, b.ucApsState);
  swap(a.ucRequestedSignal, b.ucRequestedSignal);
  swap(a.ucBridgedSignal, b.ucBridgedSignal);
  swap(a.ucReserved, b.ucReserved);
  swap(a.__isset, b.__isset);
}

COpsReqStatus_t::COpsReqStatus_t(const COpsReqStatus_t& other548) {
  ucProtTypeR = other548.ucProtTypeR;
  ucProtTypeD = other548.ucProtTypeD;
  ucProtTypeB = other548.ucProtTypeB;
  ucProtTypeA = other548.ucProtTypeA;
  ucApsState = other548.ucApsState;
  ucRequestedSignal = other548.ucRequestedSignal;
  ucBridgedSignal = other548.ucBridgedSignal;
  ucReserved = other548.ucReserved;
  __isset = other548.__isset;
}
COpsReqStatus_t& COpsReqStatus_t::operator=(const COpsReqStatus_t& other549) {
  ucProtTypeR = other549.ucProtTypeR;
  ucProtTypeD = other549.ucProtTypeD;
  ucProtTypeB = other549.ucProtTypeB;
  ucProtTypeA = other549.ucProtTypeA;
  ucApsState = other549.ucApsState;
  ucRequestedSignal = other549.ucRequestedSignal;
  ucBridgedSignal = other549.ucBridgedSignal;
  ucReserved = other549.ucReserved;
  __isset = other549.__isset;
  return *this;
}
void COpsReqStatus_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsReqStatus_t(";
  out << "ucProtTypeR=" << to_string(ucProtTypeR);
  out << ", " << "ucProtTypeD=" << to_string(ucProtTypeD);
  out << ", " << "ucProtTypeB=" << to_string(ucProtTypeB);
  out << ", " << "ucProtTypeA=" << to_string(ucProtTypeA);
  out << ", " << "ucApsState=" << to_string(ucApsState);
  out << ", " << "ucRequestedSignal=" << to_string(ucRequestedSignal);
  out << ", " << "ucBridgedSignal=" << to_string(ucBridgedSignal);
  out << ", " << "ucReserved=" << to_string(ucReserved);
  out << ")";
}


COpsBidirectionStatus_t::~COpsBidirectionStatus_t() noexcept {
}


void COpsBidirectionStatus_t::__set_ucLocalWorkMode(const int8_t val) {
  this->ucLocalWorkMode = val;
}

void COpsBidirectionStatus_t::__set_ucLocalPosition(const int8_t val) {
  this->ucLocalPosition = val;
}

void COpsBidirectionStatus_t::__set_ucLocalStatus(const int8_t val) {
  this->ucLocalStatus = val;
}

void COpsBidirectionStatus_t::__set_stRemoteStatus(const COpsReqStatus_t& val) {
  this->stRemoteStatus = val;
}
std::ostream& operator<<(std::ostream& out, const COpsBidirectionStatus_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsBidirectionStatus_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucLocalWorkMode);
          this->__isset.ucLocalWorkMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucLocalPosition);
          this->__isset.ucLocalPosition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucLocalStatus);
          this->__isset.ucLocalStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stRemoteStatus.read(iprot);
          this->__isset.stRemoteStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsBidirectionStatus_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsBidirectionStatus_t");

  xfer += oprot->writeFieldBegin("ucLocalWorkMode", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucLocalWorkMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucLocalPosition", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucLocalPosition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucLocalStatus", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->ucLocalStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stRemoteStatus", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->stRemoteStatus.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsBidirectionStatus_t &a, COpsBidirectionStatus_t &b) {
  using ::std::swap;
  swap(a.ucLocalWorkMode, b.ucLocalWorkMode);
  swap(a.ucLocalPosition, b.ucLocalPosition);
  swap(a.ucLocalStatus, b.ucLocalStatus);
  swap(a.stRemoteStatus, b.stRemoteStatus);
  swap(a.__isset, b.__isset);
}

COpsBidirectionStatus_t::COpsBidirectionStatus_t(const COpsBidirectionStatus_t& other550) {
  ucLocalWorkMode = other550.ucLocalWorkMode;
  ucLocalPosition = other550.ucLocalPosition;
  ucLocalStatus = other550.ucLocalStatus;
  stRemoteStatus = other550.stRemoteStatus;
  __isset = other550.__isset;
}
COpsBidirectionStatus_t& COpsBidirectionStatus_t::operator=(const COpsBidirectionStatus_t& other551) {
  ucLocalWorkMode = other551.ucLocalWorkMode;
  ucLocalPosition = other551.ucLocalPosition;
  ucLocalStatus = other551.ucLocalStatus;
  stRemoteStatus = other551.stRemoteStatus;
  __isset = other551.__isset;
  return *this;
}
void COpsBidirectionStatus_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsBidirectionStatus_t(";
  out << "ucLocalWorkMode=" << to_string(ucLocalWorkMode);
  out << ", " << "ucLocalPosition=" << to_string(ucLocalPosition);
  out << ", " << "ucLocalStatus=" << to_string(ucLocalStatus);
  out << ", " << "stRemoteStatus=" << to_string(stRemoteStatus);
  out << ")";
}


COpsAlmMask_t::~COpsAlmMask_t() noexcept {
}


void COpsAlmMask_t::__set_Line1InLossAlarm(const int8_t val) {
  this->Line1InLossAlarm = val;
}

void COpsAlmMask_t::__set_Line2InLossAlarm(const int8_t val) {
  this->Line2InLossAlarm = val;
}

void COpsAlmMask_t::__set_SwitchFailedAlarm(const int8_t val) {
  this->SwitchFailedAlarm = val;
}

void COpsAlmMask_t::__set_LutAlarm(const int8_t val) {
  this->LutAlarm = val;
}

void COpsAlmMask_t::__set_RelativeAlarmbetweenLine1andLine2(const int8_t val) {
  this->RelativeAlarmbetweenLine1andLine2 = val;
}

void COpsAlmMask_t::__set_PDVoltageAlarm(const int8_t val) {
  this->PDVoltageAlarm = val;
}

void COpsAlmMask_t::__set_ComInLossAlarm(const int8_t val) {
  this->ComInLossAlarm = val;
}

void COpsAlmMask_t::__set_ReceivePowerDifferBetween(const int8_t val) {
  this->ReceivePowerDifferBetween = val;
}
std::ostream& operator<<(std::ostream& out, const COpsAlmMask_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsAlmMask_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->Line1InLossAlarm);
          this->__isset.Line1InLossAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->Line2InLossAlarm);
          this->__isset.Line2InLossAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->SwitchFailedAlarm);
          this->__isset.SwitchFailedAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->LutAlarm);
          this->__isset.LutAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->RelativeAlarmbetweenLine1andLine2);
          this->__isset.RelativeAlarmbetweenLine1andLine2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->PDVoltageAlarm);
          this->__isset.PDVoltageAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ComInLossAlarm);
          this->__isset.ComInLossAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ReceivePowerDifferBetween);
          this->__isset.ReceivePowerDifferBetween = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsAlmMask_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsAlmMask_t");

  xfer += oprot->writeFieldBegin("Line1InLossAlarm", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->Line1InLossAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Line2InLossAlarm", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->Line2InLossAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SwitchFailedAlarm", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->SwitchFailedAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("LutAlarm", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->LutAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RelativeAlarmbetweenLine1andLine2", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->RelativeAlarmbetweenLine1andLine2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PDVoltageAlarm", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->PDVoltageAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ComInLossAlarm", ::apache::thrift::protocol::T_BYTE, 7);
  xfer += oprot->writeByte(this->ComInLossAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ReceivePowerDifferBetween", ::apache::thrift::protocol::T_BYTE, 8);
  xfer += oprot->writeByte(this->ReceivePowerDifferBetween);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsAlmMask_t &a, COpsAlmMask_t &b) {
  using ::std::swap;
  swap(a.Line1InLossAlarm, b.Line1InLossAlarm);
  swap(a.Line2InLossAlarm, b.Line2InLossAlarm);
  swap(a.SwitchFailedAlarm, b.SwitchFailedAlarm);
  swap(a.LutAlarm, b.LutAlarm);
  swap(a.RelativeAlarmbetweenLine1andLine2, b.RelativeAlarmbetweenLine1andLine2);
  swap(a.PDVoltageAlarm, b.PDVoltageAlarm);
  swap(a.ComInLossAlarm, b.ComInLossAlarm);
  swap(a.ReceivePowerDifferBetween, b.ReceivePowerDifferBetween);
  swap(a.__isset, b.__isset);
}

COpsAlmMask_t::COpsAlmMask_t(const COpsAlmMask_t& other552) {
  Line1InLossAlarm = other552.Line1InLossAlarm;
  Line2InLossAlarm = other552.Line2InLossAlarm;
  SwitchFailedAlarm = other552.SwitchFailedAlarm;
  LutAlarm = other552.LutAlarm;
  RelativeAlarmbetweenLine1andLine2 = other552.RelativeAlarmbetweenLine1andLine2;
  PDVoltageAlarm = other552.PDVoltageAlarm;
  ComInLossAlarm = other552.ComInLossAlarm;
  ReceivePowerDifferBetween = other552.ReceivePowerDifferBetween;
  __isset = other552.__isset;
}
COpsAlmMask_t& COpsAlmMask_t::operator=(const COpsAlmMask_t& other553) {
  Line1InLossAlarm = other553.Line1InLossAlarm;
  Line2InLossAlarm = other553.Line2InLossAlarm;
  SwitchFailedAlarm = other553.SwitchFailedAlarm;
  LutAlarm = other553.LutAlarm;
  RelativeAlarmbetweenLine1andLine2 = other553.RelativeAlarmbetweenLine1andLine2;
  PDVoltageAlarm = other553.PDVoltageAlarm;
  ComInLossAlarm = other553.ComInLossAlarm;
  ReceivePowerDifferBetween = other553.ReceivePowerDifferBetween;
  __isset = other553.__isset;
  return *this;
}
void COpsAlmMask_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsAlmMask_t(";
  out << "Line1InLossAlarm=" << to_string(Line1InLossAlarm);
  out << ", " << "Line2InLossAlarm=" << to_string(Line2InLossAlarm);
  out << ", " << "SwitchFailedAlarm=" << to_string(SwitchFailedAlarm);
  out << ", " << "LutAlarm=" << to_string(LutAlarm);
  out << ", " << "RelativeAlarmbetweenLine1andLine2=" << to_string(RelativeAlarmbetweenLine1andLine2);
  out << ", " << "PDVoltageAlarm=" << to_string(PDVoltageAlarm);
  out << ", " << "ComInLossAlarm=" << to_string(ComInLossAlarm);
  out << ", " << "ReceivePowerDifferBetween=" << to_string(ReceivePowerDifferBetween);
  out << ")";
}


COpsCommStatusData_t::~COpsCommStatusData_t() noexcept {
}


void COpsCommStatusData_t::__set_stAlarm(const COpsAlarm_t& val) {
  this->stAlarm = val;
}

void COpsCommStatusData_t::__set_stLed(const COpsLed_t& val) {
  this->stLed = val;
}

void COpsCommStatusData_t::__set_stVoltage(const COpsVoltage_t& val) {
  this->stVoltage = val;
}

void COpsCommStatusData_t::__set_stAlmMask(const COpsAlmMask_t& val) {
  this->stAlmMask = val;
}
std::ostream& operator<<(std::ostream& out, const COpsCommStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsCommStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stAlarm.read(iprot);
          this->__isset.stAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stLed.read(iprot);
          this->__isset.stLed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stVoltage.read(iprot);
          this->__isset.stVoltage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stAlmMask.read(iprot);
          this->__isset.stAlmMask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsCommStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsCommStatusData_t");

  xfer += oprot->writeFieldBegin("stAlarm", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stAlarm.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stLed", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stLed.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stVoltage", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->stVoltage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stAlmMask", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->stAlmMask.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsCommStatusData_t &a, COpsCommStatusData_t &b) {
  using ::std::swap;
  swap(a.stAlarm, b.stAlarm);
  swap(a.stLed, b.stLed);
  swap(a.stVoltage, b.stVoltage);
  swap(a.stAlmMask, b.stAlmMask);
  swap(a.__isset, b.__isset);
}

COpsCommStatusData_t::COpsCommStatusData_t(const COpsCommStatusData_t& other554) {
  stAlarm = other554.stAlarm;
  stLed = other554.stLed;
  stVoltage = other554.stVoltage;
  stAlmMask = other554.stAlmMask;
  __isset = other554.__isset;
}
COpsCommStatusData_t& COpsCommStatusData_t::operator=(const COpsCommStatusData_t& other555) {
  stAlarm = other555.stAlarm;
  stLed = other555.stLed;
  stVoltage = other555.stVoltage;
  stAlmMask = other555.stAlmMask;
  __isset = other555.__isset;
  return *this;
}
void COpsCommStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsCommStatusData_t(";
  out << "stAlarm=" << to_string(stAlarm);
  out << ", " << "stLed=" << to_string(stLed);
  out << ", " << "stVoltage=" << to_string(stVoltage);
  out << ", " << "stAlmMask=" << to_string(stAlmMask);
  out << ")";
}


COpsStatusData_t::~COpsStatusData_t() noexcept {
}


void COpsStatusData_t::__set_stCurData(const COpsCurData_t& val) {
  this->stCurData = val;
}

void COpsStatusData_t::__set_stWssStaData(const CWssStatusData_t& val) {
  this->stWssStaData = val;
}

void COpsStatusData_t::__set_stOscPd(const COscPd_t& val) {
  this->stOscPd = val;
}

void COpsStatusData_t::__set_stIl(const COpsIL_t& val) {
  this->stIl = val;
}

void COpsStatusData_t::__set_stConnectionPds(const COpsConnectionPd_t& val) {
  this->stConnectionPds = val;
}

void COpsStatusData_t::__set_stBidiStatus(const COpsBidirectionStatus_t& val) {
  this->stBidiStatus = val;
}
std::ostream& operator<<(std::ostream& out, const COpsStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stCurData.read(iprot);
          this->__isset.stCurData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stWssStaData.read(iprot);
          this->__isset.stWssStaData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stOscPd.read(iprot);
          this->__isset.stOscPd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stIl.read(iprot);
          this->__isset.stIl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stConnectionPds.read(iprot);
          this->__isset.stConnectionPds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stBidiStatus.read(iprot);
          this->__isset.stBidiStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsStatusData_t");

  xfer += oprot->writeFieldBegin("stCurData", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stCurData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stWssStaData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stWssStaData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stOscPd", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->stOscPd.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stIl", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->stIl.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stConnectionPds", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->stConnectionPds.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stBidiStatus", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->stBidiStatus.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsStatusData_t &a, COpsStatusData_t &b) {
  using ::std::swap;
  swap(a.stCurData, b.stCurData);
  swap(a.stWssStaData, b.stWssStaData);
  swap(a.stOscPd, b.stOscPd);
  swap(a.stIl, b.stIl);
  swap(a.stConnectionPds, b.stConnectionPds);
  swap(a.stBidiStatus, b.stBidiStatus);
  swap(a.__isset, b.__isset);
}

COpsStatusData_t::COpsStatusData_t(const COpsStatusData_t& other556) {
  stCurData = other556.stCurData;
  stWssStaData = other556.stWssStaData;
  stOscPd = other556.stOscPd;
  stIl = other556.stIl;
  stConnectionPds = other556.stConnectionPds;
  stBidiStatus = other556.stBidiStatus;
  __isset = other556.__isset;
}
COpsStatusData_t& COpsStatusData_t::operator=(const COpsStatusData_t& other557) {
  stCurData = other557.stCurData;
  stWssStaData = other557.stWssStaData;
  stOscPd = other557.stOscPd;
  stIl = other557.stIl;
  stConnectionPds = other557.stConnectionPds;
  stBidiStatus = other557.stBidiStatus;
  __isset = other557.__isset;
  return *this;
}
void COpsStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsStatusData_t(";
  out << "stCurData=" << to_string(stCurData);
  out << ", " << "stWssStaData=" << to_string(stWssStaData);
  out << ", " << "stOscPd=" << to_string(stOscPd);
  out << ", " << "stIl=" << to_string(stIl);
  out << ", " << "stConnectionPds=" << to_string(stConnectionPds);
  out << ", " << "stBidiStatus=" << to_string(stBidiStatus);
  out << ")";
}


COpsSwitchThr_t::~COpsSwitchThr_t() noexcept {
}


void COpsSwitchThr_t::__set_asThr(const std::vector<int16_t> & val) {
  this->asThr = val;
}
std::ostream& operator<<(std::ostream& out, const COpsSwitchThr_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsSwitchThr_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asThr.clear();
            uint32_t _size558;
            ::apache::thrift::protocol::TType _etype561;
            xfer += iprot->readListBegin(_etype561, _size558);
            this->asThr.resize(_size558);
            uint32_t _i562;
            for (_i562 = 0; _i562 < _size558; ++_i562)
            {
              xfer += iprot->readI16(this->asThr[_i562]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsSwitchThr_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsSwitchThr_t");

  xfer += oprot->writeFieldBegin("asThr", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asThr.size()));
    std::vector<int16_t> ::const_iterator _iter563;
    for (_iter563 = this->asThr.begin(); _iter563 != this->asThr.end(); ++_iter563)
    {
      xfer += oprot->writeI16((*_iter563));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsSwitchThr_t &a, COpsSwitchThr_t &b) {
  using ::std::swap;
  swap(a.asThr, b.asThr);
  swap(a.__isset, b.__isset);
}

COpsSwitchThr_t::COpsSwitchThr_t(const COpsSwitchThr_t& other564) {
  asThr = other564.asThr;
  __isset = other564.__isset;
}
COpsSwitchThr_t& COpsSwitchThr_t::operator=(const COpsSwitchThr_t& other565) {
  asThr = other565.asThr;
  __isset = other565.__isset;
  return *this;
}
void COpsSwitchThr_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsSwitchThr_t(";
  out << "asThr=" << to_string(asThr);
  out << ")";
}


COpsSwitchHys_t::~COpsSwitchHys_t() noexcept {
}


void COpsSwitchHys_t::__set_asHys(const std::vector<int16_t> & val) {
  this->asHys = val;
}
std::ostream& operator<<(std::ostream& out, const COpsSwitchHys_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsSwitchHys_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asHys.clear();
            uint32_t _size566;
            ::apache::thrift::protocol::TType _etype569;
            xfer += iprot->readListBegin(_etype569, _size566);
            this->asHys.resize(_size566);
            uint32_t _i570;
            for (_i570 = 0; _i570 < _size566; ++_i570)
            {
              xfer += iprot->readI16(this->asHys[_i570]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsSwitchHys_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsSwitchHys_t");

  xfer += oprot->writeFieldBegin("asHys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->asHys.size()));
    std::vector<int16_t> ::const_iterator _iter571;
    for (_iter571 = this->asHys.begin(); _iter571 != this->asHys.end(); ++_iter571)
    {
      xfer += oprot->writeI16((*_iter571));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsSwitchHys_t &a, COpsSwitchHys_t &b) {
  using ::std::swap;
  swap(a.asHys, b.asHys);
  swap(a.__isset, b.__isset);
}

COpsSwitchHys_t::COpsSwitchHys_t(const COpsSwitchHys_t& other572) {
  asHys = other572.asHys;
  __isset = other572.__isset;
}
COpsSwitchHys_t& COpsSwitchHys_t::operator=(const COpsSwitchHys_t& other573) {
  asHys = other573.asHys;
  __isset = other573.__isset;
  return *this;
}
void COpsSwitchHys_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsSwitchHys_t(";
  out << "asHys=" << to_string(asHys);
  out << ")";
}


CPortPowerThr_t::~CPortPowerThr_t() noexcept {
}


void CPortPowerThr_t::__set_asThr(const std::vector<std::vector<int16_t> > & val) {
  this->asThr = val;
}

void CPortPowerThr_t::__set_sDifferBetweenLine1Line2(const int16_t val) {
  this->sDifferBetweenLine1Line2 = val;
}
std::ostream& operator<<(std::ostream& out, const CPortPowerThr_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPortPowerThr_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asThr.clear();
            uint32_t _size574;
            ::apache::thrift::protocol::TType _etype577;
            xfer += iprot->readListBegin(_etype577, _size574);
            this->asThr.resize(_size574);
            uint32_t _i578;
            for (_i578 = 0; _i578 < _size574; ++_i578)
            {
              {
                this->asThr[_i578].clear();
                uint32_t _size579;
                ::apache::thrift::protocol::TType _etype582;
                xfer += iprot->readListBegin(_etype582, _size579);
                this->asThr[_i578].resize(_size579);
                uint32_t _i583;
                for (_i583 = 0; _i583 < _size579; ++_i583)
                {
                  xfer += iprot->readI16(this->asThr[_i578][_i583]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sDifferBetweenLine1Line2);
          this->__isset.sDifferBetweenLine1Line2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPortPowerThr_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPortPowerThr_t");

  xfer += oprot->writeFieldBegin("asThr", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->asThr.size()));
    std::vector<std::vector<int16_t> > ::const_iterator _iter584;
    for (_iter584 = this->asThr.begin(); _iter584 != this->asThr.end(); ++_iter584)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*_iter584).size()));
        std::vector<int16_t> ::const_iterator _iter585;
        for (_iter585 = (*_iter584).begin(); _iter585 != (*_iter584).end(); ++_iter585)
        {
          xfer += oprot->writeI16((*_iter585));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sDifferBetweenLine1Line2", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sDifferBetweenLine1Line2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPortPowerThr_t &a, CPortPowerThr_t &b) {
  using ::std::swap;
  swap(a.asThr, b.asThr);
  swap(a.sDifferBetweenLine1Line2, b.sDifferBetweenLine1Line2);
  swap(a.__isset, b.__isset);
}

CPortPowerThr_t::CPortPowerThr_t(const CPortPowerThr_t& other586) {
  asThr = other586.asThr;
  sDifferBetweenLine1Line2 = other586.sDifferBetweenLine1Line2;
  __isset = other586.__isset;
}
CPortPowerThr_t& CPortPowerThr_t::operator=(const CPortPowerThr_t& other587) {
  asThr = other587.asThr;
  sDifferBetweenLine1Line2 = other587.sDifferBetweenLine1Line2;
  __isset = other587.__isset;
  return *this;
}
void CPortPowerThr_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPortPowerThr_t(";
  out << "asThr=" << to_string(asThr);
  out << ", " << "sDifferBetweenLine1Line2=" << to_string(sDifferBetweenLine1Line2);
  out << ")";
}


CPortPowerHys_t::~CPortPowerHys_t() noexcept {
}


void CPortPowerHys_t::__set_asHys(const std::vector<std::vector<int16_t> > & val) {
  this->asHys = val;
}
std::ostream& operator<<(std::ostream& out, const CPortPowerHys_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPortPowerHys_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asHys.clear();
            uint32_t _size588;
            ::apache::thrift::protocol::TType _etype591;
            xfer += iprot->readListBegin(_etype591, _size588);
            this->asHys.resize(_size588);
            uint32_t _i592;
            for (_i592 = 0; _i592 < _size588; ++_i592)
            {
              {
                this->asHys[_i592].clear();
                uint32_t _size593;
                ::apache::thrift::protocol::TType _etype596;
                xfer += iprot->readListBegin(_etype596, _size593);
                this->asHys[_i592].resize(_size593);
                uint32_t _i597;
                for (_i597 = 0; _i597 < _size593; ++_i597)
                {
                  xfer += iprot->readI16(this->asHys[_i592][_i597]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPortPowerHys_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPortPowerHys_t");

  xfer += oprot->writeFieldBegin("asHys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->asHys.size()));
    std::vector<std::vector<int16_t> > ::const_iterator _iter598;
    for (_iter598 = this->asHys.begin(); _iter598 != this->asHys.end(); ++_iter598)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*_iter598).size()));
        std::vector<int16_t> ::const_iterator _iter599;
        for (_iter599 = (*_iter598).begin(); _iter599 != (*_iter598).end(); ++_iter599)
        {
          xfer += oprot->writeI16((*_iter599));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPortPowerHys_t &a, CPortPowerHys_t &b) {
  using ::std::swap;
  swap(a.asHys, b.asHys);
  swap(a.__isset, b.__isset);
}

CPortPowerHys_t::CPortPowerHys_t(const CPortPowerHys_t& other600) {
  asHys = other600.asHys;
  __isset = other600.__isset;
}
CPortPowerHys_t& CPortPowerHys_t::operator=(const CPortPowerHys_t& other601) {
  asHys = other601.asHys;
  __isset = other601.__isset;
  return *this;
}
void CPortPowerHys_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPortPowerHys_t(";
  out << "asHys=" << to_string(asHys);
  out << ")";
}


CWssPortPowerThr_t::~CWssPortPowerThr_t() noexcept {
}


void CWssPortPowerThr_t::__set_asThr(const std::vector<std::vector<int16_t> > & val) {
  this->asThr = val;
}
std::ostream& operator<<(std::ostream& out, const CWssPortPowerThr_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssPortPowerThr_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asThr.clear();
            uint32_t _size602;
            ::apache::thrift::protocol::TType _etype605;
            xfer += iprot->readListBegin(_etype605, _size602);
            this->asThr.resize(_size602);
            uint32_t _i606;
            for (_i606 = 0; _i606 < _size602; ++_i606)
            {
              {
                this->asThr[_i606].clear();
                uint32_t _size607;
                ::apache::thrift::protocol::TType _etype610;
                xfer += iprot->readListBegin(_etype610, _size607);
                this->asThr[_i606].resize(_size607);
                uint32_t _i611;
                for (_i611 = 0; _i611 < _size607; ++_i611)
                {
                  xfer += iprot->readI16(this->asThr[_i606][_i611]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssPortPowerThr_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssPortPowerThr_t");

  xfer += oprot->writeFieldBegin("asThr", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->asThr.size()));
    std::vector<std::vector<int16_t> > ::const_iterator _iter612;
    for (_iter612 = this->asThr.begin(); _iter612 != this->asThr.end(); ++_iter612)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*_iter612).size()));
        std::vector<int16_t> ::const_iterator _iter613;
        for (_iter613 = (*_iter612).begin(); _iter613 != (*_iter612).end(); ++_iter613)
        {
          xfer += oprot->writeI16((*_iter613));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssPortPowerThr_t &a, CWssPortPowerThr_t &b) {
  using ::std::swap;
  swap(a.asThr, b.asThr);
  swap(a.__isset, b.__isset);
}

CWssPortPowerThr_t::CWssPortPowerThr_t(const CWssPortPowerThr_t& other614) {
  asThr = other614.asThr;
  __isset = other614.__isset;
}
CWssPortPowerThr_t& CWssPortPowerThr_t::operator=(const CWssPortPowerThr_t& other615) {
  asThr = other615.asThr;
  __isset = other615.__isset;
  return *this;
}
void CWssPortPowerThr_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssPortPowerThr_t(";
  out << "asThr=" << to_string(asThr);
  out << ")";
}


CWssPortPowerHys_t::~CWssPortPowerHys_t() noexcept {
}


void CWssPortPowerHys_t::__set_asHys(const std::vector<std::vector<int16_t> > & val) {
  this->asHys = val;
}
std::ostream& operator<<(std::ostream& out, const CWssPortPowerHys_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssPortPowerHys_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->asHys.clear();
            uint32_t _size616;
            ::apache::thrift::protocol::TType _etype619;
            xfer += iprot->readListBegin(_etype619, _size616);
            this->asHys.resize(_size616);
            uint32_t _i620;
            for (_i620 = 0; _i620 < _size616; ++_i620)
            {
              {
                this->asHys[_i620].clear();
                uint32_t _size621;
                ::apache::thrift::protocol::TType _etype624;
                xfer += iprot->readListBegin(_etype624, _size621);
                this->asHys[_i620].resize(_size621);
                uint32_t _i625;
                for (_i625 = 0; _i625 < _size621; ++_i625)
                {
                  xfer += iprot->readI16(this->asHys[_i620][_i625]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.asHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssPortPowerHys_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssPortPowerHys_t");

  xfer += oprot->writeFieldBegin("asHys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->asHys.size()));
    std::vector<std::vector<int16_t> > ::const_iterator _iter626;
    for (_iter626 = this->asHys.begin(); _iter626 != this->asHys.end(); ++_iter626)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>((*_iter626).size()));
        std::vector<int16_t> ::const_iterator _iter627;
        for (_iter627 = (*_iter626).begin(); _iter627 != (*_iter626).end(); ++_iter627)
        {
          xfer += oprot->writeI16((*_iter627));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssPortPowerHys_t &a, CWssPortPowerHys_t &b) {
  using ::std::swap;
  swap(a.asHys, b.asHys);
  swap(a.__isset, b.__isset);
}

CWssPortPowerHys_t::CWssPortPowerHys_t(const CWssPortPowerHys_t& other628) {
  asHys = other628.asHys;
  __isset = other628.__isset;
}
CWssPortPowerHys_t& CWssPortPowerHys_t::operator=(const CWssPortPowerHys_t& other629) {
  asHys = other629.asHys;
  __isset = other629.__isset;
  return *this;
}
void CWssPortPowerHys_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssPortPowerHys_t(";
  out << "asHys=" << to_string(asHys);
  out << ")";
}


CRelativeThr_t::~CRelativeThr_t() noexcept {
}


void CRelativeThr_t::__set_sThr(const int16_t val) {
  this->sThr = val;
}
std::ostream& operator<<(std::ostream& out, const CRelativeThr_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CRelativeThr_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CRelativeThr_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CRelativeThr_t");

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CRelativeThr_t &a, CRelativeThr_t &b) {
  using ::std::swap;
  swap(a.sThr, b.sThr);
  swap(a.__isset, b.__isset);
}

CRelativeThr_t::CRelativeThr_t(const CRelativeThr_t& other630) {
  sThr = other630.sThr;
  __isset = other630.__isset;
}
CRelativeThr_t& CRelativeThr_t::operator=(const CRelativeThr_t& other631) {
  sThr = other631.sThr;
  __isset = other631.__isset;
  return *this;
}
void CRelativeThr_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CRelativeThr_t(";
  out << "sThr=" << to_string(sThr);
  out << ")";
}


CRelativeOffset_t::~CRelativeOffset_t() noexcept {
}


void CRelativeOffset_t::__set_sOffset(const int16_t val) {
  this->sOffset = val;
}
std::ostream& operator<<(std::ostream& out, const CRelativeOffset_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CRelativeOffset_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOffset);
          this->__isset.sOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CRelativeOffset_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CRelativeOffset_t");

  xfer += oprot->writeFieldBegin("sOffset", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CRelativeOffset_t &a, CRelativeOffset_t &b) {
  using ::std::swap;
  swap(a.sOffset, b.sOffset);
  swap(a.__isset, b.__isset);
}

CRelativeOffset_t::CRelativeOffset_t(const CRelativeOffset_t& other632) {
  sOffset = other632.sOffset;
  __isset = other632.__isset;
}
CRelativeOffset_t& CRelativeOffset_t::operator=(const CRelativeOffset_t& other633) {
  sOffset = other633.sOffset;
  __isset = other633.__isset;
  return *this;
}
void CRelativeOffset_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CRelativeOffset_t(";
  out << "sOffset=" << to_string(sOffset);
  out << ")";
}


COpsCfgData_t::~COpsCfgData_t() noexcept {
}


void COpsCfgData_t::__set_ucWorkMode(const int8_t val) {
  this->ucWorkMode = val;
}

void COpsCfgData_t::__set_usRelativeEnable(const int16_t val) {
  this->usRelativeEnable = val;
}

void COpsCfgData_t::__set_usHoldTime(const int16_t val) {
  this->usHoldTime = val;
}

void COpsCfgData_t::__set_usRelativeSwitchThr(const int16_t val) {
  this->usRelativeSwitchThr = val;
}

void COpsCfgData_t::__set_sRelativeOffset(const int16_t val) {
  this->sRelativeOffset = val;
}

void COpsCfgData_t::__set_uiWtrTime(const int32_t val) {
  this->uiWtrTime = val;
}

void COpsCfgData_t::__set_uiHour(const int32_t val) {
  this->uiHour = val;
}

void COpsCfgData_t::__set_uiMinute(const int32_t val) {
  this->uiMinute = val;
}

void COpsCfgData_t::__set_uiSecond(const int32_t val) {
  this->uiSecond = val;
}

void COpsCfgData_t::__set_stPortPowerThr(const CPortPowerThr_t& val) {
  this->stPortPowerThr = val;
}

void COpsCfgData_t::__set_stPortPowerHys(const CPortPowerHys_t& val) {
  this->stPortPowerHys = val;
}

void COpsCfgData_t::__set_stWssPortPowerThr(const CWssPortPowerThr_t& val) {
  this->stWssPortPowerThr = val;
}

void COpsCfgData_t::__set_stWssPortPowerHys(const CWssPortPowerHys_t& val) {
  this->stWssPortPowerHys = val;
}

void COpsCfgData_t::__set_stSwitchThr(const COpsSwitchThr_t& val) {
  this->stSwitchThr = val;
}

void COpsCfgData_t::__set_stSwitchHys(const COpsSwitchHys_t& val) {
  this->stSwitchHys = val;
}

void COpsCfgData_t::__set_stConnectionPdThr(const COpsConnectionPdThr_t& val) {
  this->stConnectionPdThr = val;
}

void COpsCfgData_t::__set_stConnectionPdHys(const COpsConnectionPdHys_t& val) {
  this->stConnectionPdHys = val;
}
std::ostream& operator<<(std::ostream& out, const COpsCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucWorkMode);
          this->__isset.ucWorkMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usRelativeEnable);
          this->__isset.usRelativeEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usHoldTime);
          this->__isset.usHoldTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usRelativeSwitchThr);
          this->__isset.usRelativeSwitchThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sRelativeOffset);
          this->__isset.sRelativeOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiWtrTime);
          this->__isset.uiWtrTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiHour);
          this->__isset.uiHour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMinute);
          this->__isset.uiMinute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSecond);
          this->__isset.uiSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stPortPowerThr.read(iprot);
          this->__isset.stPortPowerThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stPortPowerHys.read(iprot);
          this->__isset.stPortPowerHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stWssPortPowerThr.read(iprot);
          this->__isset.stWssPortPowerThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stWssPortPowerHys.read(iprot);
          this->__isset.stWssPortPowerHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stSwitchThr.read(iprot);
          this->__isset.stSwitchThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stSwitchHys.read(iprot);
          this->__isset.stSwitchHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stConnectionPdThr.read(iprot);
          this->__isset.stConnectionPdThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stConnectionPdHys.read(iprot);
          this->__isset.stConnectionPdHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsCfgData_t");

  xfer += oprot->writeFieldBegin("ucWorkMode", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucWorkMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usRelativeEnable", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->usRelativeEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usHoldTime", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->usHoldTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usRelativeSwitchThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->usRelativeSwitchThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sRelativeOffset", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->sRelativeOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiWtrTime", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->uiWtrTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiHour", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->uiHour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMinute", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->uiMinute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSecond", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->uiSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stPortPowerThr", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->stPortPowerThr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stPortPowerHys", ::apache::thrift::protocol::T_STRUCT, 11);
  xfer += this->stPortPowerHys.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stWssPortPowerThr", ::apache::thrift::protocol::T_STRUCT, 12);
  xfer += this->stWssPortPowerThr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stWssPortPowerHys", ::apache::thrift::protocol::T_STRUCT, 13);
  xfer += this->stWssPortPowerHys.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stSwitchThr", ::apache::thrift::protocol::T_STRUCT, 14);
  xfer += this->stSwitchThr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stSwitchHys", ::apache::thrift::protocol::T_STRUCT, 15);
  xfer += this->stSwitchHys.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stConnectionPdThr", ::apache::thrift::protocol::T_STRUCT, 16);
  xfer += this->stConnectionPdThr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stConnectionPdHys", ::apache::thrift::protocol::T_STRUCT, 17);
  xfer += this->stConnectionPdHys.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsCfgData_t &a, COpsCfgData_t &b) {
  using ::std::swap;
  swap(a.ucWorkMode, b.ucWorkMode);
  swap(a.usRelativeEnable, b.usRelativeEnable);
  swap(a.usHoldTime, b.usHoldTime);
  swap(a.usRelativeSwitchThr, b.usRelativeSwitchThr);
  swap(a.sRelativeOffset, b.sRelativeOffset);
  swap(a.uiWtrTime, b.uiWtrTime);
  swap(a.uiHour, b.uiHour);
  swap(a.uiMinute, b.uiMinute);
  swap(a.uiSecond, b.uiSecond);
  swap(a.stPortPowerThr, b.stPortPowerThr);
  swap(a.stPortPowerHys, b.stPortPowerHys);
  swap(a.stWssPortPowerThr, b.stWssPortPowerThr);
  swap(a.stWssPortPowerHys, b.stWssPortPowerHys);
  swap(a.stSwitchThr, b.stSwitchThr);
  swap(a.stSwitchHys, b.stSwitchHys);
  swap(a.stConnectionPdThr, b.stConnectionPdThr);
  swap(a.stConnectionPdHys, b.stConnectionPdHys);
  swap(a.__isset, b.__isset);
}

COpsCfgData_t::COpsCfgData_t(const COpsCfgData_t& other634) {
  ucWorkMode = other634.ucWorkMode;
  usRelativeEnable = other634.usRelativeEnable;
  usHoldTime = other634.usHoldTime;
  usRelativeSwitchThr = other634.usRelativeSwitchThr;
  sRelativeOffset = other634.sRelativeOffset;
  uiWtrTime = other634.uiWtrTime;
  uiHour = other634.uiHour;
  uiMinute = other634.uiMinute;
  uiSecond = other634.uiSecond;
  stPortPowerThr = other634.stPortPowerThr;
  stPortPowerHys = other634.stPortPowerHys;
  stWssPortPowerThr = other634.stWssPortPowerThr;
  stWssPortPowerHys = other634.stWssPortPowerHys;
  stSwitchThr = other634.stSwitchThr;
  stSwitchHys = other634.stSwitchHys;
  stConnectionPdThr = other634.stConnectionPdThr;
  stConnectionPdHys = other634.stConnectionPdHys;
  __isset = other634.__isset;
}
COpsCfgData_t& COpsCfgData_t::operator=(const COpsCfgData_t& other635) {
  ucWorkMode = other635.ucWorkMode;
  usRelativeEnable = other635.usRelativeEnable;
  usHoldTime = other635.usHoldTime;
  usRelativeSwitchThr = other635.usRelativeSwitchThr;
  sRelativeOffset = other635.sRelativeOffset;
  uiWtrTime = other635.uiWtrTime;
  uiHour = other635.uiHour;
  uiMinute = other635.uiMinute;
  uiSecond = other635.uiSecond;
  stPortPowerThr = other635.stPortPowerThr;
  stPortPowerHys = other635.stPortPowerHys;
  stWssPortPowerThr = other635.stWssPortPowerThr;
  stWssPortPowerHys = other635.stWssPortPowerHys;
  stSwitchThr = other635.stSwitchThr;
  stSwitchHys = other635.stSwitchHys;
  stConnectionPdThr = other635.stConnectionPdThr;
  stConnectionPdHys = other635.stConnectionPdHys;
  __isset = other635.__isset;
  return *this;
}
void COpsCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsCfgData_t(";
  out << "ucWorkMode=" << to_string(ucWorkMode);
  out << ", " << "usRelativeEnable=" << to_string(usRelativeEnable);
  out << ", " << "usHoldTime=" << to_string(usHoldTime);
  out << ", " << "usRelativeSwitchThr=" << to_string(usRelativeSwitchThr);
  out << ", " << "sRelativeOffset=" << to_string(sRelativeOffset);
  out << ", " << "uiWtrTime=" << to_string(uiWtrTime);
  out << ", " << "uiHour=" << to_string(uiHour);
  out << ", " << "uiMinute=" << to_string(uiMinute);
  out << ", " << "uiSecond=" << to_string(uiSecond);
  out << ", " << "stPortPowerThr=" << to_string(stPortPowerThr);
  out << ", " << "stPortPowerHys=" << to_string(stPortPowerHys);
  out << ", " << "stWssPortPowerThr=" << to_string(stWssPortPowerThr);
  out << ", " << "stWssPortPowerHys=" << to_string(stWssPortPowerHys);
  out << ", " << "stSwitchThr=" << to_string(stSwitchThr);
  out << ", " << "stSwitchHys=" << to_string(stSwitchHys);
  out << ", " << "stConnectionPdThr=" << to_string(stConnectionPdThr);
  out << ", " << "stConnectionPdHys=" << to_string(stConnectionPdHys);
  out << ")";
}


COpsEventLogData_t::~COpsEventLogData_t() noexcept {
}


void COpsEventLogData_t::__set_uiSwitchOffsetTime(const int32_t val) {
  this->uiSwitchOffsetTime = val;
}

void COpsEventLogData_t::__set_uiAlarmOffsetTime(const int32_t val) {
  this->uiAlarmOffsetTime = val;
}

void COpsEventLogData_t::__set_sAlarmWPower(const int16_t val) {
  this->sAlarmWPower = val;
}

void COpsEventLogData_t::__set_sAlarmPPower(const int16_t val) {
  this->sAlarmPPower = val;
}

void COpsEventLogData_t::__set_uiSwitchState(const int32_t val) {
  this->uiSwitchState = val;
}
std::ostream& operator<<(std::ostream& out, const COpsEventLogData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsEventLogData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSwitchOffsetTime);
          this->__isset.uiSwitchOffsetTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiAlarmOffsetTime);
          this->__isset.uiAlarmOffsetTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAlarmWPower);
          this->__isset.sAlarmWPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAlarmPPower);
          this->__isset.sAlarmPPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSwitchState);
          this->__isset.uiSwitchState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsEventLogData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsEventLogData_t");

  xfer += oprot->writeFieldBegin("uiSwitchOffsetTime", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSwitchOffsetTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiAlarmOffsetTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiAlarmOffsetTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAlarmWPower", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sAlarmWPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAlarmPPower", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sAlarmPPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSwitchState", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiSwitchState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsEventLogData_t &a, COpsEventLogData_t &b) {
  using ::std::swap;
  swap(a.uiSwitchOffsetTime, b.uiSwitchOffsetTime);
  swap(a.uiAlarmOffsetTime, b.uiAlarmOffsetTime);
  swap(a.sAlarmWPower, b.sAlarmWPower);
  swap(a.sAlarmPPower, b.sAlarmPPower);
  swap(a.uiSwitchState, b.uiSwitchState);
  swap(a.__isset, b.__isset);
}

COpsEventLogData_t::COpsEventLogData_t(const COpsEventLogData_t& other636) {
  uiSwitchOffsetTime = other636.uiSwitchOffsetTime;
  uiAlarmOffsetTime = other636.uiAlarmOffsetTime;
  sAlarmWPower = other636.sAlarmWPower;
  sAlarmPPower = other636.sAlarmPPower;
  uiSwitchState = other636.uiSwitchState;
  __isset = other636.__isset;
}
COpsEventLogData_t& COpsEventLogData_t::operator=(const COpsEventLogData_t& other637) {
  uiSwitchOffsetTime = other637.uiSwitchOffsetTime;
  uiAlarmOffsetTime = other637.uiAlarmOffsetTime;
  sAlarmWPower = other637.sAlarmWPower;
  sAlarmPPower = other637.sAlarmPPower;
  uiSwitchState = other637.uiSwitchState;
  __isset = other637.__isset;
  return *this;
}
void COpsEventLogData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsEventLogData_t(";
  out << "uiSwitchOffsetTime=" << to_string(uiSwitchOffsetTime);
  out << ", " << "uiAlarmOffsetTime=" << to_string(uiAlarmOffsetTime);
  out << ", " << "sAlarmWPower=" << to_string(sAlarmWPower);
  out << ", " << "sAlarmPPower=" << to_string(sAlarmPPower);
  out << ", " << "uiSwitchState=" << to_string(uiSwitchState);
  out << ")";
}


COpsEventLogAllData_t::~COpsEventLogAllData_t() noexcept {
}


void COpsEventLogAllData_t::__set_stOpsEventLogData(const std::vector<COpsEventLogData_t> & val) {
  this->stOpsEventLogData = val;
}

void COpsEventLogAllData_t::__set_rev(const std::string& val) {
  this->rev = val;
}
std::ostream& operator<<(std::ostream& out, const COpsEventLogAllData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsEventLogAllData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stOpsEventLogData.clear();
            uint32_t _size638;
            ::apache::thrift::protocol::TType _etype641;
            xfer += iprot->readListBegin(_etype641, _size638);
            this->stOpsEventLogData.resize(_size638);
            uint32_t _i642;
            for (_i642 = 0; _i642 < _size638; ++_i642)
            {
              xfer += this->stOpsEventLogData[_i642].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stOpsEventLogData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->rev);
          this->__isset.rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsEventLogAllData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsEventLogAllData_t");

  xfer += oprot->writeFieldBegin("stOpsEventLogData", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stOpsEventLogData.size()));
    std::vector<COpsEventLogData_t> ::const_iterator _iter643;
    for (_iter643 = this->stOpsEventLogData.begin(); _iter643 != this->stOpsEventLogData.end(); ++_iter643)
    {
      xfer += (*_iter643).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rev", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->rev);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsEventLogAllData_t &a, COpsEventLogAllData_t &b) {
  using ::std::swap;
  swap(a.stOpsEventLogData, b.stOpsEventLogData);
  swap(a.rev, b.rev);
  swap(a.__isset, b.__isset);
}

COpsEventLogAllData_t::COpsEventLogAllData_t(const COpsEventLogAllData_t& other644) {
  stOpsEventLogData = other644.stOpsEventLogData;
  rev = other644.rev;
  __isset = other644.__isset;
}
COpsEventLogAllData_t& COpsEventLogAllData_t::operator=(const COpsEventLogAllData_t& other645) {
  stOpsEventLogData = other645.stOpsEventLogData;
  rev = other645.rev;
  __isset = other645.__isset;
  return *this;
}
void COpsEventLogAllData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsEventLogAllData_t(";
  out << "stOpsEventLogData=" << to_string(stOpsEventLogData);
  out << ", " << "rev=" << to_string(rev);
  out << ")";
}


CCvMuxStatusData_t::~CCvMuxStatusData_t() noexcept {
}


void CCvMuxStatusData_t::__set_sOutputPowerR(const int16_t val) {
  this->sOutputPowerR = val;
}

void CCvMuxStatusData_t::__set_sInputPowerR(const int16_t val) {
  this->sInputPowerR = val;
}

void CCvMuxStatusData_t::__set_sOutputPowerT(const int16_t val) {
  this->sOutputPowerT = val;
}

void CCvMuxStatusData_t::__set_sInputPowerT(const int16_t val) {
  this->sInputPowerT = val;
}
std::ostream& operator<<(std::ostream& out, const CCvMuxStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCvMuxStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutputPowerR);
          this->__isset.sOutputPowerR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sInputPowerR);
          this->__isset.sInputPowerR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutputPowerT);
          this->__isset.sOutputPowerT = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sInputPowerT);
          this->__isset.sInputPowerT = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCvMuxStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCvMuxStatusData_t");

  xfer += oprot->writeFieldBegin("sOutputPowerR", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sOutputPowerR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sInputPowerR", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sInputPowerR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutputPowerT", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sOutputPowerT);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sInputPowerT", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sInputPowerT);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCvMuxStatusData_t &a, CCvMuxStatusData_t &b) {
  using ::std::swap;
  swap(a.sOutputPowerR, b.sOutputPowerR);
  swap(a.sInputPowerR, b.sInputPowerR);
  swap(a.sOutputPowerT, b.sOutputPowerT);
  swap(a.sInputPowerT, b.sInputPowerT);
  swap(a.__isset, b.__isset);
}

CCvMuxStatusData_t::CCvMuxStatusData_t(const CCvMuxStatusData_t& other646) {
  sOutputPowerR = other646.sOutputPowerR;
  sInputPowerR = other646.sInputPowerR;
  sOutputPowerT = other646.sOutputPowerT;
  sInputPowerT = other646.sInputPowerT;
  __isset = other646.__isset;
}
CCvMuxStatusData_t& CCvMuxStatusData_t::operator=(const CCvMuxStatusData_t& other647) {
  sOutputPowerR = other647.sOutputPowerR;
  sInputPowerR = other647.sInputPowerR;
  sOutputPowerT = other647.sOutputPowerT;
  sInputPowerT = other647.sInputPowerT;
  __isset = other647.__isset;
  return *this;
}
void CCvMuxStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCvMuxStatusData_t(";
  out << "sOutputPowerR=" << to_string(sOutputPowerR);
  out << ", " << "sInputPowerR=" << to_string(sInputPowerR);
  out << ", " << "sOutputPowerT=" << to_string(sOutputPowerT);
  out << ", " << "sInputPowerT=" << to_string(sInputPowerT);
  out << ")";
}


CCvClientStatusData_t::~CCvClientStatusData_t() noexcept {
}


void CCvClientStatusData_t::__set_sOutputPowerR(const int16_t val) {
  this->sOutputPowerR = val;
}

void CCvClientStatusData_t::__set_sInputPowerR(const int16_t val) {
  this->sInputPowerR = val;
}

void CCvClientStatusData_t::__set_sOutputPowerT(const int16_t val) {
  this->sOutputPowerT = val;
}

void CCvClientStatusData_t::__set_sInputPowerT(const int16_t val) {
  this->sInputPowerT = val;
}
std::ostream& operator<<(std::ostream& out, const CCvClientStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCvClientStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutputPowerR);
          this->__isset.sOutputPowerR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sInputPowerR);
          this->__isset.sInputPowerR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutputPowerT);
          this->__isset.sOutputPowerT = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sInputPowerT);
          this->__isset.sInputPowerT = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCvClientStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCvClientStatusData_t");

  xfer += oprot->writeFieldBegin("sOutputPowerR", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sOutputPowerR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sInputPowerR", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sInputPowerR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutputPowerT", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sOutputPowerT);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sInputPowerT", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sInputPowerT);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCvClientStatusData_t &a, CCvClientStatusData_t &b) {
  using ::std::swap;
  swap(a.sOutputPowerR, b.sOutputPowerR);
  swap(a.sInputPowerR, b.sInputPowerR);
  swap(a.sOutputPowerT, b.sOutputPowerT);
  swap(a.sInputPowerT, b.sInputPowerT);
  swap(a.__isset, b.__isset);
}

CCvClientStatusData_t::CCvClientStatusData_t(const CCvClientStatusData_t& other648) {
  sOutputPowerR = other648.sOutputPowerR;
  sInputPowerR = other648.sInputPowerR;
  sOutputPowerT = other648.sOutputPowerT;
  sInputPowerT = other648.sInputPowerT;
  __isset = other648.__isset;
}
CCvClientStatusData_t& CCvClientStatusData_t::operator=(const CCvClientStatusData_t& other649) {
  sOutputPowerR = other649.sOutputPowerR;
  sInputPowerR = other649.sInputPowerR;
  sOutputPowerT = other649.sOutputPowerT;
  sInputPowerT = other649.sInputPowerT;
  __isset = other649.__isset;
  return *this;
}
void CCvClientStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCvClientStatusData_t(";
  out << "sOutputPowerR=" << to_string(sOutputPowerR);
  out << ", " << "sInputPowerR=" << to_string(sInputPowerR);
  out << ", " << "sOutputPowerT=" << to_string(sOutputPowerT);
  out << ", " << "sInputPowerT=" << to_string(sInputPowerT);
  out << ")";
}


CCvRef_t::~CCvRef_t() noexcept {
}


void CCvRef_t::__set_sOutputPower(const int16_t val) {
  this->sOutputPower = val;
}

void CCvRef_t::__set_sRefPower(const int16_t val) {
  this->sRefPower = val;
}
std::ostream& operator<<(std::ostream& out, const CCvRef_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCvRef_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutputPower);
          this->__isset.sOutputPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sRefPower);
          this->__isset.sRefPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCvRef_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCvRef_t");

  xfer += oprot->writeFieldBegin("sOutputPower", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sOutputPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sRefPower", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sRefPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCvRef_t &a, CCvRef_t &b) {
  using ::std::swap;
  swap(a.sOutputPower, b.sOutputPower);
  swap(a.sRefPower, b.sRefPower);
  swap(a.__isset, b.__isset);
}

CCvRef_t::CCvRef_t(const CCvRef_t& other650) {
  sOutputPower = other650.sOutputPower;
  sRefPower = other650.sRefPower;
  __isset = other650.__isset;
}
CCvRef_t& CCvRef_t::operator=(const CCvRef_t& other651) {
  sOutputPower = other651.sOutputPower;
  sRefPower = other651.sRefPower;
  __isset = other651.__isset;
  return *this;
}
void CCvRef_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCvRef_t(";
  out << "sOutputPower=" << to_string(sOutputPower);
  out << ", " << "sRefPower=" << to_string(sRefPower);
  out << ")";
}


COcsConnection_t::~COcsConnection_t() noexcept {
}


void COcsConnection_t::__set_ucId(const int8_t val) {
  this->ucId = val;
}

void COcsConnection_t::__set_ucSource(const int8_t val) {
  this->ucSource = val;
}

void COcsConnection_t::__set_ucDestination(const int8_t val) {
  this->ucDestination = val;
}

void COcsConnection_t::__set_ucReserve(const int8_t val) {
  this->ucReserve = val;
}
std::ostream& operator<<(std::ostream& out, const COcsConnection_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsConnection_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucId);
          this->__isset.ucId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucSource);
          this->__isset.ucSource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucDestination);
          this->__isset.ucDestination = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucReserve);
          this->__isset.ucReserve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsConnection_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsConnection_t");

  xfer += oprot->writeFieldBegin("ucId", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucSource", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucSource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucDestination", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->ucDestination);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucReserve", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->ucReserve);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsConnection_t &a, COcsConnection_t &b) {
  using ::std::swap;
  swap(a.ucId, b.ucId);
  swap(a.ucSource, b.ucSource);
  swap(a.ucDestination, b.ucDestination);
  swap(a.ucReserve, b.ucReserve);
  swap(a.__isset, b.__isset);
}

COcsConnection_t::COcsConnection_t(const COcsConnection_t& other652) {
  ucId = other652.ucId;
  ucSource = other652.ucSource;
  ucDestination = other652.ucDestination;
  ucReserve = other652.ucReserve;
  __isset = other652.__isset;
}
COcsConnection_t& COcsConnection_t::operator=(const COcsConnection_t& other653) {
  ucId = other653.ucId;
  ucSource = other653.ucSource;
  ucDestination = other653.ucDestination;
  ucReserve = other653.ucReserve;
  __isset = other653.__isset;
  return *this;
}
void COcsConnection_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsConnection_t(";
  out << "ucId=" << to_string(ucId);
  out << ", " << "ucSource=" << to_string(ucSource);
  out << ", " << "ucDestination=" << to_string(ucDestination);
  out << ", " << "ucReserve=" << to_string(ucReserve);
  out << ")";
}


COcsConnections_t::~COcsConnections_t() noexcept {
}


void COcsConnections_t::__set_uiCount(const int32_t val) {
  this->uiCount = val;
}

void COcsConnections_t::__set_astConn(const std::vector<COcsConnection_t> & val) {
  this->astConn = val;
}
std::ostream& operator<<(std::ostream& out, const COcsConnections_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsConnections_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiCount);
          this->__isset.uiCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astConn.clear();
            uint32_t _size654;
            ::apache::thrift::protocol::TType _etype657;
            xfer += iprot->readListBegin(_etype657, _size654);
            this->astConn.resize(_size654);
            uint32_t _i658;
            for (_i658 = 0; _i658 < _size654; ++_i658)
            {
              xfer += this->astConn[_i658].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astConn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsConnections_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsConnections_t");

  xfer += oprot->writeFieldBegin("uiCount", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astConn", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astConn.size()));
    std::vector<COcsConnection_t> ::const_iterator _iter659;
    for (_iter659 = this->astConn.begin(); _iter659 != this->astConn.end(); ++_iter659)
    {
      xfer += (*_iter659).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsConnections_t &a, COcsConnections_t &b) {
  using ::std::swap;
  swap(a.uiCount, b.uiCount);
  swap(a.astConn, b.astConn);
  swap(a.__isset, b.__isset);
}

COcsConnections_t::COcsConnections_t(const COcsConnections_t& other660) {
  uiCount = other660.uiCount;
  astConn = other660.astConn;
  __isset = other660.__isset;
}
COcsConnections_t& COcsConnections_t::operator=(const COcsConnections_t& other661) {
  uiCount = other661.uiCount;
  astConn = other661.astConn;
  __isset = other661.__isset;
  return *this;
}
void COcsConnections_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsConnections_t(";
  out << "uiCount=" << to_string(uiCount);
  out << ", " << "astConn=" << to_string(astConn);
  out << ")";
}


COcsAlarm_t::~COcsAlarm_t() noexcept {
}


void COcsAlarm_t::__set_abAlarms(const std::vector<bool> & val) {
  this->abAlarms = val;
}

void COcsAlarm_t::__set_aucReserve(const std::string& val) {
  this->aucReserve = val;
}
std::ostream& operator<<(std::ostream& out, const COcsAlarm_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsAlarm_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abAlarms.clear();
            uint32_t _size662;
            ::apache::thrift::protocol::TType _etype665;
            xfer += iprot->readListBegin(_etype665, _size662);
            this->abAlarms.resize(_size662);
            uint32_t _i666;
            for (_i666 = 0; _i666 < _size662; ++_i666)
            {
              xfer += iprot->readBool(this->abAlarms[_i666]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abAlarms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucReserve);
          this->__isset.aucReserve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsAlarm_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsAlarm_t");

  xfer += oprot->writeFieldBegin("abAlarms", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abAlarms.size()));
    std::vector<bool> ::const_iterator _iter667;
    for (_iter667 = this->abAlarms.begin(); _iter667 != this->abAlarms.end(); ++_iter667)
    {
      xfer += oprot->writeBool((*_iter667));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucReserve", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->aucReserve);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsAlarm_t &a, COcsAlarm_t &b) {
  using ::std::swap;
  swap(a.abAlarms, b.abAlarms);
  swap(a.aucReserve, b.aucReserve);
  swap(a.__isset, b.__isset);
}

COcsAlarm_t::COcsAlarm_t(const COcsAlarm_t& other668) {
  abAlarms = other668.abAlarms;
  aucReserve = other668.aucReserve;
  __isset = other668.__isset;
}
COcsAlarm_t& COcsAlarm_t::operator=(const COcsAlarm_t& other669) {
  abAlarms = other669.abAlarms;
  aucReserve = other669.aucReserve;
  __isset = other669.__isset;
  return *this;
}
void COcsAlarm_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsAlarm_t(";
  out << "abAlarms=" << to_string(abAlarms);
  out << ", " << "aucReserve=" << to_string(aucReserve);
  out << ")";
}


COcsLedSta_t::~COcsLedSta_t() noexcept {
}


void COcsLedSta_t::__set_aucLedSta(const std::string& val) {
  this->aucLedSta = val;
}

void COcsLedSta_t::__set_ucLedWorkSta(const int8_t val) {
  this->ucLedWorkSta = val;
}

void COcsLedSta_t::__set_aucReserve(const std::string& val) {
  this->aucReserve = val;
}
std::ostream& operator<<(std::ostream& out, const COcsLedSta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsLedSta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucLedSta);
          this->__isset.aucLedSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucLedWorkSta);
          this->__isset.ucLedWorkSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucReserve);
          this->__isset.aucReserve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsLedSta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsLedSta_t");

  xfer += oprot->writeFieldBegin("aucLedSta", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->aucLedSta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucLedWorkSta", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucLedWorkSta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucReserve", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->aucReserve);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsLedSta_t &a, COcsLedSta_t &b) {
  using ::std::swap;
  swap(a.aucLedSta, b.aucLedSta);
  swap(a.ucLedWorkSta, b.ucLedWorkSta);
  swap(a.aucReserve, b.aucReserve);
  swap(a.__isset, b.__isset);
}

COcsLedSta_t::COcsLedSta_t(const COcsLedSta_t& other670) {
  aucLedSta = other670.aucLedSta;
  ucLedWorkSta = other670.ucLedWorkSta;
  aucReserve = other670.aucReserve;
  __isset = other670.__isset;
}
COcsLedSta_t& COcsLedSta_t::operator=(const COcsLedSta_t& other671) {
  aucLedSta = other671.aucLedSta;
  ucLedWorkSta = other671.ucLedWorkSta;
  aucReserve = other671.aucReserve;
  __isset = other671.__isset;
  return *this;
}
void COcsLedSta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsLedSta_t(";
  out << "aucLedSta=" << to_string(aucLedSta);
  out << ", " << "ucLedWorkSta=" << to_string(ucLedWorkSta);
  out << ", " << "aucReserve=" << to_string(aucReserve);
  out << ")";
}


COcsTempSta_t::~COcsTempSta_t() noexcept {
}


void COcsTempSta_t::__set_sCaseTemp(const int16_t val) {
  this->sCaseTemp = val;
}

void COcsTempSta_t::__set_aucReserve(const std::string& val) {
  this->aucReserve = val;
}
std::ostream& operator<<(std::ostream& out, const COcsTempSta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsTempSta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sCaseTemp);
          this->__isset.sCaseTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucReserve);
          this->__isset.aucReserve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsTempSta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsTempSta_t");

  xfer += oprot->writeFieldBegin("sCaseTemp", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->sCaseTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucReserve", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->aucReserve);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsTempSta_t &a, COcsTempSta_t &b) {
  using ::std::swap;
  swap(a.sCaseTemp, b.sCaseTemp);
  swap(a.aucReserve, b.aucReserve);
  swap(a.__isset, b.__isset);
}

COcsTempSta_t::COcsTempSta_t(const COcsTempSta_t& other672) {
  sCaseTemp = other672.sCaseTemp;
  aucReserve = other672.aucReserve;
  __isset = other672.__isset;
}
COcsTempSta_t& COcsTempSta_t::operator=(const COcsTempSta_t& other673) {
  sCaseTemp = other673.sCaseTemp;
  aucReserve = other673.aucReserve;
  __isset = other673.__isset;
  return *this;
}
void COcsTempSta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsTempSta_t(";
  out << "sCaseTemp=" << to_string(sCaseTemp);
  out << ", " << "aucReserve=" << to_string(aucReserve);
  out << ")";
}


COcsStatusData_t::~COcsStatusData_t() noexcept {
}


void COcsStatusData_t::__set_stAlm(const COcsAlarm_t& val) {
  this->stAlm = val;
}

void COcsStatusData_t::__set_stConnsSta(const COcsConnections_t& val) {
  this->stConnsSta = val;
}

void COcsStatusData_t::__set_stLedSta(const COcsLedSta_t& val) {
  this->stLedSta = val;
}

void COcsStatusData_t::__set_stTempSta(const COcsTempSta_t& val) {
  this->stTempSta = val;
}
std::ostream& operator<<(std::ostream& out, const COcsStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stAlm.read(iprot);
          this->__isset.stAlm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stConnsSta.read(iprot);
          this->__isset.stConnsSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stLedSta.read(iprot);
          this->__isset.stLedSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stTempSta.read(iprot);
          this->__isset.stTempSta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsStatusData_t");

  xfer += oprot->writeFieldBegin("stAlm", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stAlm.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stConnsSta", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stConnsSta.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stLedSta", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->stLedSta.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stTempSta", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->stTempSta.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsStatusData_t &a, COcsStatusData_t &b) {
  using ::std::swap;
  swap(a.stAlm, b.stAlm);
  swap(a.stConnsSta, b.stConnsSta);
  swap(a.stLedSta, b.stLedSta);
  swap(a.stTempSta, b.stTempSta);
  swap(a.__isset, b.__isset);
}

COcsStatusData_t::COcsStatusData_t(const COcsStatusData_t& other674) {
  stAlm = other674.stAlm;
  stConnsSta = other674.stConnsSta;
  stLedSta = other674.stLedSta;
  stTempSta = other674.stTempSta;
  __isset = other674.__isset;
}
COcsStatusData_t& COcsStatusData_t::operator=(const COcsStatusData_t& other675) {
  stAlm = other675.stAlm;
  stConnsSta = other675.stConnsSta;
  stLedSta = other675.stLedSta;
  stTempSta = other675.stTempSta;
  __isset = other675.__isset;
  return *this;
}
void COcsStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsStatusData_t(";
  out << "stAlm=" << to_string(stAlm);
  out << ", " << "stConnsSta=" << to_string(stConnsSta);
  out << ", " << "stLedSta=" << to_string(stLedSta);
  out << ", " << "stTempSta=" << to_string(stTempSta);
  out << ")";
}


COcsCfgData_t::~COcsCfgData_t() noexcept {
}


void COcsCfgData_t::__set_stConns(const COcsConnections_t& val) {
  this->stConns = val;
}
std::ostream& operator<<(std::ostream& out, const COcsCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stConns.read(iprot);
          this->__isset.stConns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsCfgData_t");

  xfer += oprot->writeFieldBegin("stConns", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stConns.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsCfgData_t &a, COcsCfgData_t &b) {
  using ::std::swap;
  swap(a.stConns, b.stConns);
  swap(a.__isset, b.__isset);
}

COcsCfgData_t::COcsCfgData_t(const COcsCfgData_t& other676) {
  stConns = other676.stConns;
  __isset = other676.__isset;
}
COcsCfgData_t& COcsCfgData_t::operator=(const COcsCfgData_t& other677) {
  stConns = other677.stConns;
  __isset = other677.__isset;
  return *this;
}
void COcsCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsCfgData_t(";
  out << "stConns=" << to_string(stConns);
  out << ")";
}


CSlotDevInfo_t::~CSlotDevInfo_t() noexcept {
}


void CSlotDevInfo_t::__set_uiDevType(const int32_t val) {
  this->uiDevType = val;
}

void CSlotDevInfo_t::__set_uiDevIdx(const int32_t val) {
  this->uiDevIdx = val;
}

void CSlotDevInfo_t::__set_uiSubType(const int32_t val) {
  this->uiSubType = val;
}

void CSlotDevInfo_t::__set_uiFuncType(const int32_t val) {
  this->uiFuncType = val;
}

void CSlotDevInfo_t::__set_bOnBoard(const bool val) {
  this->bOnBoard = val;
}
std::ostream& operator<<(std::ostream& out, const CSlotDevInfo_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CSlotDevInfo_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSubType);
          this->__isset.uiSubType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiFuncType);
          this->__isset.uiFuncType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOnBoard);
          this->__isset.bOnBoard = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSlotDevInfo_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSlotDevInfo_t");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSubType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiSubType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiFuncType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiFuncType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOnBoard", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->bOnBoard);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSlotDevInfo_t &a, CSlotDevInfo_t &b) {
  using ::std::swap;
  swap(a.uiDevType, b.uiDevType);
  swap(a.uiDevIdx, b.uiDevIdx);
  swap(a.uiSubType, b.uiSubType);
  swap(a.uiFuncType, b.uiFuncType);
  swap(a.bOnBoard, b.bOnBoard);
  swap(a.__isset, b.__isset);
}

CSlotDevInfo_t::CSlotDevInfo_t(const CSlotDevInfo_t& other678) {
  uiDevType = other678.uiDevType;
  uiDevIdx = other678.uiDevIdx;
  uiSubType = other678.uiSubType;
  uiFuncType = other678.uiFuncType;
  bOnBoard = other678.bOnBoard;
  __isset = other678.__isset;
}
CSlotDevInfo_t& CSlotDevInfo_t::operator=(const CSlotDevInfo_t& other679) {
  uiDevType = other679.uiDevType;
  uiDevIdx = other679.uiDevIdx;
  uiSubType = other679.uiSubType;
  uiFuncType = other679.uiFuncType;
  bOnBoard = other679.bOnBoard;
  __isset = other679.__isset;
  return *this;
}
void CSlotDevInfo_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSlotDevInfo_t(";
  out << "uiDevType=" << to_string(uiDevType);
  out << ", " << "uiDevIdx=" << to_string(uiDevIdx);
  out << ", " << "uiSubType=" << to_string(uiSubType);
  out << ", " << "uiFuncType=" << to_string(uiFuncType);
  out << ", " << "bOnBoard=" << to_string(bOnBoard);
  out << ")";
}


CSlotInfo_t::~CSlotInfo_t() noexcept {
}


void CSlotInfo_t::__set_uiCardType(const int32_t val) {
  this->uiCardType = val;
}

void CSlotInfo_t::__set_uiSlotState(const int32_t val) {
  this->uiSlotState = val;
}

void CSlotInfo_t::__set_uiPlugFlag(const int32_t val) {
  this->uiPlugFlag = val;
}

void CSlotInfo_t::__set_uiResetType(const int32_t val) {
  this->uiResetType = val;
}

void CSlotInfo_t::__set_uiDevNum(const int32_t val) {
  this->uiDevNum = val;
}

void CSlotInfo_t::__set_astDevInfo(const std::vector<CSlotDevInfo_t> & val) {
  this->astDevInfo = val;
}
std::ostream& operator<<(std::ostream& out, const CSlotInfo_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CSlotInfo_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiCardType);
          this->__isset.uiCardType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotState);
          this->__isset.uiSlotState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPlugFlag);
          this->__isset.uiPlugFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiResetType);
          this->__isset.uiResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevNum);
          this->__isset.uiDevNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astDevInfo.clear();
            uint32_t _size680;
            ::apache::thrift::protocol::TType _etype683;
            xfer += iprot->readListBegin(_etype683, _size680);
            this->astDevInfo.resize(_size680);
            uint32_t _i684;
            for (_i684 = 0; _i684 < _size680; ++_i684)
            {
              xfer += this->astDevInfo[_i684].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astDevInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSlotInfo_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSlotInfo_t");

  xfer += oprot->writeFieldBegin("uiCardType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiCardType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSlotState", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiSlotState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPlugFlag", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPlugFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiResetType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiDevNum", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiDevNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astDevInfo", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astDevInfo.size()));
    std::vector<CSlotDevInfo_t> ::const_iterator _iter685;
    for (_iter685 = this->astDevInfo.begin(); _iter685 != this->astDevInfo.end(); ++_iter685)
    {
      xfer += (*_iter685).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSlotInfo_t &a, CSlotInfo_t &b) {
  using ::std::swap;
  swap(a.uiCardType, b.uiCardType);
  swap(a.uiSlotState, b.uiSlotState);
  swap(a.uiPlugFlag, b.uiPlugFlag);
  swap(a.uiResetType, b.uiResetType);
  swap(a.uiDevNum, b.uiDevNum);
  swap(a.astDevInfo, b.astDevInfo);
  swap(a.__isset, b.__isset);
}

CSlotInfo_t::CSlotInfo_t(const CSlotInfo_t& other686) {
  uiCardType = other686.uiCardType;
  uiSlotState = other686.uiSlotState;
  uiPlugFlag = other686.uiPlugFlag;
  uiResetType = other686.uiResetType;
  uiDevNum = other686.uiDevNum;
  astDevInfo = other686.astDevInfo;
  __isset = other686.__isset;
}
CSlotInfo_t& CSlotInfo_t::operator=(const CSlotInfo_t& other687) {
  uiCardType = other687.uiCardType;
  uiSlotState = other687.uiSlotState;
  uiPlugFlag = other687.uiPlugFlag;
  uiResetType = other687.uiResetType;
  uiDevNum = other687.uiDevNum;
  astDevInfo = other687.astDevInfo;
  __isset = other687.__isset;
  return *this;
}
void CSlotInfo_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSlotInfo_t(";
  out << "uiCardType=" << to_string(uiCardType);
  out << ", " << "uiSlotState=" << to_string(uiSlotState);
  out << ", " << "uiPlugFlag=" << to_string(uiPlugFlag);
  out << ", " << "uiResetType=" << to_string(uiResetType);
  out << ", " << "uiDevNum=" << to_string(uiDevNum);
  out << ", " << "astDevInfo=" << to_string(astDevInfo);
  out << ")";
}


CSlotStatusData_t::~CSlotStatusData_t() noexcept {
}


void CSlotStatusData_t::__set_iTemp(const int32_t val) {
  this->iTemp = val;
}

void CSlotStatusData_t::__set_astLed(const std::vector<CLedSta_t> & val) {
  this->astLed = val;
}

void CSlotStatusData_t::__set_bEEpromAlarm(const bool val) {
  this->bEEpromAlarm = val;
}
std::ostream& operator<<(std::ostream& out, const CSlotStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CSlotStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iTemp);
          this->__isset.iTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astLed.clear();
            uint32_t _size688;
            ::apache::thrift::protocol::TType _etype691;
            xfer += iprot->readListBegin(_etype691, _size688);
            this->astLed.resize(_size688);
            uint32_t _i692;
            for (_i692 = 0; _i692 < _size688; ++_i692)
            {
              xfer += this->astLed[_i692].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astLed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEEpromAlarm);
          this->__isset.bEEpromAlarm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSlotStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSlotStatusData_t");

  xfer += oprot->writeFieldBegin("iTemp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astLed", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astLed.size()));
    std::vector<CLedSta_t> ::const_iterator _iter693;
    for (_iter693 = this->astLed.begin(); _iter693 != this->astLed.end(); ++_iter693)
    {
      xfer += (*_iter693).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEEpromAlarm", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->bEEpromAlarm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSlotStatusData_t &a, CSlotStatusData_t &b) {
  using ::std::swap;
  swap(a.iTemp, b.iTemp);
  swap(a.astLed, b.astLed);
  swap(a.bEEpromAlarm, b.bEEpromAlarm);
  swap(a.__isset, b.__isset);
}

CSlotStatusData_t::CSlotStatusData_t(const CSlotStatusData_t& other694) {
  iTemp = other694.iTemp;
  astLed = other694.astLed;
  bEEpromAlarm = other694.bEEpromAlarm;
  __isset = other694.__isset;
}
CSlotStatusData_t& CSlotStatusData_t::operator=(const CSlotStatusData_t& other695) {
  iTemp = other695.iTemp;
  astLed = other695.astLed;
  bEEpromAlarm = other695.bEEpromAlarm;
  __isset = other695.__isset;
  return *this;
}
void CSlotStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSlotStatusData_t(";
  out << "iTemp=" << to_string(iTemp);
  out << ", " << "astLed=" << to_string(astLed);
  out << ", " << "bEEpromAlarm=" << to_string(bEEpromAlarm);
  out << ")";
}


CFanCfg_t::~CFanCfg_t() noexcept {
}


void CFanCfg_t::__set_uiDuty(const int32_t val) {
  this->uiDuty = val;
}
std::ostream& operator<<(std::ostream& out, const CFanCfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CFanCfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDuty);
          this->__isset.uiDuty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CFanCfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CFanCfg_t");

  xfer += oprot->writeFieldBegin("uiDuty", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDuty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CFanCfg_t &a, CFanCfg_t &b) {
  using ::std::swap;
  swap(a.uiDuty, b.uiDuty);
  swap(a.__isset, b.__isset);
}

CFanCfg_t::CFanCfg_t(const CFanCfg_t& other696) {
  uiDuty = other696.uiDuty;
  __isset = other696.__isset;
}
CFanCfg_t& CFanCfg_t::operator=(const CFanCfg_t& other697) {
  uiDuty = other697.uiDuty;
  __isset = other697.__isset;
  return *this;
}
void CFanCfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CFanCfg_t(";
  out << "uiDuty=" << to_string(uiDuty);
  out << ")";
}


CFanSta_t::~CFanSta_t() noexcept {
}


void CFanSta_t::__set_bIsOnline(const bool val) {
  this->bIsOnline = val;
}

void CFanSta_t::__set_bIsFailure(const bool val) {
  this->bIsFailure = val;
}

void CFanSta_t::__set_uiSpeed(const int32_t val) {
  this->uiSpeed = val;
}

void CFanSta_t::__set_uiLedState(const int32_t val) {
  this->uiLedState = val;
}
std::ostream& operator<<(std::ostream& out, const CFanSta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CFanSta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsOnline);
          this->__isset.bIsOnline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsFailure);
          this->__isset.bIsFailure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSpeed);
          this->__isset.uiSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLedState);
          this->__isset.uiLedState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CFanSta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CFanSta_t");

  xfer += oprot->writeFieldBegin("bIsOnline", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bIsOnline);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bIsFailure", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bIsFailure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSpeed", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedState", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiLedState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CFanSta_t &a, CFanSta_t &b) {
  using ::std::swap;
  swap(a.bIsOnline, b.bIsOnline);
  swap(a.bIsFailure, b.bIsFailure);
  swap(a.uiSpeed, b.uiSpeed);
  swap(a.uiLedState, b.uiLedState);
  swap(a.__isset, b.__isset);
}

CFanSta_t::CFanSta_t(const CFanSta_t& other698) {
  bIsOnline = other698.bIsOnline;
  bIsFailure = other698.bIsFailure;
  uiSpeed = other698.uiSpeed;
  uiLedState = other698.uiLedState;
  __isset = other698.__isset;
}
CFanSta_t& CFanSta_t::operator=(const CFanSta_t& other699) {
  bIsOnline = other699.bIsOnline;
  bIsFailure = other699.bIsFailure;
  uiSpeed = other699.uiSpeed;
  uiLedState = other699.uiLedState;
  __isset = other699.__isset;
  return *this;
}
void CFanSta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CFanSta_t(";
  out << "bIsOnline=" << to_string(bIsOnline);
  out << ", " << "bIsFailure=" << to_string(bIsFailure);
  out << ", " << "uiSpeed=" << to_string(uiSpeed);
  out << ", " << "uiLedState=" << to_string(uiLedState);
  out << ")";
}


CPowerCfg_t::~CPowerCfg_t() noexcept {
}

std::ostream& operator<<(std::ostream& out, const CPowerCfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPowerCfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPowerCfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPowerCfg_t");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPowerCfg_t &a, CPowerCfg_t &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CPowerCfg_t::CPowerCfg_t(const CPowerCfg_t& other700) {
  (void) other700;
}
CPowerCfg_t& CPowerCfg_t::operator=(const CPowerCfg_t& other701) {
  (void) other701;
  return *this;
}
void CPowerCfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPowerCfg_t(";
  out << ")";
}


CPowerSta_t::~CPowerSta_t() noexcept {
}


void CPowerSta_t::__set_bIsOnline(const bool val) {
  this->bIsOnline = val;
}

void CPowerSta_t::__set_bIsFailure(const bool val) {
  this->bIsFailure = val;
}

void CPowerSta_t::__set_usInVol(const int16_t val) {
  this->usInVol = val;
}

void CPowerSta_t::__set_usOutVol(const int16_t val) {
  this->usOutVol = val;
}

void CPowerSta_t::__set_uiInCurrent(const int32_t val) {
  this->uiInCurrent = val;
}

void CPowerSta_t::__set_uiOutCurrent(const int32_t val) {
  this->uiOutCurrent = val;
}

void CPowerSta_t::__set_uiWatts(const int32_t val) {
  this->uiWatts = val;
}

void CPowerSta_t::__set_iTemp(const int32_t val) {
  this->iTemp = val;
}
std::ostream& operator<<(std::ostream& out, const CPowerSta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPowerSta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsOnline);
          this->__isset.bIsOnline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsFailure);
          this->__isset.bIsFailure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usInVol);
          this->__isset.usInVol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usOutVol);
          this->__isset.usOutVol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiInCurrent);
          this->__isset.uiInCurrent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiOutCurrent);
          this->__isset.uiOutCurrent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiWatts);
          this->__isset.uiWatts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iTemp);
          this->__isset.iTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPowerSta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPowerSta_t");

  xfer += oprot->writeFieldBegin("bIsOnline", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bIsOnline);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bIsFailure", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bIsFailure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usInVol", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->usInVol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usOutVol", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->usOutVol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiInCurrent", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiInCurrent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiOutCurrent", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->uiOutCurrent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiWatts", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->uiWatts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iTemp", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iTemp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPowerSta_t &a, CPowerSta_t &b) {
  using ::std::swap;
  swap(a.bIsOnline, b.bIsOnline);
  swap(a.bIsFailure, b.bIsFailure);
  swap(a.usInVol, b.usInVol);
  swap(a.usOutVol, b.usOutVol);
  swap(a.uiInCurrent, b.uiInCurrent);
  swap(a.uiOutCurrent, b.uiOutCurrent);
  swap(a.uiWatts, b.uiWatts);
  swap(a.iTemp, b.iTemp);
  swap(a.__isset, b.__isset);
}

CPowerSta_t::CPowerSta_t(const CPowerSta_t& other702) {
  bIsOnline = other702.bIsOnline;
  bIsFailure = other702.bIsFailure;
  usInVol = other702.usInVol;
  usOutVol = other702.usOutVol;
  uiInCurrent = other702.uiInCurrent;
  uiOutCurrent = other702.uiOutCurrent;
  uiWatts = other702.uiWatts;
  iTemp = other702.iTemp;
  __isset = other702.__isset;
}
CPowerSta_t& CPowerSta_t::operator=(const CPowerSta_t& other703) {
  bIsOnline = other703.bIsOnline;
  bIsFailure = other703.bIsFailure;
  usInVol = other703.usInVol;
  usOutVol = other703.usOutVol;
  uiInCurrent = other703.uiInCurrent;
  uiOutCurrent = other703.uiOutCurrent;
  uiWatts = other703.uiWatts;
  iTemp = other703.iTemp;
  __isset = other703.__isset;
  return *this;
}
void CPowerSta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPowerSta_t(";
  out << "bIsOnline=" << to_string(bIsOnline);
  out << ", " << "bIsFailure=" << to_string(bIsFailure);
  out << ", " << "usInVol=" << to_string(usInVol);
  out << ", " << "usOutVol=" << to_string(usOutVol);
  out << ", " << "uiInCurrent=" << to_string(uiInCurrent);
  out << ", " << "uiOutCurrent=" << to_string(uiOutCurrent);
  out << ", " << "uiWatts=" << to_string(uiWatts);
  out << ", " << "iTemp=" << to_string(iTemp);
  out << ")";
}


CBoardMfg_t::~CBoardMfg_t() noexcept {
}


void CBoardMfg_t::__set_stChassis(const CMfg_t& val) {
  this->stChassis = val;
}

void CBoardMfg_t::__set_bChassisMfgOk(const bool val) {
  this->bChassisMfgOk = val;
}

void CBoardMfg_t::__set_stScc(const CMfg_t& val) {
  this->stScc = val;
}

void CBoardMfg_t::__set_bSccMfgOk(const bool val) {
  this->bSccMfgOk = val;
}

void CBoardMfg_t::__set_astFan(const std::vector<CMfg_t> & val) {
  this->astFan = val;
}

void CBoardMfg_t::__set_abFanMfgOk(const std::vector<bool> & val) {
  this->abFanMfgOk = val;
}

void CBoardMfg_t::__set_astPower(const std::vector<CMfg_t> & val) {
  this->astPower = val;
}

void CBoardMfg_t::__set_abPowerMfgOk(const std::vector<bool> & val) {
  this->abPowerMfgOk = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardMfg_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardMfg_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stChassis.read(iprot);
          this->__isset.stChassis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bChassisMfgOk);
          this->__isset.bChassisMfgOk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stScc.read(iprot);
          this->__isset.stScc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bSccMfgOk);
          this->__isset.bSccMfgOk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astFan.clear();
            uint32_t _size704;
            ::apache::thrift::protocol::TType _etype707;
            xfer += iprot->readListBegin(_etype707, _size704);
            this->astFan.resize(_size704);
            uint32_t _i708;
            for (_i708 = 0; _i708 < _size704; ++_i708)
            {
              xfer += this->astFan[_i708].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astFan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abFanMfgOk.clear();
            uint32_t _size709;
            ::apache::thrift::protocol::TType _etype712;
            xfer += iprot->readListBegin(_etype712, _size709);
            this->abFanMfgOk.resize(_size709);
            uint32_t _i713;
            for (_i713 = 0; _i713 < _size709; ++_i713)
            {
              xfer += iprot->readBool(this->abFanMfgOk[_i713]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abFanMfgOk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astPower.clear();
            uint32_t _size714;
            ::apache::thrift::protocol::TType _etype717;
            xfer += iprot->readListBegin(_etype717, _size714);
            this->astPower.resize(_size714);
            uint32_t _i718;
            for (_i718 = 0; _i718 < _size714; ++_i718)
            {
              xfer += this->astPower[_i718].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abPowerMfgOk.clear();
            uint32_t _size719;
            ::apache::thrift::protocol::TType _etype722;
            xfer += iprot->readListBegin(_etype722, _size719);
            this->abPowerMfgOk.resize(_size719);
            uint32_t _i723;
            for (_i723 = 0; _i723 < _size719; ++_i723)
            {
              xfer += iprot->readBool(this->abPowerMfgOk[_i723]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abPowerMfgOk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardMfg_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardMfg_t");

  xfer += oprot->writeFieldBegin("stChassis", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stChassis.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bChassisMfgOk", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bChassisMfgOk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stScc", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->stScc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bSccMfgOk", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bSccMfgOk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astFan", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astFan.size()));
    std::vector<CMfg_t> ::const_iterator _iter724;
    for (_iter724 = this->astFan.begin(); _iter724 != this->astFan.end(); ++_iter724)
    {
      xfer += (*_iter724).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abFanMfgOk", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abFanMfgOk.size()));
    std::vector<bool> ::const_iterator _iter725;
    for (_iter725 = this->abFanMfgOk.begin(); _iter725 != this->abFanMfgOk.end(); ++_iter725)
    {
      xfer += oprot->writeBool((*_iter725));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astPower", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astPower.size()));
    std::vector<CMfg_t> ::const_iterator _iter726;
    for (_iter726 = this->astPower.begin(); _iter726 != this->astPower.end(); ++_iter726)
    {
      xfer += (*_iter726).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abPowerMfgOk", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abPowerMfgOk.size()));
    std::vector<bool> ::const_iterator _iter727;
    for (_iter727 = this->abPowerMfgOk.begin(); _iter727 != this->abPowerMfgOk.end(); ++_iter727)
    {
      xfer += oprot->writeBool((*_iter727));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardMfg_t &a, CBoardMfg_t &b) {
  using ::std::swap;
  swap(a.stChassis, b.stChassis);
  swap(a.bChassisMfgOk, b.bChassisMfgOk);
  swap(a.stScc, b.stScc);
  swap(a.bSccMfgOk, b.bSccMfgOk);
  swap(a.astFan, b.astFan);
  swap(a.abFanMfgOk, b.abFanMfgOk);
  swap(a.astPower, b.astPower);
  swap(a.abPowerMfgOk, b.abPowerMfgOk);
  swap(a.__isset, b.__isset);
}

CBoardMfg_t::CBoardMfg_t(const CBoardMfg_t& other728) {
  stChassis = other728.stChassis;
  bChassisMfgOk = other728.bChassisMfgOk;
  stScc = other728.stScc;
  bSccMfgOk = other728.bSccMfgOk;
  astFan = other728.astFan;
  abFanMfgOk = other728.abFanMfgOk;
  astPower = other728.astPower;
  abPowerMfgOk = other728.abPowerMfgOk;
  __isset = other728.__isset;
}
CBoardMfg_t& CBoardMfg_t::operator=(const CBoardMfg_t& other729) {
  stChassis = other729.stChassis;
  bChassisMfgOk = other729.bChassisMfgOk;
  stScc = other729.stScc;
  bSccMfgOk = other729.bSccMfgOk;
  astFan = other729.astFan;
  abFanMfgOk = other729.abFanMfgOk;
  astPower = other729.astPower;
  abPowerMfgOk = other729.abPowerMfgOk;
  __isset = other729.__isset;
  return *this;
}
void CBoardMfg_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardMfg_t(";
  out << "stChassis=" << to_string(stChassis);
  out << ", " << "bChassisMfgOk=" << to_string(bChassisMfgOk);
  out << ", " << "stScc=" << to_string(stScc);
  out << ", " << "bSccMfgOk=" << to_string(bSccMfgOk);
  out << ", " << "astFan=" << to_string(astFan);
  out << ", " << "abFanMfgOk=" << to_string(abFanMfgOk);
  out << ", " << "astPower=" << to_string(astPower);
  out << ", " << "abPowerMfgOk=" << to_string(abPowerMfgOk);
  out << ")";
}


CBoardCfgData_t::~CBoardCfgData_t() noexcept {
}


void CBoardCfgData_t::__set_astLed(const std::vector<CLedCfg_t> & val) {
  this->astLed = val;
}

void CBoardCfgData_t::__set_astFan(const std::vector<CFanCfg_t> & val) {
  this->astFan = val;
}

void CBoardCfgData_t::__set_astPower(const std::vector<CPowerCfg_t> & val) {
  this->astPower = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astLed.clear();
            uint32_t _size730;
            ::apache::thrift::protocol::TType _etype733;
            xfer += iprot->readListBegin(_etype733, _size730);
            this->astLed.resize(_size730);
            uint32_t _i734;
            for (_i734 = 0; _i734 < _size730; ++_i734)
            {
              xfer += this->astLed[_i734].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astLed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astFan.clear();
            uint32_t _size735;
            ::apache::thrift::protocol::TType _etype738;
            xfer += iprot->readListBegin(_etype738, _size735);
            this->astFan.resize(_size735);
            uint32_t _i739;
            for (_i739 = 0; _i739 < _size735; ++_i739)
            {
              xfer += this->astFan[_i739].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astFan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astPower.clear();
            uint32_t _size740;
            ::apache::thrift::protocol::TType _etype743;
            xfer += iprot->readListBegin(_etype743, _size740);
            this->astPower.resize(_size740);
            uint32_t _i744;
            for (_i744 = 0; _i744 < _size740; ++_i744)
            {
              xfer += this->astPower[_i744].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardCfgData_t");

  xfer += oprot->writeFieldBegin("astLed", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astLed.size()));
    std::vector<CLedCfg_t> ::const_iterator _iter745;
    for (_iter745 = this->astLed.begin(); _iter745 != this->astLed.end(); ++_iter745)
    {
      xfer += (*_iter745).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astFan", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astFan.size()));
    std::vector<CFanCfg_t> ::const_iterator _iter746;
    for (_iter746 = this->astFan.begin(); _iter746 != this->astFan.end(); ++_iter746)
    {
      xfer += (*_iter746).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astPower", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astPower.size()));
    std::vector<CPowerCfg_t> ::const_iterator _iter747;
    for (_iter747 = this->astPower.begin(); _iter747 != this->astPower.end(); ++_iter747)
    {
      xfer += (*_iter747).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardCfgData_t &a, CBoardCfgData_t &b) {
  using ::std::swap;
  swap(a.astLed, b.astLed);
  swap(a.astFan, b.astFan);
  swap(a.astPower, b.astPower);
  swap(a.__isset, b.__isset);
}

CBoardCfgData_t::CBoardCfgData_t(const CBoardCfgData_t& other748) {
  astLed = other748.astLed;
  astFan = other748.astFan;
  astPower = other748.astPower;
  __isset = other748.__isset;
}
CBoardCfgData_t& CBoardCfgData_t::operator=(const CBoardCfgData_t& other749) {
  astLed = other749.astLed;
  astFan = other749.astFan;
  astPower = other749.astPower;
  __isset = other749.__isset;
  return *this;
}
void CBoardCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardCfgData_t(";
  out << "astLed=" << to_string(astLed);
  out << ", " << "astFan=" << to_string(astFan);
  out << ", " << "astPower=" << to_string(astPower);
  out << ")";
}


CBoardCali_t::~CBoardCali_t() noexcept {
}


void CBoardCali_t::__set_stChassis(const CCali_t& val) {
  this->stChassis = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardCali_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardCali_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stChassis.read(iprot);
          this->__isset.stChassis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardCali_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardCali_t");

  xfer += oprot->writeFieldBegin("stChassis", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stChassis.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardCali_t &a, CBoardCali_t &b) {
  using ::std::swap;
  swap(a.stChassis, b.stChassis);
  swap(a.__isset, b.__isset);
}

CBoardCali_t::CBoardCali_t(const CBoardCali_t& other750) {
  stChassis = other750.stChassis;
  __isset = other750.__isset;
}
CBoardCali_t& CBoardCali_t::operator=(const CBoardCali_t& other751) {
  stChassis = other751.stChassis;
  __isset = other751.__isset;
  return *this;
}
void CBoardCali_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardCali_t(";
  out << "stChassis=" << to_string(stChassis);
  out << ")";
}


CLtc4215Sta_t::~CLtc4215Sta_t() noexcept {
}


void CLtc4215Sta_t::__set_iSense(const int32_t val) {
  this->iSense = val;
}

void CLtc4215Sta_t::__set_iSource(const int32_t val) {
  this->iSource = val;
}
std::ostream& operator<<(std::ostream& out, const CLtc4215Sta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CLtc4215Sta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSense);
          this->__isset.iSense = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSource);
          this->__isset.iSource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLtc4215Sta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLtc4215Sta_t");

  xfer += oprot->writeFieldBegin("iSense", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSense);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSource", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iSource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLtc4215Sta_t &a, CLtc4215Sta_t &b) {
  using ::std::swap;
  swap(a.iSense, b.iSense);
  swap(a.iSource, b.iSource);
  swap(a.__isset, b.__isset);
}

CLtc4215Sta_t::CLtc4215Sta_t(const CLtc4215Sta_t& other752) {
  iSense = other752.iSense;
  iSource = other752.iSource;
  __isset = other752.__isset;
}
CLtc4215Sta_t& CLtc4215Sta_t::operator=(const CLtc4215Sta_t& other753) {
  iSense = other753.iSense;
  iSource = other753.iSource;
  __isset = other753.__isset;
  return *this;
}
void CLtc4215Sta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLtc4215Sta_t(";
  out << "iSense=" << to_string(iSense);
  out << ", " << "iSource=" << to_string(iSource);
  out << ")";
}


CMax1139Sta_t::~CMax1139Sta_t() noexcept {
}


void CMax1139Sta_t::__set_adVoltage(const std::vector<double> & val) {
  this->adVoltage = val;
}
std::ostream& operator<<(std::ostream& out, const CMax1139Sta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMax1139Sta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->adVoltage.clear();
            uint32_t _size754;
            ::apache::thrift::protocol::TType _etype757;
            xfer += iprot->readListBegin(_etype757, _size754);
            this->adVoltage.resize(_size754);
            uint32_t _i758;
            for (_i758 = 0; _i758 < _size754; ++_i758)
            {
              xfer += iprot->readDouble(this->adVoltage[_i758]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.adVoltage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMax1139Sta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMax1139Sta_t");

  xfer += oprot->writeFieldBegin("adVoltage", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->adVoltage.size()));
    std::vector<double> ::const_iterator _iter759;
    for (_iter759 = this->adVoltage.begin(); _iter759 != this->adVoltage.end(); ++_iter759)
    {
      xfer += oprot->writeDouble((*_iter759));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMax1139Sta_t &a, CMax1139Sta_t &b) {
  using ::std::swap;
  swap(a.adVoltage, b.adVoltage);
  swap(a.__isset, b.__isset);
}

CMax1139Sta_t::CMax1139Sta_t(const CMax1139Sta_t& other760) {
  adVoltage = other760.adVoltage;
  __isset = other760.__isset;
}
CMax1139Sta_t& CMax1139Sta_t::operator=(const CMax1139Sta_t& other761) {
  adVoltage = other761.adVoltage;
  __isset = other761.__isset;
  return *this;
}
void CMax1139Sta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMax1139Sta_t(";
  out << "adVoltage=" << to_string(adVoltage);
  out << ")";
}


CMp5023Sta_t::~CMp5023Sta_t() noexcept {
}


void CMp5023Sta_t::__set_dVIn(const double val) {
  this->dVIn = val;
}

void CMp5023Sta_t::__set_dVOut(const double val) {
  this->dVOut = val;
}

void CMp5023Sta_t::__set_dIOut(const double val) {
  this->dIOut = val;
}
std::ostream& operator<<(std::ostream& out, const CMp5023Sta_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMp5023Sta_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dVIn);
          this->__isset.dVIn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dVOut);
          this->__isset.dVOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dIOut);
          this->__isset.dIOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMp5023Sta_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMp5023Sta_t");

  xfer += oprot->writeFieldBegin("dVIn", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->dVIn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dVOut", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->dVOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dIOut", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dIOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMp5023Sta_t &a, CMp5023Sta_t &b) {
  using ::std::swap;
  swap(a.dVIn, b.dVIn);
  swap(a.dVOut, b.dVOut);
  swap(a.dIOut, b.dIOut);
  swap(a.__isset, b.__isset);
}

CMp5023Sta_t::CMp5023Sta_t(const CMp5023Sta_t& other762) {
  dVIn = other762.dVIn;
  dVOut = other762.dVOut;
  dIOut = other762.dIOut;
  __isset = other762.__isset;
}
CMp5023Sta_t& CMp5023Sta_t::operator=(const CMp5023Sta_t& other763) {
  dVIn = other763.dVIn;
  dVOut = other763.dVOut;
  dIOut = other763.dIOut;
  __isset = other763.__isset;
  return *this;
}
void CMp5023Sta_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMp5023Sta_t(";
  out << "dVIn=" << to_string(dVIn);
  out << ", " << "dVOut=" << to_string(dVOut);
  out << ", " << "dIOut=" << to_string(dIOut);
  out << ")";
}


CBoardStatusData_t::~CBoardStatusData_t() noexcept {
}


void CBoardStatusData_t::__set_astFan(const std::vector<CFanSta_t> & val) {
  this->astFan = val;
}

void CBoardStatusData_t::__set_astPower(const std::vector<CPowerSta_t> & val) {
  this->astPower = val;
}

void CBoardStatusData_t::__set_astLed(const std::vector<CLedSta_t> & val) {
  this->astLed = val;
}

void CBoardStatusData_t::__set_abApsdStatus(const std::vector<bool> & val) {
  this->abApsdStatus = val;
}

void CBoardStatusData_t::__set_abApsdEvent(const std::vector<bool> & val) {
  this->abApsdEvent = val;
}

void CBoardStatusData_t::__set_abApsdEnable(const std::vector<bool> & val) {
  this->abApsdEnable = val;
}

void CBoardStatusData_t::__set_aucResetType(const std::string& val) {
  this->aucResetType = val;
}

void CBoardStatusData_t::__set_aiTemp(const std::vector<int32_t> & val) {
  this->aiTemp = val;
}

void CBoardStatusData_t::__set_aiPortPower(const std::vector<int32_t> & val) {
  this->aiPortPower = val;
}

void CBoardStatusData_t::__set_astLtc4215(const std::vector<CLtc4215Sta_t> & val) {
  this->astLtc4215 = val;
}

void CBoardStatusData_t::__set_astMp5023(const std::vector<CMp5023Sta_t> & val) {
  this->astMp5023 = val;
}

void CBoardStatusData_t::__set_astMax1139(const std::vector<CMax1139Sta_t> & val) {
  this->astMax1139 = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astFan.clear();
            uint32_t _size764;
            ::apache::thrift::protocol::TType _etype767;
            xfer += iprot->readListBegin(_etype767, _size764);
            this->astFan.resize(_size764);
            uint32_t _i768;
            for (_i768 = 0; _i768 < _size764; ++_i768)
            {
              xfer += this->astFan[_i768].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astFan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astPower.clear();
            uint32_t _size769;
            ::apache::thrift::protocol::TType _etype772;
            xfer += iprot->readListBegin(_etype772, _size769);
            this->astPower.resize(_size769);
            uint32_t _i773;
            for (_i773 = 0; _i773 < _size769; ++_i773)
            {
              xfer += this->astPower[_i773].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astLed.clear();
            uint32_t _size774;
            ::apache::thrift::protocol::TType _etype777;
            xfer += iprot->readListBegin(_etype777, _size774);
            this->astLed.resize(_size774);
            uint32_t _i778;
            for (_i778 = 0; _i778 < _size774; ++_i778)
            {
              xfer += this->astLed[_i778].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astLed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abApsdStatus.clear();
            uint32_t _size779;
            ::apache::thrift::protocol::TType _etype782;
            xfer += iprot->readListBegin(_etype782, _size779);
            this->abApsdStatus.resize(_size779);
            uint32_t _i783;
            for (_i783 = 0; _i783 < _size779; ++_i783)
            {
              xfer += iprot->readBool(this->abApsdStatus[_i783]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abApsdStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abApsdEvent.clear();
            uint32_t _size784;
            ::apache::thrift::protocol::TType _etype787;
            xfer += iprot->readListBegin(_etype787, _size784);
            this->abApsdEvent.resize(_size784);
            uint32_t _i788;
            for (_i788 = 0; _i788 < _size784; ++_i788)
            {
              xfer += iprot->readBool(this->abApsdEvent[_i788]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abApsdEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->abApsdEnable.clear();
            uint32_t _size789;
            ::apache::thrift::protocol::TType _etype792;
            xfer += iprot->readListBegin(_etype792, _size789);
            this->abApsdEnable.resize(_size789);
            uint32_t _i793;
            for (_i793 = 0; _i793 < _size789; ++_i793)
            {
              xfer += iprot->readBool(this->abApsdEnable[_i793]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.abApsdEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucResetType);
          this->__isset.aucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aiTemp.clear();
            uint32_t _size794;
            ::apache::thrift::protocol::TType _etype797;
            xfer += iprot->readListBegin(_etype797, _size794);
            this->aiTemp.resize(_size794);
            uint32_t _i798;
            for (_i798 = 0; _i798 < _size794; ++_i798)
            {
              xfer += iprot->readI32(this->aiTemp[_i798]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aiTemp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aiPortPower.clear();
            uint32_t _size799;
            ::apache::thrift::protocol::TType _etype802;
            xfer += iprot->readListBegin(_etype802, _size799);
            this->aiPortPower.resize(_size799);
            uint32_t _i803;
            for (_i803 = 0; _i803 < _size799; ++_i803)
            {
              xfer += iprot->readI32(this->aiPortPower[_i803]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aiPortPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astLtc4215.clear();
            uint32_t _size804;
            ::apache::thrift::protocol::TType _etype807;
            xfer += iprot->readListBegin(_etype807, _size804);
            this->astLtc4215.resize(_size804);
            uint32_t _i808;
            for (_i808 = 0; _i808 < _size804; ++_i808)
            {
              xfer += this->astLtc4215[_i808].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astLtc4215 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astMp5023.clear();
            uint32_t _size809;
            ::apache::thrift::protocol::TType _etype812;
            xfer += iprot->readListBegin(_etype812, _size809);
            this->astMp5023.resize(_size809);
            uint32_t _i813;
            for (_i813 = 0; _i813 < _size809; ++_i813)
            {
              xfer += this->astMp5023[_i813].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astMp5023 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->astMax1139.clear();
            uint32_t _size814;
            ::apache::thrift::protocol::TType _etype817;
            xfer += iprot->readListBegin(_etype817, _size814);
            this->astMax1139.resize(_size814);
            uint32_t _i818;
            for (_i818 = 0; _i818 < _size814; ++_i818)
            {
              xfer += this->astMax1139[_i818].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.astMax1139 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardStatusData_t");

  xfer += oprot->writeFieldBegin("astFan", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astFan.size()));
    std::vector<CFanSta_t> ::const_iterator _iter819;
    for (_iter819 = this->astFan.begin(); _iter819 != this->astFan.end(); ++_iter819)
    {
      xfer += (*_iter819).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astPower", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astPower.size()));
    std::vector<CPowerSta_t> ::const_iterator _iter820;
    for (_iter820 = this->astPower.begin(); _iter820 != this->astPower.end(); ++_iter820)
    {
      xfer += (*_iter820).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astLed", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astLed.size()));
    std::vector<CLedSta_t> ::const_iterator _iter821;
    for (_iter821 = this->astLed.begin(); _iter821 != this->astLed.end(); ++_iter821)
    {
      xfer += (*_iter821).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abApsdStatus", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abApsdStatus.size()));
    std::vector<bool> ::const_iterator _iter822;
    for (_iter822 = this->abApsdStatus.begin(); _iter822 != this->abApsdStatus.end(); ++_iter822)
    {
      xfer += oprot->writeBool((*_iter822));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abApsdEvent", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abApsdEvent.size()));
    std::vector<bool> ::const_iterator _iter823;
    for (_iter823 = this->abApsdEvent.begin(); _iter823 != this->abApsdEvent.end(); ++_iter823)
    {
      xfer += oprot->writeBool((*_iter823));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("abApsdEnable", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->abApsdEnable.size()));
    std::vector<bool> ::const_iterator _iter824;
    for (_iter824 = this->abApsdEnable.begin(); _iter824 != this->abApsdEnable.end(); ++_iter824)
    {
      xfer += oprot->writeBool((*_iter824));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucResetType", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeBinary(this->aucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aiTemp", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->aiTemp.size()));
    std::vector<int32_t> ::const_iterator _iter825;
    for (_iter825 = this->aiTemp.begin(); _iter825 != this->aiTemp.end(); ++_iter825)
    {
      xfer += oprot->writeI32((*_iter825));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aiPortPower", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->aiPortPower.size()));
    std::vector<int32_t> ::const_iterator _iter826;
    for (_iter826 = this->aiPortPower.begin(); _iter826 != this->aiPortPower.end(); ++_iter826)
    {
      xfer += oprot->writeI32((*_iter826));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astLtc4215", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astLtc4215.size()));
    std::vector<CLtc4215Sta_t> ::const_iterator _iter827;
    for (_iter827 = this->astLtc4215.begin(); _iter827 != this->astLtc4215.end(); ++_iter827)
    {
      xfer += (*_iter827).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astMp5023", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astMp5023.size()));
    std::vector<CMp5023Sta_t> ::const_iterator _iter828;
    for (_iter828 = this->astMp5023.begin(); _iter828 != this->astMp5023.end(); ++_iter828)
    {
      xfer += (*_iter828).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("astMax1139", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->astMax1139.size()));
    std::vector<CMax1139Sta_t> ::const_iterator _iter829;
    for (_iter829 = this->astMax1139.begin(); _iter829 != this->astMax1139.end(); ++_iter829)
    {
      xfer += (*_iter829).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardStatusData_t &a, CBoardStatusData_t &b) {
  using ::std::swap;
  swap(a.astFan, b.astFan);
  swap(a.astPower, b.astPower);
  swap(a.astLed, b.astLed);
  swap(a.abApsdStatus, b.abApsdStatus);
  swap(a.abApsdEvent, b.abApsdEvent);
  swap(a.abApsdEnable, b.abApsdEnable);
  swap(a.aucResetType, b.aucResetType);
  swap(a.aiTemp, b.aiTemp);
  swap(a.aiPortPower, b.aiPortPower);
  swap(a.astLtc4215, b.astLtc4215);
  swap(a.astMp5023, b.astMp5023);
  swap(a.astMax1139, b.astMax1139);
  swap(a.__isset, b.__isset);
}

CBoardStatusData_t::CBoardStatusData_t(const CBoardStatusData_t& other830) {
  astFan = other830.astFan;
  astPower = other830.astPower;
  astLed = other830.astLed;
  abApsdStatus = other830.abApsdStatus;
  abApsdEvent = other830.abApsdEvent;
  abApsdEnable = other830.abApsdEnable;
  aucResetType = other830.aucResetType;
  aiTemp = other830.aiTemp;
  aiPortPower = other830.aiPortPower;
  astLtc4215 = other830.astLtc4215;
  astMp5023 = other830.astMp5023;
  astMax1139 = other830.astMax1139;
  __isset = other830.__isset;
}
CBoardStatusData_t& CBoardStatusData_t::operator=(const CBoardStatusData_t& other831) {
  astFan = other831.astFan;
  astPower = other831.astPower;
  astLed = other831.astLed;
  abApsdStatus = other831.abApsdStatus;
  abApsdEvent = other831.abApsdEvent;
  abApsdEnable = other831.abApsdEnable;
  aucResetType = other831.aucResetType;
  aiTemp = other831.aiTemp;
  aiPortPower = other831.aiPortPower;
  astLtc4215 = other831.astLtc4215;
  astMp5023 = other831.astMp5023;
  astMax1139 = other831.astMax1139;
  __isset = other831.__isset;
  return *this;
}
void CBoardStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardStatusData_t(";
  out << "astFan=" << to_string(astFan);
  out << ", " << "astPower=" << to_string(astPower);
  out << ", " << "astLed=" << to_string(astLed);
  out << ", " << "abApsdStatus=" << to_string(abApsdStatus);
  out << ", " << "abApsdEvent=" << to_string(abApsdEvent);
  out << ", " << "abApsdEnable=" << to_string(abApsdEnable);
  out << ", " << "aucResetType=" << to_string(aucResetType);
  out << ", " << "aiTemp=" << to_string(aiTemp);
  out << ", " << "aiPortPower=" << to_string(aiPortPower);
  out << ", " << "astLtc4215=" << to_string(astLtc4215);
  out << ", " << "astMp5023=" << to_string(astMp5023);
  out << ", " << "astMax1139=" << to_string(astMax1139);
  out << ")";
}


CBoardRealTimeData_t::~CBoardRealTimeData_t() noexcept {
}


void CBoardRealTimeData_t::__set_aucLogicVal(const std::string& val) {
  this->aucLogicVal = val;
}

void CBoardRealTimeData_t::__set_aucUpgInfo(const std::string& val) {
  this->aucUpgInfo = val;
}

void CBoardRealTimeData_t::__set_aucBdlHead(const std::string& val) {
  this->aucBdlHead = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardRealTimeData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardRealTimeData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucLogicVal);
          this->__isset.aucLogicVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucUpgInfo);
          this->__isset.aucUpgInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->aucBdlHead);
          this->__isset.aucBdlHead = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardRealTimeData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardRealTimeData_t");

  xfer += oprot->writeFieldBegin("aucLogicVal", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->aucLogicVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucUpgInfo", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->aucUpgInfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aucBdlHead", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->aucBdlHead);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardRealTimeData_t &a, CBoardRealTimeData_t &b) {
  using ::std::swap;
  swap(a.aucLogicVal, b.aucLogicVal);
  swap(a.aucUpgInfo, b.aucUpgInfo);
  swap(a.aucBdlHead, b.aucBdlHead);
  swap(a.__isset, b.__isset);
}

CBoardRealTimeData_t::CBoardRealTimeData_t(const CBoardRealTimeData_t& other832) {
  aucLogicVal = other832.aucLogicVal;
  aucUpgInfo = other832.aucUpgInfo;
  aucBdlHead = other832.aucBdlHead;
  __isset = other832.__isset;
}
CBoardRealTimeData_t& CBoardRealTimeData_t::operator=(const CBoardRealTimeData_t& other833) {
  aucLogicVal = other833.aucLogicVal;
  aucUpgInfo = other833.aucUpgInfo;
  aucBdlHead = other833.aucBdlHead;
  __isset = other833.__isset;
  return *this;
}
void CBoardRealTimeData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardRealTimeData_t(";
  out << "aucLogicVal=" << to_string(aucLogicVal);
  out << ", " << "aucUpgInfo=" << to_string(aucUpgInfo);
  out << ", " << "aucBdlHead=" << to_string(aucBdlHead);
  out << ")";
}


CTdcmStatusData_t::~CTdcmStatusData_t() noexcept {
}


void CTdcmStatusData_t::__set_fFrequency(const double val) {
  this->fFrequency = val;
}

void CTdcmStatusData_t::__set_fDispersion(const double val) {
  this->fDispersion = val;
}
std::ostream& operator<<(std::ostream& out, const CTdcmStatusData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CTdcmStatusData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fFrequency);
          this->__isset.fFrequency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fDispersion);
          this->__isset.fDispersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTdcmStatusData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTdcmStatusData_t");

  xfer += oprot->writeFieldBegin("fFrequency", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->fFrequency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fDispersion", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->fDispersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTdcmStatusData_t &a, CTdcmStatusData_t &b) {
  using ::std::swap;
  swap(a.fFrequency, b.fFrequency);
  swap(a.fDispersion, b.fDispersion);
  swap(a.__isset, b.__isset);
}

CTdcmStatusData_t::CTdcmStatusData_t(const CTdcmStatusData_t& other834) {
  fFrequency = other834.fFrequency;
  fDispersion = other834.fDispersion;
  __isset = other834.__isset;
}
CTdcmStatusData_t& CTdcmStatusData_t::operator=(const CTdcmStatusData_t& other835) {
  fFrequency = other835.fFrequency;
  fDispersion = other835.fDispersion;
  __isset = other835.__isset;
  return *this;
}
void CTdcmStatusData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CTdcmStatusData_t(";
  out << "fFrequency=" << to_string(fFrequency);
  out << ", " << "fDispersion=" << to_string(fDispersion);
  out << ")";
}


CTdcmCfgData_t::~CTdcmCfgData_t() noexcept {
}

std::ostream& operator<<(std::ostream& out, const CTdcmCfgData_t& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CTdcmCfgData_t::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTdcmCfgData_t::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTdcmCfgData_t");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTdcmCfgData_t &a, CTdcmCfgData_t &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CTdcmCfgData_t::CTdcmCfgData_t(const CTdcmCfgData_t& other836) {
  (void) other836;
}
CTdcmCfgData_t& CTdcmCfgData_t::operator=(const CTdcmCfgData_t& other837) {
  (void) other837;
  return *this;
}
void CTdcmCfgData_t::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CTdcmCfgData_t(";
  out << ")";
}


CLedCfg_rsp::~CLedCfg_rsp() noexcept {
}


void CLedCfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CLedCfg_rsp::__set_data(const CLedCfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CLedCfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CLedCfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLedCfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLedCfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLedCfg_rsp &a, CLedCfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CLedCfg_rsp::CLedCfg_rsp(const CLedCfg_rsp& other838) {
  response = other838.response;
  data = other838.data;
  __isset = other838.__isset;
}
CLedCfg_rsp& CLedCfg_rsp::operator=(const CLedCfg_rsp& other839) {
  response = other839.response;
  data = other839.data;
  __isset = other839.__isset;
  return *this;
}
void CLedCfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLedCfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CLedSta_rsp::~CLedSta_rsp() noexcept {
}


void CLedSta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CLedSta_rsp::__set_data(const CLedSta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CLedSta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CLedSta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLedSta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLedSta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLedSta_rsp &a, CLedSta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CLedSta_rsp::CLedSta_rsp(const CLedSta_rsp& other840) {
  response = other840.response;
  data = other840.data;
  __isset = other840.__isset;
}
CLedSta_rsp& CLedSta_rsp::operator=(const CLedSta_rsp& other841) {
  response = other841.response;
  data = other841.data;
  __isset = other841.__isset;
  return *this;
}
void CLedSta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLedSta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMfg_rsp::~CMfg_rsp() noexcept {
}


void CMfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMfg_rsp::__set_data(const CMfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMfg_rsp &a, CMfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMfg_rsp::CMfg_rsp(const CMfg_rsp& other842) {
  response = other842.response;
  data = other842.data;
  __isset = other842.__isset;
}
CMfg_rsp& CMfg_rsp::operator=(const CMfg_rsp& other843) {
  response = other843.response;
  data = other843.data;
  __isset = other843.__isset;
  return *this;
}
void CMfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CCali_rsp::~CCali_rsp() noexcept {
}


void CCali_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CCali_rsp::__set_data(const CCali_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CCali_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCali_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCali_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCali_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCali_rsp &a, CCali_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CCali_rsp::CCali_rsp(const CCali_rsp& other844) {
  response = other844.response;
  data = other844.data;
  __isset = other844.__isset;
}
CCali_rsp& CCali_rsp::operator=(const CCali_rsp& other845) {
  response = other845.response;
  data = other845.data;
  __isset = other845.__isset;
  return *this;
}
void CCali_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCali_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COscCfgData_rsp::~COscCfgData_rsp() noexcept {
}


void COscCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COscCfgData_rsp::__set_data(const COscCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COscCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscCfgData_rsp &a, COscCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COscCfgData_rsp::COscCfgData_rsp(const COscCfgData_rsp& other846) {
  response = other846.response;
  data = other846.data;
  __isset = other846.__isset;
}
COscCfgData_rsp& COscCfgData_rsp::operator=(const COscCfgData_rsp& other847) {
  response = other847.response;
  data = other847.data;
  __isset = other847.__isset;
  return *this;
}
void COscCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COscStatusData_rsp::~COscStatusData_rsp() noexcept {
}


void COscStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COscStatusData_rsp::__set_data(const COscStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COscStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscStatusData_rsp &a, COscStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COscStatusData_rsp::COscStatusData_rsp(const COscStatusData_rsp& other848) {
  response = other848.response;
  data = other848.data;
  __isset = other848.__isset;
}
COscStatusData_rsp& COscStatusData_rsp::operator=(const COscStatusData_rsp& other849) {
  response = other849.response;
  data = other849.data;
  __isset = other849.__isset;
  return *this;
}
void COscStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrCfgData_rsp::~COtdrCfgData_rsp() noexcept {
}


void COtdrCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrCfgData_rsp::__set_data(const COtdrCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrCfgData_rsp &a, COtdrCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrCfgData_rsp::COtdrCfgData_rsp(const COtdrCfgData_rsp& other850) {
  response = other850.response;
  data = other850.data;
  __isset = other850.__isset;
}
COtdrCfgData_rsp& COtdrCfgData_rsp::operator=(const COtdrCfgData_rsp& other851) {
  response = other851.response;
  data = other851.data;
  __isset = other851.__isset;
  return *this;
}
void COtdrCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrEventTop_rsp::~COtdrEventTop_rsp() noexcept {
}


void COtdrEventTop_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrEventTop_rsp::__set_data(const COtdrEventTop_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrEventTop_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrEventTop_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrEventTop_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrEventTop_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrEventTop_rsp &a, COtdrEventTop_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrEventTop_rsp::COtdrEventTop_rsp(const COtdrEventTop_rsp& other852) {
  response = other852.response;
  data = other852.data;
  __isset = other852.__isset;
}
COtdrEventTop_rsp& COtdrEventTop_rsp::operator=(const COtdrEventTop_rsp& other853) {
  response = other853.response;
  data = other853.data;
  __isset = other853.__isset;
  return *this;
}
void COtdrEventTop_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrEventTop_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrEventLine_rsp::~COtdrEventLine_rsp() noexcept {
}


void COtdrEventLine_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrEventLine_rsp::__set_data(const COtdrEventLine_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrEventLine_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrEventLine_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrEventLine_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrEventLine_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrEventLine_rsp &a, COtdrEventLine_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrEventLine_rsp::COtdrEventLine_rsp(const COtdrEventLine_rsp& other854) {
  response = other854.response;
  data = other854.data;
  __isset = other854.__isset;
}
COtdrEventLine_rsp& COtdrEventLine_rsp::operator=(const COtdrEventLine_rsp& other855) {
  response = other855.response;
  data = other855.data;
  __isset = other855.__isset;
  return *this;
}
void COtdrEventLine_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrEventLine_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrTemp_rsp::~COtdrTemp_rsp() noexcept {
}


void COtdrTemp_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrTemp_rsp::__set_data(const COtdrTemp_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrTemp_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrTemp_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrTemp_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrTemp_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrTemp_rsp &a, COtdrTemp_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrTemp_rsp::COtdrTemp_rsp(const COtdrTemp_rsp& other856) {
  response = other856.response;
  data = other856.data;
  __isset = other856.__isset;
}
COtdrTemp_rsp& COtdrTemp_rsp::operator=(const COtdrTemp_rsp& other857) {
  response = other857.response;
  data = other857.data;
  __isset = other857.__isset;
  return *this;
}
void COtdrTemp_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrTemp_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrStartOffset_rsp::~COtdrStartOffset_rsp() noexcept {
}


void COtdrStartOffset_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrStartOffset_rsp::__set_data(const COtdrStartOffset_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStartOffset_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStartOffset_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStartOffset_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStartOffset_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStartOffset_rsp &a, COtdrStartOffset_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrStartOffset_rsp::COtdrStartOffset_rsp(const COtdrStartOffset_rsp& other858) {
  response = other858.response;
  data = other858.data;
  __isset = other858.__isset;
}
COtdrStartOffset_rsp& COtdrStartOffset_rsp::operator=(const COtdrStartOffset_rsp& other859) {
  response = other859.response;
  data = other859.data;
  __isset = other859.__isset;
  return *this;
}
void COtdrStartOffset_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStartOffset_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrStartOffsetPort_rsp::~COtdrStartOffsetPort_rsp() noexcept {
}


void COtdrStartOffsetPort_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrStartOffsetPort_rsp::__set_data(const COtdrStartOffsetPort_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStartOffsetPort_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStartOffsetPort_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStartOffsetPort_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStartOffsetPort_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStartOffsetPort_rsp &a, COtdrStartOffsetPort_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrStartOffsetPort_rsp::COtdrStartOffsetPort_rsp(const COtdrStartOffsetPort_rsp& other860) {
  response = other860.response;
  data = other860.data;
  __isset = other860.__isset;
}
COtdrStartOffsetPort_rsp& COtdrStartOffsetPort_rsp::operator=(const COtdrStartOffsetPort_rsp& other861) {
  response = other861.response;
  data = other861.data;
  __isset = other861.__isset;
  return *this;
}
void COtdrStartOffsetPort_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStartOffsetPort_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrStartOffsetAll_rsp::~COtdrStartOffsetAll_rsp() noexcept {
}


void COtdrStartOffsetAll_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrStartOffsetAll_rsp::__set_data(const COtdrStartOffsetAll_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStartOffsetAll_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStartOffsetAll_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStartOffsetAll_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStartOffsetAll_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStartOffsetAll_rsp &a, COtdrStartOffsetAll_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrStartOffsetAll_rsp::COtdrStartOffsetAll_rsp(const COtdrStartOffsetAll_rsp& other862) {
  response = other862.response;
  data = other862.data;
  __isset = other862.__isset;
}
COtdrStartOffsetAll_rsp& COtdrStartOffsetAll_rsp::operator=(const COtdrStartOffsetAll_rsp& other863) {
  response = other863.response;
  data = other863.data;
  __isset = other863.__isset;
  return *this;
}
void COtdrStartOffsetAll_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStartOffsetAll_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COtdrStatusData_rsp::~COtdrStatusData_rsp() noexcept {
}


void COtdrStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COtdrStatusData_rsp::__set_data(const COtdrStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COtdrStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COtdrStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COtdrStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COtdrStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COtdrStatusData_rsp &a, COtdrStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COtdrStatusData_rsp::COtdrStatusData_rsp(const COtdrStatusData_rsp& other864) {
  response = other864.response;
  data = other864.data;
  __isset = other864.__isset;
}
COtdrStatusData_rsp& COtdrStatusData_rsp::operator=(const COtdrStatusData_rsp& other865) {
  response = other865.response;
  data = other865.data;
  __isset = other865.__isset;
  return *this;
}
void COtdrStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COtdrStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWavePlan_rsp::~CWavePlan_rsp() noexcept {
}


void CWavePlan_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWavePlan_rsp::__set_data(const CWavePlan_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWavePlan_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWavePlan_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWavePlan_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWavePlan_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWavePlan_rsp &a, CWavePlan_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWavePlan_rsp::CWavePlan_rsp(const CWavePlan_rsp& other866) {
  response = other866.response;
  data = other866.data;
  __isset = other866.__isset;
}
CWavePlan_rsp& CWavePlan_rsp::operator=(const CWavePlan_rsp& other867) {
  response = other867.response;
  data = other867.data;
  __isset = other867.__isset;
  return *this;
}
void CWavePlan_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWavePlan_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssCfg_rsp::~CWssCfg_rsp() noexcept {
}


void CWssCfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssCfg_rsp::__set_data(const CWssCfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssCfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssCfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssCfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssCfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssCfg_rsp &a, CWssCfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssCfg_rsp::CWssCfg_rsp(const CWssCfg_rsp& other868) {
  response = other868.response;
  data = other868.data;
  __isset = other868.__isset;
}
CWssCfg_rsp& CWssCfg_rsp::operator=(const CWssCfg_rsp& other869) {
  response = other869.response;
  data = other869.data;
  __isset = other869.__isset;
  return *this;
}
void CWssCfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssCfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssAllCfg_rsp::~CWssAllCfg_rsp() noexcept {
}


void CWssAllCfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssAllCfg_rsp::__set_data(const CWssAllCfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssAllCfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssAllCfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssAllCfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssAllCfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssAllCfg_rsp &a, CWssAllCfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssAllCfg_rsp::CWssAllCfg_rsp(const CWssAllCfg_rsp& other870) {
  response = other870.response;
  data = other870.data;
  __isset = other870.__isset;
}
CWssAllCfg_rsp& CWssAllCfg_rsp::operator=(const CWssAllCfg_rsp& other871) {
  response = other871.response;
  data = other871.data;
  __isset = other871.__isset;
  return *this;
}
void CWssAllCfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssAllCfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssPortPowerHistory_rsp::~CWssPortPowerHistory_rsp() noexcept {
}


void CWssPortPowerHistory_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssPortPowerHistory_rsp::__set_data(const CWssPortPowerHistory_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssPortPowerHistory_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssPortPowerHistory_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssPortPowerHistory_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssPortPowerHistory_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssPortPowerHistory_rsp &a, CWssPortPowerHistory_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssPortPowerHistory_rsp::CWssPortPowerHistory_rsp(const CWssPortPowerHistory_rsp& other872) {
  response = other872.response;
  data = other872.data;
  __isset = other872.__isset;
}
CWssPortPowerHistory_rsp& CWssPortPowerHistory_rsp::operator=(const CWssPortPowerHistory_rsp& other873) {
  response = other873.response;
  data = other873.data;
  __isset = other873.__isset;
  return *this;
}
void CWssPortPowerHistory_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssPortPowerHistory_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssCurData_rsp::~CWssCurData_rsp() noexcept {
}


void CWssCurData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssCurData_rsp::__set_data(const CWssCurData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssCurData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssCurData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssCurData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssCurData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssCurData_rsp &a, CWssCurData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssCurData_rsp::CWssCurData_rsp(const CWssCurData_rsp& other874) {
  response = other874.response;
  data = other874.data;
  __isset = other874.__isset;
}
CWssCurData_rsp& CWssCurData_rsp::operator=(const CWssCurData_rsp& other875) {
  response = other875.response;
  data = other875.data;
  __isset = other875.__isset;
  return *this;
}
void CWssCurData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssCurData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssAlarm_rsp::~CWssAlarm_rsp() noexcept {
}


void CWssAlarm_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssAlarm_rsp::__set_data(const CWssAlarm_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssAlarm_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssAlarm_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssAlarm_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssAlarm_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssAlarm_rsp &a, CWssAlarm_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssAlarm_rsp::CWssAlarm_rsp(const CWssAlarm_rsp& other876) {
  response = other876.response;
  data = other876.data;
  __isset = other876.__isset;
}
CWssAlarm_rsp& CWssAlarm_rsp::operator=(const CWssAlarm_rsp& other877) {
  response = other877.response;
  data = other877.data;
  __isset = other877.__isset;
  return *this;
}
void CWssAlarm_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssAlarm_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssStatusData_rsp::~CWssStatusData_rsp() noexcept {
}


void CWssStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssStatusData_rsp::__set_data(const CWssStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssStatusData_rsp &a, CWssStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssStatusData_rsp::CWssStatusData_rsp(const CWssStatusData_rsp& other878) {
  response = other878.response;
  data = other878.data;
  __isset = other878.__isset;
}
CWssStatusData_rsp& CWssStatusData_rsp::operator=(const CWssStatusData_rsp& other879) {
  response = other879.response;
  data = other879.data;
  __isset = other879.__isset;
  return *this;
}
void CWssStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CPortPowerCfg_rsp::~CPortPowerCfg_rsp() noexcept {
}


void CPortPowerCfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CPortPowerCfg_rsp::__set_data(const CPortPowerCfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CPortPowerCfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPortPowerCfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPortPowerCfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPortPowerCfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPortPowerCfg_rsp &a, CPortPowerCfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CPortPowerCfg_rsp::CPortPowerCfg_rsp(const CPortPowerCfg_rsp& other880) {
  response = other880.response;
  data = other880.data;
  __isset = other880.__isset;
}
CPortPowerCfg_rsp& CPortPowerCfg_rsp::operator=(const CPortPowerCfg_rsp& other881) {
  response = other881.response;
  data = other881.data;
  __isset = other881.__isset;
  return *this;
}
void CPortPowerCfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPortPowerCfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWavePlanSlice_rsp::~CWavePlanSlice_rsp() noexcept {
}


void CWavePlanSlice_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWavePlanSlice_rsp::__set_data(const CWavePlanSlice_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWavePlanSlice_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWavePlanSlice_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWavePlanSlice_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWavePlanSlice_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWavePlanSlice_rsp &a, CWavePlanSlice_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWavePlanSlice_rsp::CWavePlanSlice_rsp(const CWavePlanSlice_rsp& other882) {
  response = other882.response;
  data = other882.data;
  __isset = other882.__isset;
}
CWavePlanSlice_rsp& CWavePlanSlice_rsp::operator=(const CWavePlanSlice_rsp& other883) {
  response = other883.response;
  data = other883.data;
  __isset = other883.__isset;
  return *this;
}
void CWavePlanSlice_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWavePlanSlice_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


STChannelGrid_rsp::~STChannelGrid_rsp() noexcept {
}


void STChannelGrid_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void STChannelGrid_rsp::__set_data(const STChannelGrid_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const STChannelGrid_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t STChannelGrid_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t STChannelGrid_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("STChannelGrid_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(STChannelGrid_rsp &a, STChannelGrid_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

STChannelGrid_rsp::STChannelGrid_rsp(const STChannelGrid_rsp& other884) {
  response = other884.response;
  data = other884.data;
  __isset = other884.__isset;
}
STChannelGrid_rsp& STChannelGrid_rsp::operator=(const STChannelGrid_rsp& other885) {
  response = other885.response;
  data = other885.data;
  __isset = other885.__isset;
  return *this;
}
void STChannelGrid_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "STChannelGrid_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcmCfgData_rsp::~COcmCfgData_rsp() noexcept {
}


void COcmCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcmCfgData_rsp::__set_data(const COcmCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcmCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmCfgData_rsp &a, COcmCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcmCfgData_rsp::COcmCfgData_rsp(const COcmCfgData_rsp& other886) {
  response = other886.response;
  data = other886.data;
  __isset = other886.__isset;
}
COcmCfgData_rsp& COcmCfgData_rsp::operator=(const COcmCfgData_rsp& other887) {
  response = other887.response;
  data = other887.data;
  __isset = other887.__isset;
  return *this;
}
void COcmCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcmChPower_rsp::~COcmChPower_rsp() noexcept {
}


void COcmChPower_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcmChPower_rsp::__set_data(const COcmChPower_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcmChPower_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmChPower_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmChPower_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmChPower_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmChPower_rsp &a, COcmChPower_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcmChPower_rsp::COcmChPower_rsp(const COcmChPower_rsp& other888) {
  response = other888.response;
  data = other888.data;
  __isset = other888.__isset;
}
COcmChPower_rsp& COcmChPower_rsp::operator=(const COcmChPower_rsp& other889) {
  response = other889.response;
  data = other889.data;
  __isset = other889.__isset;
  return *this;
}
void COcmChPower_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmChPower_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcmOsa_rsp::~COcmOsa_rsp() noexcept {
}


void COcmOsa_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcmOsa_rsp::__set_data(const COcmOsa_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcmOsa_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmOsa_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmOsa_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmOsa_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmOsa_rsp &a, COcmOsa_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcmOsa_rsp::COcmOsa_rsp(const COcmOsa_rsp& other890) {
  response = other890.response;
  data = other890.data;
  __isset = other890.__isset;
}
COcmOsa_rsp& COcmOsa_rsp::operator=(const COcmOsa_rsp& other891) {
  response = other891.response;
  data = other891.data;
  __isset = other891.__isset;
  return *this;
}
void COcmOsa_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmOsa_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcmStatusData_rsp::~COcmStatusData_rsp() noexcept {
}


void COcmStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcmStatusData_rsp::__set_data(const COcmStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcmStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmStatusData_rsp &a, COcmStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcmStatusData_rsp::COcmStatusData_rsp(const COcmStatusData_rsp& other892) {
  response = other892.response;
  data = other892.data;
  __isset = other892.__isset;
}
COcmStatusData_rsp& COcmStatusData_rsp::operator=(const COcmStatusData_rsp& other893) {
  response = other893.response;
  data = other893.data;
  __isset = other893.__isset;
  return *this;
}
void COcmStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcmMode_rsp::~COcmMode_rsp() noexcept {
}


void COcmMode_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcmMode_rsp::__set_data(const COcmMode_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcmMode_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmMode_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmMode_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmMode_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmMode_rsp &a, COcmMode_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcmMode_rsp::COcmMode_rsp(const COcmMode_rsp& other894) {
  response = other894.response;
  data = other894.data;
  __isset = other894.__isset;
}
COcmMode_rsp& COcmMode_rsp::operator=(const COcmMode_rsp& other895) {
  response = other895.response;
  data = other895.data;
  __isset = other895.__isset;
  return *this;
}
void COcmMode_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmMode_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcmPortCali_rsp::~COcmPortCali_rsp() noexcept {
}


void COcmPortCali_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcmPortCali_rsp::__set_data(const COcmPortCali_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcmPortCali_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmPortCali_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmPortCali_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmPortCali_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmPortCali_rsp &a, COcmPortCali_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcmPortCali_rsp::COcmPortCali_rsp(const COcmPortCali_rsp& other896) {
  response = other896.response;
  data = other896.data;
  __isset = other896.__isset;
}
COcmPortCali_rsp& COcmPortCali_rsp::operator=(const COcmPortCali_rsp& other897) {
  response = other897.response;
  data = other897.data;
  __isset = other897.__isset;
  return *this;
}
void COcmPortCali_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmPortCali_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcmCali_rsp::~COcmCali_rsp() noexcept {
}


void COcmCali_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcmCali_rsp::__set_data(const COcmCali_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcmCali_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcmCali_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcmCali_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcmCali_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcmCali_rsp &a, COcmCali_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcmCali_rsp::COcmCali_rsp(const COcmCali_rsp& other898) {
  response = other898.response;
  data = other898.data;
  __isset = other898.__isset;
}
COcmCali_rsp& COcmCali_rsp::operator=(const COcmCali_rsp& other899) {
  response = other899.response;
  data = other899.data;
  __isset = other899.__isset;
  return *this;
}
void COcmCali_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcmCali_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaCaliData_rsp::~COaCaliData_rsp() noexcept {
}


void COaCaliData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaCaliData_rsp::__set_data(const COaCaliData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaCaliData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaCaliData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaCaliData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaCaliData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaCaliData_rsp &a, COaCaliData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaCaliData_rsp::COaCaliData_rsp(const COaCaliData_rsp& other900) {
  response = other900.response;
  data = other900.data;
  __isset = other900.__isset;
}
COaCaliData_rsp& COaCaliData_rsp::operator=(const COaCaliData_rsp& other901) {
  response = other901.response;
  data = other901.data;
  __isset = other901.__isset;
  return *this;
}
void COaCaliData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaCaliData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaCfgData_rsp::~COaCfgData_rsp() noexcept {
}


void COaCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaCfgData_rsp::__set_data(const COaCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaCfgData_rsp &a, COaCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaCfgData_rsp::COaCfgData_rsp(const COaCfgData_rsp& other902) {
  response = other902.response;
  data = other902.data;
  __isset = other902.__isset;
}
COaCfgData_rsp& COaCfgData_rsp::operator=(const COaCfgData_rsp& other903) {
  response = other903.response;
  data = other903.data;
  __isset = other903.__isset;
  return *this;
}
void COaCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaAlarm_rsp::~COaAlarm_rsp() noexcept {
}


void COaAlarm_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaAlarm_rsp::__set_data(const COaAlarm_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaAlarm_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaAlarm_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaAlarm_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaAlarm_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaAlarm_rsp &a, COaAlarm_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaAlarm_rsp::COaAlarm_rsp(const COaAlarm_rsp& other904) {
  response = other904.response;
  data = other904.data;
  __isset = other904.__isset;
}
COaAlarm_rsp& COaAlarm_rsp::operator=(const COaAlarm_rsp& other905) {
  response = other905.response;
  data = other905.data;
  __isset = other905.__isset;
  return *this;
}
void COaAlarm_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaAlarm_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMN_THR_HYS_INFO_ST_rsp::~CMN_THR_HYS_INFO_ST_rsp() noexcept {
}


void CMN_THR_HYS_INFO_ST_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMN_THR_HYS_INFO_ST_rsp::__set_data(const CMN_THR_HYS_INFO_ST_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMN_THR_HYS_INFO_ST_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMN_THR_HYS_INFO_ST_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMN_THR_HYS_INFO_ST_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMN_THR_HYS_INFO_ST_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMN_THR_HYS_INFO_ST_rsp &a, CMN_THR_HYS_INFO_ST_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMN_THR_HYS_INFO_ST_rsp::CMN_THR_HYS_INFO_ST_rsp(const CMN_THR_HYS_INFO_ST_rsp& other906) {
  response = other906.response;
  data = other906.data;
  __isset = other906.__isset;
}
CMN_THR_HYS_INFO_ST_rsp& CMN_THR_HYS_INFO_ST_rsp::operator=(const CMN_THR_HYS_INFO_ST_rsp& other907) {
  response = other907.response;
  data = other907.data;
  __isset = other907.__isset;
  return *this;
}
void CMN_THR_HYS_INFO_ST_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMN_THR_HYS_INFO_ST_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


EDFA_LASER_SAFETY_ST_rsp::~EDFA_LASER_SAFETY_ST_rsp() noexcept {
}


void EDFA_LASER_SAFETY_ST_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void EDFA_LASER_SAFETY_ST_rsp::__set_data(const EDFA_LASER_SAFETY_ST_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const EDFA_LASER_SAFETY_ST_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EDFA_LASER_SAFETY_ST_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EDFA_LASER_SAFETY_ST_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EDFA_LASER_SAFETY_ST_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EDFA_LASER_SAFETY_ST_rsp &a, EDFA_LASER_SAFETY_ST_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

EDFA_LASER_SAFETY_ST_rsp::EDFA_LASER_SAFETY_ST_rsp(const EDFA_LASER_SAFETY_ST_rsp& other908) {
  response = other908.response;
  data = other908.data;
  __isset = other908.__isset;
}
EDFA_LASER_SAFETY_ST_rsp& EDFA_LASER_SAFETY_ST_rsp::operator=(const EDFA_LASER_SAFETY_ST_rsp& other909) {
  response = other909.response;
  data = other909.data;
  __isset = other909.__isset;
  return *this;
}
void EDFA_LASER_SAFETY_ST_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EDFA_LASER_SAFETY_ST_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaCurData_rsp::~COaCurData_rsp() noexcept {
}


void COaCurData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaCurData_rsp::__set_data(const COaCurData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaCurData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaCurData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaCurData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaCurData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaCurData_rsp &a, COaCurData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaCurData_rsp::COaCurData_rsp(const COaCurData_rsp& other910) {
  response = other910.response;
  data = other910.data;
  __isset = other910.__isset;
}
COaCurData_rsp& COaCurData_rsp::operator=(const COaCurData_rsp& other911) {
  response = other911.response;
  data = other911.data;
  __isset = other911.__isset;
  return *this;
}
void COaCurData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaCurData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaAnnexData_rsp::~COaAnnexData_rsp() noexcept {
}


void COaAnnexData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaAnnexData_rsp::__set_data(const COaAnnexData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaAnnexData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaAnnexData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaAnnexData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaAnnexData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaAnnexData_rsp &a, COaAnnexData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaAnnexData_rsp::COaAnnexData_rsp(const COaAnnexData_rsp& other912) {
  response = other912.response;
  data = other912.data;
  __isset = other912.__isset;
}
COaAnnexData_rsp& COaAnnexData_rsp::operator=(const COaAnnexData_rsp& other913) {
  response = other913.response;
  data = other913.data;
  __isset = other913.__isset;
  return *this;
}
void COaAnnexData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaAnnexData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaStatusData_rsp::~COaStatusData_rsp() noexcept {
}


void COaStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaStatusData_rsp::__set_data(const COaStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaStatusData_rsp &a, COaStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaStatusData_rsp::COaStatusData_rsp(const COaStatusData_rsp& other914) {
  response = other914.response;
  data = other914.data;
  __isset = other914.__isset;
}
COaStatusData_rsp& COaStatusData_rsp::operator=(const COaStatusData_rsp& other915) {
  response = other915.response;
  data = other915.data;
  __isset = other915.__isset;
  return *this;
}
void COaStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaEventLogData_rsp::~COaEventLogData_rsp() noexcept {
}


void COaEventLogData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaEventLogData_rsp::__set_data(const COaEventLogData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaEventLogData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaEventLogData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaEventLogData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaEventLogData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaEventLogData_rsp &a, COaEventLogData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaEventLogData_rsp::COaEventLogData_rsp(const COaEventLogData_rsp& other916) {
  response = other916.response;
  data = other916.data;
  __isset = other916.__isset;
}
COaEventLogData_rsp& COaEventLogData_rsp::operator=(const COaEventLogData_rsp& other917) {
  response = other917.response;
  data = other917.data;
  __isset = other917.__isset;
  return *this;
}
void COaEventLogData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaEventLogData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COaEventLogAllData_rsp::~COaEventLogAllData_rsp() noexcept {
}


void COaEventLogAllData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COaEventLogAllData_rsp::__set_data(const COaEventLogAllData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COaEventLogAllData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COaEventLogAllData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COaEventLogAllData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COaEventLogAllData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COaEventLogAllData_rsp &a, COaEventLogAllData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COaEventLogAllData_rsp::COaEventLogAllData_rsp(const COaEventLogAllData_rsp& other918) {
  response = other918.response;
  data = other918.data;
  __isset = other918.__isset;
}
COaEventLogAllData_rsp& COaEventLogAllData_rsp::operator=(const COaEventLogAllData_rsp& other919) {
  response = other919.response;
  data = other919.data;
  __isset = other919.__isset;
  return *this;
}
void COaEventLogAllData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COaEventLogAllData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CExtendCfgData_rsp::~CExtendCfgData_rsp() noexcept {
}


void CExtendCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CExtendCfgData_rsp::__set_data(const CExtendCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CExtendCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CExtendCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CExtendCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CExtendCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CExtendCfgData_rsp &a, CExtendCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CExtendCfgData_rsp::CExtendCfgData_rsp(const CExtendCfgData_rsp& other920) {
  response = other920.response;
  data = other920.data;
  __isset = other920.__isset;
}
CExtendCfgData_rsp& CExtendCfgData_rsp::operator=(const CExtendCfgData_rsp& other921) {
  response = other921.response;
  data = other921.data;
  __isset = other921.__isset;
  return *this;
}
void CExtendCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CExtendCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CExtendStatusData_rsp::~CExtendStatusData_rsp() noexcept {
}


void CExtendStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CExtendStatusData_rsp::__set_data(const CExtendStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CExtendStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CExtendStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CExtendStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CExtendStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CExtendStatusData_rsp &a, CExtendStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CExtendStatusData_rsp::CExtendStatusData_rsp(const CExtendStatusData_rsp& other922) {
  response = other922.response;
  data = other922.data;
  __isset = other922.__isset;
}
CExtendStatusData_rsp& CExtendStatusData_rsp::operator=(const CExtendStatusData_rsp& other923) {
  response = other923.response;
  data = other923.data;
  __isset = other923.__isset;
  return *this;
}
void CExtendStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CExtendStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMirrorData_rsp::~CMirrorData_rsp() noexcept {
}


void CMirrorData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMirrorData_rsp::__set_data(const CMirrorData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMirrorData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMirrorData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMirrorData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMirrorData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMirrorData_rsp &a, CMirrorData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMirrorData_rsp::CMirrorData_rsp(const CMirrorData_rsp& other924) {
  response = other924.response;
  data = other924.data;
  __isset = other924.__isset;
}
CMirrorData_rsp& CMirrorData_rsp::operator=(const CMirrorData_rsp& other925) {
  response = other925.response;
  data = other925.data;
  __isset = other925.__isset;
  return *this;
}
void CMirrorData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMirrorData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMuxCfgData_rsp::~CMuxCfgData_rsp() noexcept {
}


void CMuxCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMuxCfgData_rsp::__set_data(const CMuxCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMuxCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMuxCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMuxCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMuxCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMuxCfgData_rsp &a, CMuxCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMuxCfgData_rsp::CMuxCfgData_rsp(const CMuxCfgData_rsp& other926) {
  response = other926.response;
  data = other926.data;
  __isset = other926.__isset;
}
CMuxCfgData_rsp& CMuxCfgData_rsp::operator=(const CMuxCfgData_rsp& other927) {
  response = other927.response;
  data = other927.data;
  __isset = other927.__isset;
  return *this;
}
void CMuxCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMuxCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMuxStatusData_rsp::~CMuxStatusData_rsp() noexcept {
}


void CMuxStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMuxStatusData_rsp::__set_data(const CMuxStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMuxStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMuxStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMuxStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMuxStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMuxStatusData_rsp &a, CMuxStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMuxStatusData_rsp::CMuxStatusData_rsp(const CMuxStatusData_rsp& other928) {
  response = other928.response;
  data = other928.data;
  __isset = other928.__isset;
}
CMuxStatusData_rsp& CMuxStatusData_rsp::operator=(const CMuxStatusData_rsp& other929) {
  response = other929.response;
  data = other929.data;
  __isset = other929.__isset;
  return *this;
}
void CMuxStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMuxStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMuxCaliData_rsp::~CMuxCaliData_rsp() noexcept {
}


void CMuxCaliData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMuxCaliData_rsp::__set_data(const CMuxCaliData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMuxCaliData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMuxCaliData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMuxCaliData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMuxCaliData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMuxCaliData_rsp &a, CMuxCaliData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMuxCaliData_rsp::CMuxCaliData_rsp(const CMuxCaliData_rsp& other930) {
  response = other930.response;
  data = other930.data;
  __isset = other930.__isset;
}
CMuxCaliData_rsp& CMuxCaliData_rsp::operator=(const CMuxCaliData_rsp& other931) {
  response = other931.response;
  data = other931.data;
  __isset = other931.__isset;
  return *this;
}
void CMuxCaliData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMuxCaliData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsLedChannel_rsp::~COpsLedChannel_rsp() noexcept {
}


void COpsLedChannel_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsLedChannel_rsp::__set_data(const COpsLedChannel_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsLedChannel_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsLedChannel_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsLedChannel_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsLedChannel_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsLedChannel_rsp &a, COpsLedChannel_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsLedChannel_rsp::COpsLedChannel_rsp(const COpsLedChannel_rsp& other932) {
  response = other932.response;
  data = other932.data;
  __isset = other932.__isset;
}
COpsLedChannel_rsp& COpsLedChannel_rsp::operator=(const COpsLedChannel_rsp& other933) {
  response = other933.response;
  data = other933.data;
  __isset = other933.__isset;
  return *this;
}
void COpsLedChannel_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsLedChannel_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsLedAll_rsp::~COpsLedAll_rsp() noexcept {
}


void COpsLedAll_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsLedAll_rsp::__set_data(const COpsLedAll_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsLedAll_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsLedAll_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsLedAll_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsLedAll_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsLedAll_rsp &a, COpsLedAll_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsLedAll_rsp::COpsLedAll_rsp(const COpsLedAll_rsp& other934) {
  response = other934.response;
  data = other934.data;
  __isset = other934.__isset;
}
COpsLedAll_rsp& COpsLedAll_rsp::operator=(const COpsLedAll_rsp& other935) {
  response = other935.response;
  data = other935.data;
  __isset = other935.__isset;
  return *this;
}
void COpsLedAll_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsLedAll_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsLed_rsp::~COpsLed_rsp() noexcept {
}


void COpsLed_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsLed_rsp::__set_data(const COpsLed_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsLed_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsLed_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsLed_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsLed_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsLed_rsp &a, COpsLed_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsLed_rsp::COpsLed_rsp(const COpsLed_rsp& other936) {
  response = other936.response;
  data = other936.data;
  __isset = other936.__isset;
}
COpsLed_rsp& COpsLed_rsp::operator=(const COpsLed_rsp& other937) {
  response = other937.response;
  data = other937.data;
  __isset = other937.__isset;
  return *this;
}
void COpsLed_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsLed_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsCurData_rsp::~COpsCurData_rsp() noexcept {
}


void COpsCurData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsCurData_rsp::__set_data(const COpsCurData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsCurData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsCurData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsCurData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsCurData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsCurData_rsp &a, COpsCurData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsCurData_rsp::COpsCurData_rsp(const COpsCurData_rsp& other938) {
  response = other938.response;
  data = other938.data;
  __isset = other938.__isset;
}
COpsCurData_rsp& COpsCurData_rsp::operator=(const COpsCurData_rsp& other939) {
  response = other939.response;
  data = other939.data;
  __isset = other939.__isset;
  return *this;
}
void COpsCurData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsCurData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsAlarm_rsp::~COpsAlarm_rsp() noexcept {
}


void COpsAlarm_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsAlarm_rsp::__set_data(const COpsAlarm_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsAlarm_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsAlarm_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsAlarm_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsAlarm_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsAlarm_rsp &a, COpsAlarm_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsAlarm_rsp::COpsAlarm_rsp(const COpsAlarm_rsp& other940) {
  response = other940.response;
  data = other940.data;
  __isset = other940.__isset;
}
COpsAlarm_rsp& COpsAlarm_rsp::operator=(const COpsAlarm_rsp& other941) {
  response = other941.response;
  data = other941.data;
  __isset = other941.__isset;
  return *this;
}
void COpsAlarm_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsAlarm_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsHistoryUnitData_rsp::~COpsHistoryUnitData_rsp() noexcept {
}


void COpsHistoryUnitData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsHistoryUnitData_rsp::__set_data(const COpsHistoryUnitData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsHistoryUnitData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsHistoryUnitData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsHistoryUnitData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsHistoryUnitData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsHistoryUnitData_rsp &a, COpsHistoryUnitData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsHistoryUnitData_rsp::COpsHistoryUnitData_rsp(const COpsHistoryUnitData_rsp& other942) {
  response = other942.response;
  data = other942.data;
  __isset = other942.__isset;
}
COpsHistoryUnitData_rsp& COpsHistoryUnitData_rsp::operator=(const COpsHistoryUnitData_rsp& other943) {
  response = other943.response;
  data = other943.data;
  __isset = other943.__isset;
  return *this;
}
void COpsHistoryUnitData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsHistoryUnitData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsHistoryData_rsp::~COpsHistoryData_rsp() noexcept {
}


void COpsHistoryData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsHistoryData_rsp::__set_data(const COpsHistoryData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsHistoryData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsHistoryData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsHistoryData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsHistoryData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsHistoryData_rsp &a, COpsHistoryData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsHistoryData_rsp::COpsHistoryData_rsp(const COpsHistoryData_rsp& other944) {
  response = other944.response;
  data = other944.data;
  __isset = other944.__isset;
}
COpsHistoryData_rsp& COpsHistoryData_rsp::operator=(const COpsHistoryData_rsp& other945) {
  response = other945.response;
  data = other945.data;
  __isset = other945.__isset;
  return *this;
}
void COpsHistoryData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsHistoryData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COscPd_rsp::~COscPd_rsp() noexcept {
}


void COscPd_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COscPd_rsp::__set_data(const COscPd_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COscPd_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscPd_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscPd_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscPd_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscPd_rsp &a, COscPd_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COscPd_rsp::COscPd_rsp(const COscPd_rsp& other946) {
  response = other946.response;
  data = other946.data;
  __isset = other946.__isset;
}
COscPd_rsp& COscPd_rsp::operator=(const COscPd_rsp& other947) {
  response = other947.response;
  data = other947.data;
  __isset = other947.__isset;
  return *this;
}
void COscPd_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscPd_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COscSwitchPos_rsp::~COscSwitchPos_rsp() noexcept {
}


void COscSwitchPos_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COscSwitchPos_rsp::__set_data(const COscSwitchPos_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COscSwitchPos_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscSwitchPos_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscSwitchPos_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscSwitchPos_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscSwitchPos_rsp &a, COscSwitchPos_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COscSwitchPos_rsp::COscSwitchPos_rsp(const COscSwitchPos_rsp& other948) {
  response = other948.response;
  data = other948.data;
  __isset = other948.__isset;
}
COscSwitchPos_rsp& COscSwitchPos_rsp::operator=(const COscSwitchPos_rsp& other949) {
  response = other949.response;
  data = other949.data;
  __isset = other949.__isset;
  return *this;
}
void COscSwitchPos_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscSwitchPos_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COscSwitchPosSet_rsp::~COscSwitchPosSet_rsp() noexcept {
}


void COscSwitchPosSet_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COscSwitchPosSet_rsp::__set_data(const COscSwitchPosSet_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COscSwitchPosSet_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COscSwitchPosSet_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COscSwitchPosSet_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COscSwitchPosSet_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COscSwitchPosSet_rsp &a, COscSwitchPosSet_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COscSwitchPosSet_rsp::COscSwitchPosSet_rsp(const COscSwitchPosSet_rsp& other950) {
  response = other950.response;
  data = other950.data;
  __isset = other950.__isset;
}
COscSwitchPosSet_rsp& COscSwitchPosSet_rsp::operator=(const COscSwitchPosSet_rsp& other951) {
  response = other951.response;
  data = other951.data;
  __isset = other951.__isset;
  return *this;
}
void COscSwitchPosSet_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COscSwitchPosSet_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsVoltage_rsp::~COpsVoltage_rsp() noexcept {
}


void COpsVoltage_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsVoltage_rsp::__set_data(const COpsVoltage_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsVoltage_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsVoltage_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsVoltage_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsVoltage_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsVoltage_rsp &a, COpsVoltage_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsVoltage_rsp::COpsVoltage_rsp(const COpsVoltage_rsp& other952) {
  response = other952.response;
  data = other952.data;
  __isset = other952.__isset;
}
COpsVoltage_rsp& COpsVoltage_rsp::operator=(const COpsVoltage_rsp& other953) {
  response = other953.response;
  data = other953.data;
  __isset = other953.__isset;
  return *this;
}
void COpsVoltage_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsVoltage_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsIL_rsp::~COpsIL_rsp() noexcept {
}


void COpsIL_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsIL_rsp::__set_data(const COpsIL_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsIL_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsIL_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsIL_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsIL_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsIL_rsp &a, COpsIL_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsIL_rsp::COpsIL_rsp(const COpsIL_rsp& other954) {
  response = other954.response;
  data = other954.data;
  __isset = other954.__isset;
}
COpsIL_rsp& COpsIL_rsp::operator=(const COpsIL_rsp& other955) {
  response = other955.response;
  data = other955.data;
  __isset = other955.__isset;
  return *this;
}
void COpsIL_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsIL_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsUpgStat_rsp::~COpsUpgStat_rsp() noexcept {
}


void COpsUpgStat_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsUpgStat_rsp::__set_data(const COpsUpgStat_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsUpgStat_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsUpgStat_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsUpgStat_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsUpgStat_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsUpgStat_rsp &a, COpsUpgStat_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsUpgStat_rsp::COpsUpgStat_rsp(const COpsUpgStat_rsp& other956) {
  response = other956.response;
  data = other956.data;
  __isset = other956.__isset;
}
COpsUpgStat_rsp& COpsUpgStat_rsp::operator=(const COpsUpgStat_rsp& other957) {
  response = other957.response;
  data = other957.data;
  __isset = other957.__isset;
  return *this;
}
void COpsUpgStat_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsUpgStat_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsConnectionPd_rsp::~COpsConnectionPd_rsp() noexcept {
}


void COpsConnectionPd_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsConnectionPd_rsp::__set_data(const COpsConnectionPd_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsConnectionPd_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsConnectionPd_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsConnectionPd_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsConnectionPd_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsConnectionPd_rsp &a, COpsConnectionPd_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsConnectionPd_rsp::COpsConnectionPd_rsp(const COpsConnectionPd_rsp& other958) {
  response = other958.response;
  data = other958.data;
  __isset = other958.__isset;
}
COpsConnectionPd_rsp& COpsConnectionPd_rsp::operator=(const COpsConnectionPd_rsp& other959) {
  response = other959.response;
  data = other959.data;
  __isset = other959.__isset;
  return *this;
}
void COpsConnectionPd_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsConnectionPd_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsPdAdc_rsp::~COpsPdAdc_rsp() noexcept {
}


void COpsPdAdc_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsPdAdc_rsp::__set_data(const COpsPdAdc_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsPdAdc_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsPdAdc_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsPdAdc_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsPdAdc_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsPdAdc_rsp &a, COpsPdAdc_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsPdAdc_rsp::COpsPdAdc_rsp(const COpsPdAdc_rsp& other960) {
  response = other960.response;
  data = other960.data;
  __isset = other960.__isset;
}
COpsPdAdc_rsp& COpsPdAdc_rsp::operator=(const COpsPdAdc_rsp& other961) {
  response = other961.response;
  data = other961.data;
  __isset = other961.__isset;
  return *this;
}
void COpsPdAdc_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsPdAdc_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsConnectionPdThr_rsp::~COpsConnectionPdThr_rsp() noexcept {
}


void COpsConnectionPdThr_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsConnectionPdThr_rsp::__set_data(const COpsConnectionPdThr_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsConnectionPdThr_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsConnectionPdThr_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsConnectionPdThr_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsConnectionPdThr_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsConnectionPdThr_rsp &a, COpsConnectionPdThr_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsConnectionPdThr_rsp::COpsConnectionPdThr_rsp(const COpsConnectionPdThr_rsp& other962) {
  response = other962.response;
  data = other962.data;
  __isset = other962.__isset;
}
COpsConnectionPdThr_rsp& COpsConnectionPdThr_rsp::operator=(const COpsConnectionPdThr_rsp& other963) {
  response = other963.response;
  data = other963.data;
  __isset = other963.__isset;
  return *this;
}
void COpsConnectionPdThr_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsConnectionPdThr_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsConnectionPdHys_rsp::~COpsConnectionPdHys_rsp() noexcept {
}


void COpsConnectionPdHys_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsConnectionPdHys_rsp::__set_data(const COpsConnectionPdHys_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsConnectionPdHys_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsConnectionPdHys_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsConnectionPdHys_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsConnectionPdHys_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsConnectionPdHys_rsp &a, COpsConnectionPdHys_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsConnectionPdHys_rsp::COpsConnectionPdHys_rsp(const COpsConnectionPdHys_rsp& other964) {
  response = other964.response;
  data = other964.data;
  __isset = other964.__isset;
}
COpsConnectionPdHys_rsp& COpsConnectionPdHys_rsp::operator=(const COpsConnectionPdHys_rsp& other965) {
  response = other965.response;
  data = other965.data;
  __isset = other965.__isset;
  return *this;
}
void COpsConnectionPdHys_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsConnectionPdHys_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsReqStatus_rsp::~COpsReqStatus_rsp() noexcept {
}


void COpsReqStatus_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsReqStatus_rsp::__set_data(const COpsReqStatus_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsReqStatus_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsReqStatus_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsReqStatus_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsReqStatus_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsReqStatus_rsp &a, COpsReqStatus_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsReqStatus_rsp::COpsReqStatus_rsp(const COpsReqStatus_rsp& other966) {
  response = other966.response;
  data = other966.data;
  __isset = other966.__isset;
}
COpsReqStatus_rsp& COpsReqStatus_rsp::operator=(const COpsReqStatus_rsp& other967) {
  response = other967.response;
  data = other967.data;
  __isset = other967.__isset;
  return *this;
}
void COpsReqStatus_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsReqStatus_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsBidirectionStatus_rsp::~COpsBidirectionStatus_rsp() noexcept {
}


void COpsBidirectionStatus_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsBidirectionStatus_rsp::__set_data(const COpsBidirectionStatus_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsBidirectionStatus_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsBidirectionStatus_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsBidirectionStatus_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsBidirectionStatus_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsBidirectionStatus_rsp &a, COpsBidirectionStatus_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsBidirectionStatus_rsp::COpsBidirectionStatus_rsp(const COpsBidirectionStatus_rsp& other968) {
  response = other968.response;
  data = other968.data;
  __isset = other968.__isset;
}
COpsBidirectionStatus_rsp& COpsBidirectionStatus_rsp::operator=(const COpsBidirectionStatus_rsp& other969) {
  response = other969.response;
  data = other969.data;
  __isset = other969.__isset;
  return *this;
}
void COpsBidirectionStatus_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsBidirectionStatus_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsAlmMask_rsp::~COpsAlmMask_rsp() noexcept {
}


void COpsAlmMask_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsAlmMask_rsp::__set_data(const COpsAlmMask_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsAlmMask_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsAlmMask_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsAlmMask_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsAlmMask_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsAlmMask_rsp &a, COpsAlmMask_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsAlmMask_rsp::COpsAlmMask_rsp(const COpsAlmMask_rsp& other970) {
  response = other970.response;
  data = other970.data;
  __isset = other970.__isset;
}
COpsAlmMask_rsp& COpsAlmMask_rsp::operator=(const COpsAlmMask_rsp& other971) {
  response = other971.response;
  data = other971.data;
  __isset = other971.__isset;
  return *this;
}
void COpsAlmMask_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsAlmMask_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsCommStatusData_rsp::~COpsCommStatusData_rsp() noexcept {
}


void COpsCommStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsCommStatusData_rsp::__set_data(const COpsCommStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsCommStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsCommStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsCommStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsCommStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsCommStatusData_rsp &a, COpsCommStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsCommStatusData_rsp::COpsCommStatusData_rsp(const COpsCommStatusData_rsp& other972) {
  response = other972.response;
  data = other972.data;
  __isset = other972.__isset;
}
COpsCommStatusData_rsp& COpsCommStatusData_rsp::operator=(const COpsCommStatusData_rsp& other973) {
  response = other973.response;
  data = other973.data;
  __isset = other973.__isset;
  return *this;
}
void COpsCommStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsCommStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsStatusData_rsp::~COpsStatusData_rsp() noexcept {
}


void COpsStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsStatusData_rsp::__set_data(const COpsStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsStatusData_rsp &a, COpsStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsStatusData_rsp::COpsStatusData_rsp(const COpsStatusData_rsp& other974) {
  response = other974.response;
  data = other974.data;
  __isset = other974.__isset;
}
COpsStatusData_rsp& COpsStatusData_rsp::operator=(const COpsStatusData_rsp& other975) {
  response = other975.response;
  data = other975.data;
  __isset = other975.__isset;
  return *this;
}
void COpsStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsSwitchThr_rsp::~COpsSwitchThr_rsp() noexcept {
}


void COpsSwitchThr_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsSwitchThr_rsp::__set_data(const COpsSwitchThr_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsSwitchThr_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsSwitchThr_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsSwitchThr_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsSwitchThr_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsSwitchThr_rsp &a, COpsSwitchThr_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsSwitchThr_rsp::COpsSwitchThr_rsp(const COpsSwitchThr_rsp& other976) {
  response = other976.response;
  data = other976.data;
  __isset = other976.__isset;
}
COpsSwitchThr_rsp& COpsSwitchThr_rsp::operator=(const COpsSwitchThr_rsp& other977) {
  response = other977.response;
  data = other977.data;
  __isset = other977.__isset;
  return *this;
}
void COpsSwitchThr_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsSwitchThr_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsSwitchHys_rsp::~COpsSwitchHys_rsp() noexcept {
}


void COpsSwitchHys_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsSwitchHys_rsp::__set_data(const COpsSwitchHys_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsSwitchHys_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsSwitchHys_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsSwitchHys_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsSwitchHys_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsSwitchHys_rsp &a, COpsSwitchHys_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsSwitchHys_rsp::COpsSwitchHys_rsp(const COpsSwitchHys_rsp& other978) {
  response = other978.response;
  data = other978.data;
  __isset = other978.__isset;
}
COpsSwitchHys_rsp& COpsSwitchHys_rsp::operator=(const COpsSwitchHys_rsp& other979) {
  response = other979.response;
  data = other979.data;
  __isset = other979.__isset;
  return *this;
}
void COpsSwitchHys_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsSwitchHys_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CPortPowerThr_rsp::~CPortPowerThr_rsp() noexcept {
}


void CPortPowerThr_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CPortPowerThr_rsp::__set_data(const CPortPowerThr_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CPortPowerThr_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPortPowerThr_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPortPowerThr_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPortPowerThr_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPortPowerThr_rsp &a, CPortPowerThr_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CPortPowerThr_rsp::CPortPowerThr_rsp(const CPortPowerThr_rsp& other980) {
  response = other980.response;
  data = other980.data;
  __isset = other980.__isset;
}
CPortPowerThr_rsp& CPortPowerThr_rsp::operator=(const CPortPowerThr_rsp& other981) {
  response = other981.response;
  data = other981.data;
  __isset = other981.__isset;
  return *this;
}
void CPortPowerThr_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPortPowerThr_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CPortPowerHys_rsp::~CPortPowerHys_rsp() noexcept {
}


void CPortPowerHys_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CPortPowerHys_rsp::__set_data(const CPortPowerHys_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CPortPowerHys_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPortPowerHys_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPortPowerHys_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPortPowerHys_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPortPowerHys_rsp &a, CPortPowerHys_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CPortPowerHys_rsp::CPortPowerHys_rsp(const CPortPowerHys_rsp& other982) {
  response = other982.response;
  data = other982.data;
  __isset = other982.__isset;
}
CPortPowerHys_rsp& CPortPowerHys_rsp::operator=(const CPortPowerHys_rsp& other983) {
  response = other983.response;
  data = other983.data;
  __isset = other983.__isset;
  return *this;
}
void CPortPowerHys_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPortPowerHys_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssPortPowerThr_rsp::~CWssPortPowerThr_rsp() noexcept {
}


void CWssPortPowerThr_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssPortPowerThr_rsp::__set_data(const CWssPortPowerThr_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssPortPowerThr_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssPortPowerThr_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssPortPowerThr_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssPortPowerThr_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssPortPowerThr_rsp &a, CWssPortPowerThr_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssPortPowerThr_rsp::CWssPortPowerThr_rsp(const CWssPortPowerThr_rsp& other984) {
  response = other984.response;
  data = other984.data;
  __isset = other984.__isset;
}
CWssPortPowerThr_rsp& CWssPortPowerThr_rsp::operator=(const CWssPortPowerThr_rsp& other985) {
  response = other985.response;
  data = other985.data;
  __isset = other985.__isset;
  return *this;
}
void CWssPortPowerThr_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssPortPowerThr_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CWssPortPowerHys_rsp::~CWssPortPowerHys_rsp() noexcept {
}


void CWssPortPowerHys_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CWssPortPowerHys_rsp::__set_data(const CWssPortPowerHys_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CWssPortPowerHys_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CWssPortPowerHys_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CWssPortPowerHys_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CWssPortPowerHys_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CWssPortPowerHys_rsp &a, CWssPortPowerHys_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CWssPortPowerHys_rsp::CWssPortPowerHys_rsp(const CWssPortPowerHys_rsp& other986) {
  response = other986.response;
  data = other986.data;
  __isset = other986.__isset;
}
CWssPortPowerHys_rsp& CWssPortPowerHys_rsp::operator=(const CWssPortPowerHys_rsp& other987) {
  response = other987.response;
  data = other987.data;
  __isset = other987.__isset;
  return *this;
}
void CWssPortPowerHys_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CWssPortPowerHys_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CRelativeThr_rsp::~CRelativeThr_rsp() noexcept {
}


void CRelativeThr_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CRelativeThr_rsp::__set_data(const CRelativeThr_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CRelativeThr_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CRelativeThr_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CRelativeThr_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CRelativeThr_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CRelativeThr_rsp &a, CRelativeThr_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CRelativeThr_rsp::CRelativeThr_rsp(const CRelativeThr_rsp& other988) {
  response = other988.response;
  data = other988.data;
  __isset = other988.__isset;
}
CRelativeThr_rsp& CRelativeThr_rsp::operator=(const CRelativeThr_rsp& other989) {
  response = other989.response;
  data = other989.data;
  __isset = other989.__isset;
  return *this;
}
void CRelativeThr_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CRelativeThr_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CRelativeOffset_rsp::~CRelativeOffset_rsp() noexcept {
}


void CRelativeOffset_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CRelativeOffset_rsp::__set_data(const CRelativeOffset_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CRelativeOffset_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CRelativeOffset_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CRelativeOffset_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CRelativeOffset_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CRelativeOffset_rsp &a, CRelativeOffset_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CRelativeOffset_rsp::CRelativeOffset_rsp(const CRelativeOffset_rsp& other990) {
  response = other990.response;
  data = other990.data;
  __isset = other990.__isset;
}
CRelativeOffset_rsp& CRelativeOffset_rsp::operator=(const CRelativeOffset_rsp& other991) {
  response = other991.response;
  data = other991.data;
  __isset = other991.__isset;
  return *this;
}
void CRelativeOffset_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CRelativeOffset_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsCfgData_rsp::~COpsCfgData_rsp() noexcept {
}


void COpsCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsCfgData_rsp::__set_data(const COpsCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsCfgData_rsp &a, COpsCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsCfgData_rsp::COpsCfgData_rsp(const COpsCfgData_rsp& other992) {
  response = other992.response;
  data = other992.data;
  __isset = other992.__isset;
}
COpsCfgData_rsp& COpsCfgData_rsp::operator=(const COpsCfgData_rsp& other993) {
  response = other993.response;
  data = other993.data;
  __isset = other993.__isset;
  return *this;
}
void COpsCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsEventLogData_rsp::~COpsEventLogData_rsp() noexcept {
}


void COpsEventLogData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsEventLogData_rsp::__set_data(const COpsEventLogData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsEventLogData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsEventLogData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsEventLogData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsEventLogData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsEventLogData_rsp &a, COpsEventLogData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsEventLogData_rsp::COpsEventLogData_rsp(const COpsEventLogData_rsp& other994) {
  response = other994.response;
  data = other994.data;
  __isset = other994.__isset;
}
COpsEventLogData_rsp& COpsEventLogData_rsp::operator=(const COpsEventLogData_rsp& other995) {
  response = other995.response;
  data = other995.data;
  __isset = other995.__isset;
  return *this;
}
void COpsEventLogData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsEventLogData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COpsEventLogAllData_rsp::~COpsEventLogAllData_rsp() noexcept {
}


void COpsEventLogAllData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COpsEventLogAllData_rsp::__set_data(const COpsEventLogAllData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COpsEventLogAllData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COpsEventLogAllData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COpsEventLogAllData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COpsEventLogAllData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COpsEventLogAllData_rsp &a, COpsEventLogAllData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COpsEventLogAllData_rsp::COpsEventLogAllData_rsp(const COpsEventLogAllData_rsp& other996) {
  response = other996.response;
  data = other996.data;
  __isset = other996.__isset;
}
COpsEventLogAllData_rsp& COpsEventLogAllData_rsp::operator=(const COpsEventLogAllData_rsp& other997) {
  response = other997.response;
  data = other997.data;
  __isset = other997.__isset;
  return *this;
}
void COpsEventLogAllData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COpsEventLogAllData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CCvMuxStatusData_rsp::~CCvMuxStatusData_rsp() noexcept {
}


void CCvMuxStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CCvMuxStatusData_rsp::__set_data(const CCvMuxStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CCvMuxStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCvMuxStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCvMuxStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCvMuxStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCvMuxStatusData_rsp &a, CCvMuxStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CCvMuxStatusData_rsp::CCvMuxStatusData_rsp(const CCvMuxStatusData_rsp& other998) {
  response = other998.response;
  data = other998.data;
  __isset = other998.__isset;
}
CCvMuxStatusData_rsp& CCvMuxStatusData_rsp::operator=(const CCvMuxStatusData_rsp& other999) {
  response = other999.response;
  data = other999.data;
  __isset = other999.__isset;
  return *this;
}
void CCvMuxStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCvMuxStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CCvClientStatusData_rsp::~CCvClientStatusData_rsp() noexcept {
}


void CCvClientStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CCvClientStatusData_rsp::__set_data(const CCvClientStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CCvClientStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCvClientStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCvClientStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCvClientStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCvClientStatusData_rsp &a, CCvClientStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CCvClientStatusData_rsp::CCvClientStatusData_rsp(const CCvClientStatusData_rsp& other1000) {
  response = other1000.response;
  data = other1000.data;
  __isset = other1000.__isset;
}
CCvClientStatusData_rsp& CCvClientStatusData_rsp::operator=(const CCvClientStatusData_rsp& other1001) {
  response = other1001.response;
  data = other1001.data;
  __isset = other1001.__isset;
  return *this;
}
void CCvClientStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCvClientStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CCvRef_rsp::~CCvRef_rsp() noexcept {
}


void CCvRef_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CCvRef_rsp::__set_data(const CCvRef_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CCvRef_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCvRef_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCvRef_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCvRef_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCvRef_rsp &a, CCvRef_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CCvRef_rsp::CCvRef_rsp(const CCvRef_rsp& other1002) {
  response = other1002.response;
  data = other1002.data;
  __isset = other1002.__isset;
}
CCvRef_rsp& CCvRef_rsp::operator=(const CCvRef_rsp& other1003) {
  response = other1003.response;
  data = other1003.data;
  __isset = other1003.__isset;
  return *this;
}
void CCvRef_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCvRef_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcsConnection_rsp::~COcsConnection_rsp() noexcept {
}


void COcsConnection_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcsConnection_rsp::__set_data(const COcsConnection_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcsConnection_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsConnection_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsConnection_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsConnection_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsConnection_rsp &a, COcsConnection_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcsConnection_rsp::COcsConnection_rsp(const COcsConnection_rsp& other1004) {
  response = other1004.response;
  data = other1004.data;
  __isset = other1004.__isset;
}
COcsConnection_rsp& COcsConnection_rsp::operator=(const COcsConnection_rsp& other1005) {
  response = other1005.response;
  data = other1005.data;
  __isset = other1005.__isset;
  return *this;
}
void COcsConnection_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsConnection_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcsConnections_rsp::~COcsConnections_rsp() noexcept {
}


void COcsConnections_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcsConnections_rsp::__set_data(const COcsConnections_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcsConnections_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsConnections_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsConnections_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsConnections_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsConnections_rsp &a, COcsConnections_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcsConnections_rsp::COcsConnections_rsp(const COcsConnections_rsp& other1006) {
  response = other1006.response;
  data = other1006.data;
  __isset = other1006.__isset;
}
COcsConnections_rsp& COcsConnections_rsp::operator=(const COcsConnections_rsp& other1007) {
  response = other1007.response;
  data = other1007.data;
  __isset = other1007.__isset;
  return *this;
}
void COcsConnections_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsConnections_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcsAlarm_rsp::~COcsAlarm_rsp() noexcept {
}


void COcsAlarm_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcsAlarm_rsp::__set_data(const COcsAlarm_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcsAlarm_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsAlarm_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsAlarm_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsAlarm_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsAlarm_rsp &a, COcsAlarm_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcsAlarm_rsp::COcsAlarm_rsp(const COcsAlarm_rsp& other1008) {
  response = other1008.response;
  data = other1008.data;
  __isset = other1008.__isset;
}
COcsAlarm_rsp& COcsAlarm_rsp::operator=(const COcsAlarm_rsp& other1009) {
  response = other1009.response;
  data = other1009.data;
  __isset = other1009.__isset;
  return *this;
}
void COcsAlarm_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsAlarm_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcsLedSta_rsp::~COcsLedSta_rsp() noexcept {
}


void COcsLedSta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcsLedSta_rsp::__set_data(const COcsLedSta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcsLedSta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsLedSta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsLedSta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsLedSta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsLedSta_rsp &a, COcsLedSta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcsLedSta_rsp::COcsLedSta_rsp(const COcsLedSta_rsp& other1010) {
  response = other1010.response;
  data = other1010.data;
  __isset = other1010.__isset;
}
COcsLedSta_rsp& COcsLedSta_rsp::operator=(const COcsLedSta_rsp& other1011) {
  response = other1011.response;
  data = other1011.data;
  __isset = other1011.__isset;
  return *this;
}
void COcsLedSta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsLedSta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcsTempSta_rsp::~COcsTempSta_rsp() noexcept {
}


void COcsTempSta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcsTempSta_rsp::__set_data(const COcsTempSta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcsTempSta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsTempSta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsTempSta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsTempSta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsTempSta_rsp &a, COcsTempSta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcsTempSta_rsp::COcsTempSta_rsp(const COcsTempSta_rsp& other1012) {
  response = other1012.response;
  data = other1012.data;
  __isset = other1012.__isset;
}
COcsTempSta_rsp& COcsTempSta_rsp::operator=(const COcsTempSta_rsp& other1013) {
  response = other1013.response;
  data = other1013.data;
  __isset = other1013.__isset;
  return *this;
}
void COcsTempSta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsTempSta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcsStatusData_rsp::~COcsStatusData_rsp() noexcept {
}


void COcsStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcsStatusData_rsp::__set_data(const COcsStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcsStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsStatusData_rsp &a, COcsStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcsStatusData_rsp::COcsStatusData_rsp(const COcsStatusData_rsp& other1014) {
  response = other1014.response;
  data = other1014.data;
  __isset = other1014.__isset;
}
COcsStatusData_rsp& COcsStatusData_rsp::operator=(const COcsStatusData_rsp& other1015) {
  response = other1015.response;
  data = other1015.data;
  __isset = other1015.__isset;
  return *this;
}
void COcsStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


COcsCfgData_rsp::~COcsCfgData_rsp() noexcept {
}


void COcsCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void COcsCfgData_rsp::__set_data(const COcsCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const COcsCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t COcsCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t COcsCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("COcsCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(COcsCfgData_rsp &a, COcsCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

COcsCfgData_rsp::COcsCfgData_rsp(const COcsCfgData_rsp& other1016) {
  response = other1016.response;
  data = other1016.data;
  __isset = other1016.__isset;
}
COcsCfgData_rsp& COcsCfgData_rsp::operator=(const COcsCfgData_rsp& other1017) {
  response = other1017.response;
  data = other1017.data;
  __isset = other1017.__isset;
  return *this;
}
void COcsCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "COcsCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CSlotDevInfo_rsp::~CSlotDevInfo_rsp() noexcept {
}


void CSlotDevInfo_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CSlotDevInfo_rsp::__set_data(const CSlotDevInfo_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CSlotDevInfo_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CSlotDevInfo_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSlotDevInfo_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSlotDevInfo_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSlotDevInfo_rsp &a, CSlotDevInfo_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CSlotDevInfo_rsp::CSlotDevInfo_rsp(const CSlotDevInfo_rsp& other1018) {
  response = other1018.response;
  data = other1018.data;
  __isset = other1018.__isset;
}
CSlotDevInfo_rsp& CSlotDevInfo_rsp::operator=(const CSlotDevInfo_rsp& other1019) {
  response = other1019.response;
  data = other1019.data;
  __isset = other1019.__isset;
  return *this;
}
void CSlotDevInfo_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSlotDevInfo_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CSlotInfo_rsp::~CSlotInfo_rsp() noexcept {
}


void CSlotInfo_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CSlotInfo_rsp::__set_data(const CSlotInfo_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CSlotInfo_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CSlotInfo_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSlotInfo_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSlotInfo_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSlotInfo_rsp &a, CSlotInfo_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CSlotInfo_rsp::CSlotInfo_rsp(const CSlotInfo_rsp& other1020) {
  response = other1020.response;
  data = other1020.data;
  __isset = other1020.__isset;
}
CSlotInfo_rsp& CSlotInfo_rsp::operator=(const CSlotInfo_rsp& other1021) {
  response = other1021.response;
  data = other1021.data;
  __isset = other1021.__isset;
  return *this;
}
void CSlotInfo_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSlotInfo_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CSlotStatusData_rsp::~CSlotStatusData_rsp() noexcept {
}


void CSlotStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CSlotStatusData_rsp::__set_data(const CSlotStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CSlotStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CSlotStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSlotStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSlotStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSlotStatusData_rsp &a, CSlotStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CSlotStatusData_rsp::CSlotStatusData_rsp(const CSlotStatusData_rsp& other1022) {
  response = other1022.response;
  data = other1022.data;
  __isset = other1022.__isset;
}
CSlotStatusData_rsp& CSlotStatusData_rsp::operator=(const CSlotStatusData_rsp& other1023) {
  response = other1023.response;
  data = other1023.data;
  __isset = other1023.__isset;
  return *this;
}
void CSlotStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSlotStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CFanCfg_rsp::~CFanCfg_rsp() noexcept {
}


void CFanCfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CFanCfg_rsp::__set_data(const CFanCfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CFanCfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CFanCfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CFanCfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CFanCfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CFanCfg_rsp &a, CFanCfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CFanCfg_rsp::CFanCfg_rsp(const CFanCfg_rsp& other1024) {
  response = other1024.response;
  data = other1024.data;
  __isset = other1024.__isset;
}
CFanCfg_rsp& CFanCfg_rsp::operator=(const CFanCfg_rsp& other1025) {
  response = other1025.response;
  data = other1025.data;
  __isset = other1025.__isset;
  return *this;
}
void CFanCfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CFanCfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CFanSta_rsp::~CFanSta_rsp() noexcept {
}


void CFanSta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CFanSta_rsp::__set_data(const CFanSta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CFanSta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CFanSta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CFanSta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CFanSta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CFanSta_rsp &a, CFanSta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CFanSta_rsp::CFanSta_rsp(const CFanSta_rsp& other1026) {
  response = other1026.response;
  data = other1026.data;
  __isset = other1026.__isset;
}
CFanSta_rsp& CFanSta_rsp::operator=(const CFanSta_rsp& other1027) {
  response = other1027.response;
  data = other1027.data;
  __isset = other1027.__isset;
  return *this;
}
void CFanSta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CFanSta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CPowerCfg_rsp::~CPowerCfg_rsp() noexcept {
}


void CPowerCfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CPowerCfg_rsp::__set_data(const CPowerCfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CPowerCfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPowerCfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPowerCfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPowerCfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPowerCfg_rsp &a, CPowerCfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CPowerCfg_rsp::CPowerCfg_rsp(const CPowerCfg_rsp& other1028) {
  response = other1028.response;
  data = other1028.data;
  __isset = other1028.__isset;
}
CPowerCfg_rsp& CPowerCfg_rsp::operator=(const CPowerCfg_rsp& other1029) {
  response = other1029.response;
  data = other1029.data;
  __isset = other1029.__isset;
  return *this;
}
void CPowerCfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPowerCfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CPowerSta_rsp::~CPowerSta_rsp() noexcept {
}


void CPowerSta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CPowerSta_rsp::__set_data(const CPowerSta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CPowerSta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CPowerSta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CPowerSta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CPowerSta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CPowerSta_rsp &a, CPowerSta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CPowerSta_rsp::CPowerSta_rsp(const CPowerSta_rsp& other1030) {
  response = other1030.response;
  data = other1030.data;
  __isset = other1030.__isset;
}
CPowerSta_rsp& CPowerSta_rsp::operator=(const CPowerSta_rsp& other1031) {
  response = other1031.response;
  data = other1031.data;
  __isset = other1031.__isset;
  return *this;
}
void CPowerSta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CPowerSta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CBoardMfg_rsp::~CBoardMfg_rsp() noexcept {
}


void CBoardMfg_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CBoardMfg_rsp::__set_data(const CBoardMfg_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardMfg_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardMfg_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardMfg_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardMfg_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardMfg_rsp &a, CBoardMfg_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CBoardMfg_rsp::CBoardMfg_rsp(const CBoardMfg_rsp& other1032) {
  response = other1032.response;
  data = other1032.data;
  __isset = other1032.__isset;
}
CBoardMfg_rsp& CBoardMfg_rsp::operator=(const CBoardMfg_rsp& other1033) {
  response = other1033.response;
  data = other1033.data;
  __isset = other1033.__isset;
  return *this;
}
void CBoardMfg_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardMfg_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CBoardCfgData_rsp::~CBoardCfgData_rsp() noexcept {
}


void CBoardCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CBoardCfgData_rsp::__set_data(const CBoardCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardCfgData_rsp &a, CBoardCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CBoardCfgData_rsp::CBoardCfgData_rsp(const CBoardCfgData_rsp& other1034) {
  response = other1034.response;
  data = other1034.data;
  __isset = other1034.__isset;
}
CBoardCfgData_rsp& CBoardCfgData_rsp::operator=(const CBoardCfgData_rsp& other1035) {
  response = other1035.response;
  data = other1035.data;
  __isset = other1035.__isset;
  return *this;
}
void CBoardCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CBoardCali_rsp::~CBoardCali_rsp() noexcept {
}


void CBoardCali_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CBoardCali_rsp::__set_data(const CBoardCali_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardCali_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardCali_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardCali_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardCali_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardCali_rsp &a, CBoardCali_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CBoardCali_rsp::CBoardCali_rsp(const CBoardCali_rsp& other1036) {
  response = other1036.response;
  data = other1036.data;
  __isset = other1036.__isset;
}
CBoardCali_rsp& CBoardCali_rsp::operator=(const CBoardCali_rsp& other1037) {
  response = other1037.response;
  data = other1037.data;
  __isset = other1037.__isset;
  return *this;
}
void CBoardCali_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardCali_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CLtc4215Sta_rsp::~CLtc4215Sta_rsp() noexcept {
}


void CLtc4215Sta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CLtc4215Sta_rsp::__set_data(const CLtc4215Sta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CLtc4215Sta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CLtc4215Sta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLtc4215Sta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLtc4215Sta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLtc4215Sta_rsp &a, CLtc4215Sta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CLtc4215Sta_rsp::CLtc4215Sta_rsp(const CLtc4215Sta_rsp& other1038) {
  response = other1038.response;
  data = other1038.data;
  __isset = other1038.__isset;
}
CLtc4215Sta_rsp& CLtc4215Sta_rsp::operator=(const CLtc4215Sta_rsp& other1039) {
  response = other1039.response;
  data = other1039.data;
  __isset = other1039.__isset;
  return *this;
}
void CLtc4215Sta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLtc4215Sta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMax1139Sta_rsp::~CMax1139Sta_rsp() noexcept {
}


void CMax1139Sta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMax1139Sta_rsp::__set_data(const CMax1139Sta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMax1139Sta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMax1139Sta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMax1139Sta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMax1139Sta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMax1139Sta_rsp &a, CMax1139Sta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMax1139Sta_rsp::CMax1139Sta_rsp(const CMax1139Sta_rsp& other1040) {
  response = other1040.response;
  data = other1040.data;
  __isset = other1040.__isset;
}
CMax1139Sta_rsp& CMax1139Sta_rsp::operator=(const CMax1139Sta_rsp& other1041) {
  response = other1041.response;
  data = other1041.data;
  __isset = other1041.__isset;
  return *this;
}
void CMax1139Sta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMax1139Sta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CMp5023Sta_rsp::~CMp5023Sta_rsp() noexcept {
}


void CMp5023Sta_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CMp5023Sta_rsp::__set_data(const CMp5023Sta_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CMp5023Sta_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CMp5023Sta_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CMp5023Sta_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CMp5023Sta_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CMp5023Sta_rsp &a, CMp5023Sta_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CMp5023Sta_rsp::CMp5023Sta_rsp(const CMp5023Sta_rsp& other1042) {
  response = other1042.response;
  data = other1042.data;
  __isset = other1042.__isset;
}
CMp5023Sta_rsp& CMp5023Sta_rsp::operator=(const CMp5023Sta_rsp& other1043) {
  response = other1043.response;
  data = other1043.data;
  __isset = other1043.__isset;
  return *this;
}
void CMp5023Sta_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CMp5023Sta_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CBoardStatusData_rsp::~CBoardStatusData_rsp() noexcept {
}


void CBoardStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CBoardStatusData_rsp::__set_data(const CBoardStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardStatusData_rsp &a, CBoardStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CBoardStatusData_rsp::CBoardStatusData_rsp(const CBoardStatusData_rsp& other1044) {
  response = other1044.response;
  data = other1044.data;
  __isset = other1044.__isset;
}
CBoardStatusData_rsp& CBoardStatusData_rsp::operator=(const CBoardStatusData_rsp& other1045) {
  response = other1045.response;
  data = other1045.data;
  __isset = other1045.__isset;
  return *this;
}
void CBoardStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CBoardRealTimeData_rsp::~CBoardRealTimeData_rsp() noexcept {
}


void CBoardRealTimeData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CBoardRealTimeData_rsp::__set_data(const CBoardRealTimeData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CBoardRealTimeData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CBoardRealTimeData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CBoardRealTimeData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CBoardRealTimeData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CBoardRealTimeData_rsp &a, CBoardRealTimeData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CBoardRealTimeData_rsp::CBoardRealTimeData_rsp(const CBoardRealTimeData_rsp& other1046) {
  response = other1046.response;
  data = other1046.data;
  __isset = other1046.__isset;
}
CBoardRealTimeData_rsp& CBoardRealTimeData_rsp::operator=(const CBoardRealTimeData_rsp& other1047) {
  response = other1047.response;
  data = other1047.data;
  __isset = other1047.__isset;
  return *this;
}
void CBoardRealTimeData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CBoardRealTimeData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CTdcmStatusData_rsp::~CTdcmStatusData_rsp() noexcept {
}


void CTdcmStatusData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CTdcmStatusData_rsp::__set_data(const CTdcmStatusData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CTdcmStatusData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CTdcmStatusData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTdcmStatusData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTdcmStatusData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTdcmStatusData_rsp &a, CTdcmStatusData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CTdcmStatusData_rsp::CTdcmStatusData_rsp(const CTdcmStatusData_rsp& other1048) {
  response = other1048.response;
  data = other1048.data;
  __isset = other1048.__isset;
}
CTdcmStatusData_rsp& CTdcmStatusData_rsp::operator=(const CTdcmStatusData_rsp& other1049) {
  response = other1049.response;
  data = other1049.data;
  __isset = other1049.__isset;
  return *this;
}
void CTdcmStatusData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CTdcmStatusData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


CTdcmCfgData_rsp::~CTdcmCfgData_rsp() noexcept {
}


void CTdcmCfgData_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void CTdcmCfgData_rsp::__set_data(const CTdcmCfgData_t& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const CTdcmCfgData_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CTdcmCfgData_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTdcmCfgData_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTdcmCfgData_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTdcmCfgData_rsp &a, CTdcmCfgData_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

CTdcmCfgData_rsp::CTdcmCfgData_rsp(const CTdcmCfgData_rsp& other1050) {
  response = other1050.response;
  data = other1050.data;
  __isset = other1050.__isset;
}
CTdcmCfgData_rsp& CTdcmCfgData_rsp::operator=(const CTdcmCfgData_rsp& other1051) {
  response = other1051.response;
  data = other1051.data;
  __isset = other1051.__isset;
  return *this;
}
void CTdcmCfgData_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CTdcmCfgData_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


bool_rsp::~bool_rsp() noexcept {
}


void bool_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void bool_rsp::__set_data(const bool val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const bool_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t bool_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t bool_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("bool_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(bool_rsp &a, bool_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

bool_rsp::bool_rsp(const bool_rsp& other1052) {
  response = other1052.response;
  data = other1052.data;
  __isset = other1052.__isset;
}
bool_rsp& bool_rsp::operator=(const bool_rsp& other1053) {
  response = other1053.response;
  data = other1053.data;
  __isset = other1053.__isset;
  return *this;
}
void bool_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "bool_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


bool_list_rsp::~bool_list_rsp() noexcept {
}


void bool_list_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void bool_list_rsp::__set_data(const std::vector<bool> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const bool_list_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t bool_list_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size1054;
            ::apache::thrift::protocol::TType _etype1057;
            xfer += iprot->readListBegin(_etype1057, _size1054);
            this->data.resize(_size1054);
            uint32_t _i1058;
            for (_i1058 = 0; _i1058 < _size1054; ++_i1058)
            {
              xfer += iprot->readBool(this->data[_i1058]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t bool_list_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("bool_list_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->data.size()));
    std::vector<bool> ::const_iterator _iter1059;
    for (_iter1059 = this->data.begin(); _iter1059 != this->data.end(); ++_iter1059)
    {
      xfer += oprot->writeBool((*_iter1059));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(bool_list_rsp &a, bool_list_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

bool_list_rsp::bool_list_rsp(const bool_list_rsp& other1060) {
  response = other1060.response;
  data = other1060.data;
  __isset = other1060.__isset;
}
bool_list_rsp& bool_list_rsp::operator=(const bool_list_rsp& other1061) {
  response = other1061.response;
  data = other1061.data;
  __isset = other1061.__isset;
  return *this;
}
void bool_list_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "bool_list_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i8_rsp::~i8_rsp() noexcept {
}


void i8_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i8_rsp::__set_data(const int8_t val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i8_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i8_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i8_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i8_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i8_rsp &a, i8_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i8_rsp::i8_rsp(const i8_rsp& other1062) {
  response = other1062.response;
  data = other1062.data;
  __isset = other1062.__isset;
}
i8_rsp& i8_rsp::operator=(const i8_rsp& other1063) {
  response = other1063.response;
  data = other1063.data;
  __isset = other1063.__isset;
  return *this;
}
void i8_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i8_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i8_list_rsp::~i8_list_rsp() noexcept {
}


void i8_list_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i8_list_rsp::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i8_list_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i8_list_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i8_list_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i8_list_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i8_list_rsp &a, i8_list_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i8_list_rsp::i8_list_rsp(const i8_list_rsp& other1064) {
  response = other1064.response;
  data = other1064.data;
  __isset = other1064.__isset;
}
i8_list_rsp& i8_list_rsp::operator=(const i8_list_rsp& other1065) {
  response = other1065.response;
  data = other1065.data;
  __isset = other1065.__isset;
  return *this;
}
void i8_list_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i8_list_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i16_rsp::~i16_rsp() noexcept {
}


void i16_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i16_rsp::__set_data(const int16_t val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i16_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i16_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i16_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i16_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i16_rsp &a, i16_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i16_rsp::i16_rsp(const i16_rsp& other1066) {
  response = other1066.response;
  data = other1066.data;
  __isset = other1066.__isset;
}
i16_rsp& i16_rsp::operator=(const i16_rsp& other1067) {
  response = other1067.response;
  data = other1067.data;
  __isset = other1067.__isset;
  return *this;
}
void i16_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i16_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i16_list_rsp::~i16_list_rsp() noexcept {
}


void i16_list_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i16_list_rsp::__set_data(const std::vector<int16_t> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i16_list_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i16_list_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size1068;
            ::apache::thrift::protocol::TType _etype1071;
            xfer += iprot->readListBegin(_etype1071, _size1068);
            this->data.resize(_size1068);
            uint32_t _i1072;
            for (_i1072 = 0; _i1072 < _size1068; ++_i1072)
            {
              xfer += iprot->readI16(this->data[_i1072]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i16_list_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i16_list_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->data.size()));
    std::vector<int16_t> ::const_iterator _iter1073;
    for (_iter1073 = this->data.begin(); _iter1073 != this->data.end(); ++_iter1073)
    {
      xfer += oprot->writeI16((*_iter1073));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i16_list_rsp &a, i16_list_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i16_list_rsp::i16_list_rsp(const i16_list_rsp& other1074) {
  response = other1074.response;
  data = other1074.data;
  __isset = other1074.__isset;
}
i16_list_rsp& i16_list_rsp::operator=(const i16_list_rsp& other1075) {
  response = other1075.response;
  data = other1075.data;
  __isset = other1075.__isset;
  return *this;
}
void i16_list_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i16_list_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i32_rsp::~i32_rsp() noexcept {
}


void i32_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i32_rsp::__set_data(const int32_t val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i32_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i32_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i32_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i32_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i32_rsp &a, i32_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i32_rsp::i32_rsp(const i32_rsp& other1076) {
  response = other1076.response;
  data = other1076.data;
  __isset = other1076.__isset;
}
i32_rsp& i32_rsp::operator=(const i32_rsp& other1077) {
  response = other1077.response;
  data = other1077.data;
  __isset = other1077.__isset;
  return *this;
}
void i32_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i32_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i32_list_rsp::~i32_list_rsp() noexcept {
}


void i32_list_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i32_list_rsp::__set_data(const std::vector<int32_t> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i32_list_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i32_list_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size1078;
            ::apache::thrift::protocol::TType _etype1081;
            xfer += iprot->readListBegin(_etype1081, _size1078);
            this->data.resize(_size1078);
            uint32_t _i1082;
            for (_i1082 = 0; _i1082 < _size1078; ++_i1082)
            {
              xfer += iprot->readI32(this->data[_i1082]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i32_list_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i32_list_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->data.size()));
    std::vector<int32_t> ::const_iterator _iter1083;
    for (_iter1083 = this->data.begin(); _iter1083 != this->data.end(); ++_iter1083)
    {
      xfer += oprot->writeI32((*_iter1083));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i32_list_rsp &a, i32_list_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i32_list_rsp::i32_list_rsp(const i32_list_rsp& other1084) {
  response = other1084.response;
  data = other1084.data;
  __isset = other1084.__isset;
}
i32_list_rsp& i32_list_rsp::operator=(const i32_list_rsp& other1085) {
  response = other1085.response;
  data = other1085.data;
  __isset = other1085.__isset;
  return *this;
}
void i32_list_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i32_list_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i64_rsp::~i64_rsp() noexcept {
}


void i64_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i64_rsp::__set_data(const int64_t val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i64_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i64_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i64_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i64_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i64_rsp &a, i64_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i64_rsp::i64_rsp(const i64_rsp& other1086) {
  response = other1086.response;
  data = other1086.data;
  __isset = other1086.__isset;
}
i64_rsp& i64_rsp::operator=(const i64_rsp& other1087) {
  response = other1087.response;
  data = other1087.data;
  __isset = other1087.__isset;
  return *this;
}
void i64_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i64_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


i64_list_rsp::~i64_list_rsp() noexcept {
}


void i64_list_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void i64_list_rsp::__set_data(const std::vector<int64_t> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const i64_list_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t i64_list_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size1088;
            ::apache::thrift::protocol::TType _etype1091;
            xfer += iprot->readListBegin(_etype1091, _size1088);
            this->data.resize(_size1088);
            uint32_t _i1092;
            for (_i1092 = 0; _i1092 < _size1088; ++_i1092)
            {
              xfer += iprot->readI64(this->data[_i1092]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t i64_list_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("i64_list_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->data.size()));
    std::vector<int64_t> ::const_iterator _iter1093;
    for (_iter1093 = this->data.begin(); _iter1093 != this->data.end(); ++_iter1093)
    {
      xfer += oprot->writeI64((*_iter1093));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(i64_list_rsp &a, i64_list_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

i64_list_rsp::i64_list_rsp(const i64_list_rsp& other1094) {
  response = other1094.response;
  data = other1094.data;
  __isset = other1094.__isset;
}
i64_list_rsp& i64_list_rsp::operator=(const i64_list_rsp& other1095) {
  response = other1095.response;
  data = other1095.data;
  __isset = other1095.__isset;
  return *this;
}
void i64_list_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "i64_list_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


double_rsp::~double_rsp() noexcept {
}


void double_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void double_rsp::__set_data(const double val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const double_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t double_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t double_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("double_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(double_rsp &a, double_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

double_rsp::double_rsp(const double_rsp& other1096) {
  response = other1096.response;
  data = other1096.data;
  __isset = other1096.__isset;
}
double_rsp& double_rsp::operator=(const double_rsp& other1097) {
  response = other1097.response;
  data = other1097.data;
  __isset = other1097.__isset;
  return *this;
}
void double_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "double_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


double_list_rsp::~double_list_rsp() noexcept {
}


void double_list_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void double_list_rsp::__set_data(const std::vector<double> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const double_list_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t double_list_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size1098;
            ::apache::thrift::protocol::TType _etype1101;
            xfer += iprot->readListBegin(_etype1101, _size1098);
            this->data.resize(_size1098);
            uint32_t _i1102;
            for (_i1102 = 0; _i1102 < _size1098; ++_i1102)
            {
              xfer += iprot->readDouble(this->data[_i1102]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t double_list_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("double_list_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->data.size()));
    std::vector<double> ::const_iterator _iter1103;
    for (_iter1103 = this->data.begin(); _iter1103 != this->data.end(); ++_iter1103)
    {
      xfer += oprot->writeDouble((*_iter1103));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(double_list_rsp &a, double_list_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

double_list_rsp::double_list_rsp(const double_list_rsp& other1104) {
  response = other1104.response;
  data = other1104.data;
  __isset = other1104.__isset;
}
double_list_rsp& double_list_rsp::operator=(const double_list_rsp& other1105) {
  response = other1105.response;
  data = other1105.data;
  __isset = other1105.__isset;
  return *this;
}
void double_list_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "double_list_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


string_rsp::~string_rsp() noexcept {
}


void string_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void string_rsp::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const string_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t string_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t string_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("string_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(string_rsp &a, string_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

string_rsp::string_rsp(const string_rsp& other1106) {
  response = other1106.response;
  data = other1106.data;
  __isset = other1106.__isset;
}
string_rsp& string_rsp::operator=(const string_rsp& other1107) {
  response = other1107.response;
  data = other1107.data;
  __isset = other1107.__isset;
  return *this;
}
void string_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "string_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


string_list_rsp::~string_list_rsp() noexcept {
}


void string_list_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void string_list_rsp::__set_data(const std::vector<std::string> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const string_list_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t string_list_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size1108;
            ::apache::thrift::protocol::TType _etype1111;
            xfer += iprot->readListBegin(_etype1111, _size1108);
            this->data.resize(_size1108);
            uint32_t _i1112;
            for (_i1112 = 0; _i1112 < _size1108; ++_i1112)
            {
              xfer += iprot->readString(this->data[_i1112]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t string_list_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("string_list_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->data.size()));
    std::vector<std::string> ::const_iterator _iter1113;
    for (_iter1113 = this->data.begin(); _iter1113 != this->data.end(); ++_iter1113)
    {
      xfer += oprot->writeString((*_iter1113));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(string_list_rsp &a, string_list_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

string_list_rsp::string_list_rsp(const string_list_rsp& other1114) {
  response = other1114.response;
  data = other1114.data;
  __isset = other1114.__isset;
}
string_list_rsp& string_list_rsp::operator=(const string_list_rsp& other1115) {
  response = other1115.response;
  data = other1115.data;
  __isset = other1115.__isset;
  return *this;
}
void string_list_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "string_list_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


binary_rsp::~binary_rsp() noexcept {
}


void binary_rsp::__set_response(const int32_t val) {
  this->response = val;
}

void binary_rsp::__set_data(const std::string& val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const binary_rsp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t binary_rsp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->response);
          this->__isset.response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t binary_rsp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("binary_rsp");

  xfer += oprot->writeFieldBegin("response", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->response);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(binary_rsp &a, binary_rsp &b) {
  using ::std::swap;
  swap(a.response, b.response);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

binary_rsp::binary_rsp(const binary_rsp& other1116) {
  response = other1116.response;
  data = other1116.data;
  __isset = other1116.__isset;
}
binary_rsp& binary_rsp::operator=(const binary_rsp& other1117) {
  response = other1117.response;
  data = other1117.data;
  __isset = other1117.__isset;
  return *this;
}
void binary_rsp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "binary_rsp(";
  out << "response=" << to_string(response);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


