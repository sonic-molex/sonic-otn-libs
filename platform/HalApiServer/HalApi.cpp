/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "HalApi.h"




HalApi_BOARD_GetChassisMfg_args::~HalApi_BOARD_GetChassisMfg_args() noexcept {
}


uint32_t HalApi_BOARD_GetChassisMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetChassisMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisMfg_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisMfg_pargs::~HalApi_BOARD_GetChassisMfg_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetChassisMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisMfg_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisMfg_result::~HalApi_BOARD_GetChassisMfg_result() noexcept {
}


uint32_t HalApi_BOARD_GetChassisMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetChassisMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisMfg_presult::~HalApi_BOARD_GetChassisMfg_presult() noexcept {
}


uint32_t HalApi_BOARD_GetChassisMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetChassisMfg_args::~HalApi_BOARD_SetChassisMfg_args() noexcept {
}


uint32_t HalApi_BOARD_SetChassisMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisMfg_args");

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisMfg_pargs::~HalApi_BOARD_SetChassisMfg_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetChassisMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisMfg_pargs");

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisMfg_result::~HalApi_BOARD_SetChassisMfg_result() noexcept {
}


uint32_t HalApi_BOARD_SetChassisMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisMfg_presult::~HalApi_BOARD_SetChassisMfg_presult() noexcept {
}


uint32_t HalApi_BOARD_SetChassisMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetChassisConfigType_args::~HalApi_BOARD_SetChassisConfigType_args() noexcept {
}


uint32_t HalApi_BOARD_SetChassisConfigType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcConfigType);
          this->__isset.pcConfigType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisConfigType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisConfigType_args");

  xfer += oprot->writeFieldBegin("pcConfigType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pcConfigType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisConfigType_pargs::~HalApi_BOARD_SetChassisConfigType_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetChassisConfigType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisConfigType_pargs");

  xfer += oprot->writeFieldBegin("pcConfigType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->pcConfigType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisConfigType_result::~HalApi_BOARD_SetChassisConfigType_result() noexcept {
}


uint32_t HalApi_BOARD_SetChassisConfigType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisConfigType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisConfigType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisConfigType_presult::~HalApi_BOARD_SetChassisConfigType_presult() noexcept {
}


uint32_t HalApi_BOARD_SetChassisConfigType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetChassisCali_args::~HalApi_BOARD_GetChassisCali_args() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetChassisCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisCali_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisCali_pargs::~HalApi_BOARD_GetChassisCali_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisCali_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisCali_result::~HalApi_BOARD_GetChassisCali_result() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetChassisCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisCali_presult::~HalApi_BOARD_GetChassisCali_presult() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetChassisCali_args::~HalApi_BOARD_SetChassisCali_args() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisCali_args");

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisCali_pargs::~HalApi_BOARD_SetChassisCali_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisCali_pargs");

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisCali_result::~HalApi_BOARD_SetChassisCali_result() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisCali_presult::~HalApi_BOARD_SetChassisCali_presult() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetChassisCfg_args::~HalApi_BOARD_GetChassisCfg_args() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiAddrSlice);
          this->__isset.uiAddrSlice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetChassisCfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisCfg_args");

  xfer += oprot->writeFieldBegin("uiAddrSlice", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiAddrSlice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisCfg_pargs::~HalApi_BOARD_GetChassisCfg_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisCfg_pargs");

  xfer += oprot->writeFieldBegin("uiAddrSlice", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiAddrSlice)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisCfg_result::~HalApi_BOARD_GetChassisCfg_result() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetChassisCfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetChassisCfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetChassisCfg_presult::~HalApi_BOARD_GetChassisCfg_presult() noexcept {
}


uint32_t HalApi_BOARD_GetChassisCfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetChassisCfg_args::~HalApi_BOARD_SetChassisCfg_args() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiAddrSlice);
          this->__isset.uiAddrSlice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSize);
          this->__isset.uiSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisCfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisCfg_args");

  xfer += oprot->writeFieldBegin("uiAddrSlice", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiAddrSlice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisCfg_pargs::~HalApi_BOARD_SetChassisCfg_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisCfg_pargs");

  xfer += oprot->writeFieldBegin("uiAddrSlice", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiAddrSlice)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisCfg_result::~HalApi_BOARD_SetChassisCfg_result() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetChassisCfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetChassisCfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetChassisCfg_presult::~HalApi_BOARD_SetChassisCfg_presult() noexcept {
}


uint32_t HalApi_BOARD_SetChassisCfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetUpgInfo_args::~HalApi_BOARD_GetUpgInfo_args() noexcept {
}


uint32_t HalApi_BOARD_GetUpgInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetUpgInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetUpgInfo_args");

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetUpgInfo_pargs::~HalApi_BOARD_GetUpgInfo_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetUpgInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetUpgInfo_pargs");

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetUpgInfo_result::~HalApi_BOARD_GetUpgInfo_result() noexcept {
}


uint32_t HalApi_BOARD_GetUpgInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetUpgInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetUpgInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetUpgInfo_presult::~HalApi_BOARD_GetUpgInfo_presult() noexcept {
}


uint32_t HalApi_BOARD_GetUpgInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetUpgInfo_args::~HalApi_BOARD_SetUpgInfo_args() noexcept {
}


uint32_t HalApi_BOARD_SetUpgInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucBuf);
          this->__isset.pucBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetUpgInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetUpgInfo_args");

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->pucBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetUpgInfo_pargs::~HalApi_BOARD_SetUpgInfo_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetUpgInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetUpgInfo_pargs");

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->pucBuf)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetUpgInfo_result::~HalApi_BOARD_SetUpgInfo_result() noexcept {
}


uint32_t HalApi_BOARD_SetUpgInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetUpgInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetUpgInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetUpgInfo_presult::~HalApi_BOARD_SetUpgInfo_presult() noexcept {
}


uint32_t HalApi_BOARD_SetUpgInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetBdlHead_args::~HalApi_BOARD_GetBdlHead_args() noexcept {
}


uint32_t HalApi_BOARD_GetBdlHead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetBdlHead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetBdlHead_args");

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetBdlHead_pargs::~HalApi_BOARD_GetBdlHead_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetBdlHead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetBdlHead_pargs");

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetBdlHead_result::~HalApi_BOARD_GetBdlHead_result() noexcept {
}


uint32_t HalApi_BOARD_GetBdlHead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetBdlHead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetBdlHead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetBdlHead_presult::~HalApi_BOARD_GetBdlHead_presult() noexcept {
}


uint32_t HalApi_BOARD_GetBdlHead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetBdlHead_args::~HalApi_BOARD_SetBdlHead_args() noexcept {
}


uint32_t HalApi_BOARD_SetBdlHead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucBuf);
          this->__isset.pucBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetBdlHead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetBdlHead_args");

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->pucBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetBdlHead_pargs::~HalApi_BOARD_SetBdlHead_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetBdlHead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetBdlHead_pargs");

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary((*(this->pucBuf)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetBdlHead_result::~HalApi_BOARD_SetBdlHead_result() noexcept {
}


uint32_t HalApi_BOARD_SetBdlHead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetBdlHead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetBdlHead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetBdlHead_presult::~HalApi_BOARD_SetBdlHead_presult() noexcept {
}


uint32_t HalApi_BOARD_SetBdlHead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetStatusData_args::~HalApi_BOARD_GetStatusData_args() noexcept {
}


uint32_t HalApi_BOARD_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetStatusData_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetStatusData_pargs::~HalApi_BOARD_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetStatusData_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetStatusData_result::~HalApi_BOARD_GetStatusData_result() noexcept {
}


uint32_t HalApi_BOARD_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetStatusData_presult::~HalApi_BOARD_GetStatusData_presult() noexcept {
}


uint32_t HalApi_BOARD_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetSccMfg_args::~HalApi_BOARD_GetSccMfg_args() noexcept {
}


uint32_t HalApi_BOARD_GetSccMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetSccMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetSccMfg_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetSccMfg_pargs::~HalApi_BOARD_GetSccMfg_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetSccMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetSccMfg_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetSccMfg_result::~HalApi_BOARD_GetSccMfg_result() noexcept {
}


uint32_t HalApi_BOARD_GetSccMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetSccMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetSccMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetSccMfg_presult::~HalApi_BOARD_GetSccMfg_presult() noexcept {
}


uint32_t HalApi_BOARD_GetSccMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetSccMfg_args::~HalApi_BOARD_SetSccMfg_args() noexcept {
}


uint32_t HalApi_BOARD_SetSccMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetSccMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetSccMfg_args");

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetSccMfg_pargs::~HalApi_BOARD_SetSccMfg_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetSccMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetSccMfg_pargs");

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetSccMfg_result::~HalApi_BOARD_SetSccMfg_result() noexcept {
}


uint32_t HalApi_BOARD_SetSccMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetSccMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetSccMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetSccMfg_presult::~HalApi_BOARD_SetSccMfg_presult() noexcept {
}


uint32_t HalApi_BOARD_SetSccMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetResetType_args::~HalApi_BOARD_SetResetType_args() noexcept {
}


uint32_t HalApi_BOARD_SetResetType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetResetType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetResetType_args");

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetResetType_pargs::~HalApi_BOARD_SetResetType_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetResetType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetResetType_pargs");

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetResetType_result::~HalApi_BOARD_SetResetType_result() noexcept {
}


uint32_t HalApi_BOARD_SetResetType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetResetType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetResetType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetResetType_presult::~HalApi_BOARD_SetResetType_presult() noexcept {
}


uint32_t HalApi_BOARD_SetResetType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetResetType_args::~HalApi_BOARD_GetResetType_args() noexcept {
}


uint32_t HalApi_BOARD_GetResetType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIndex);
          this->__isset.iIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetResetType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetResetType_args");

  xfer += oprot->writeFieldBegin("iIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetResetType_pargs::~HalApi_BOARD_GetResetType_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetResetType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetResetType_pargs");

  xfer += oprot->writeFieldBegin("iIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetResetType_result::~HalApi_BOARD_GetResetType_result() noexcept {
}


uint32_t HalApi_BOARD_GetResetType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetResetType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetResetType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetResetType_presult::~HalApi_BOARD_GetResetType_presult() noexcept {
}


uint32_t HalApi_BOARD_GetResetType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_CfgWatchDogTime_args::~HalApi_BOARD_CfgWatchDogTime_args() noexcept {
}


uint32_t HalApi_BOARD_CfgWatchDogTime_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucTimeout);
          this->__isset.ucTimeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_CfgWatchDogTime_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_CfgWatchDogTime_args");

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucTimeout", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucTimeout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_CfgWatchDogTime_pargs::~HalApi_BOARD_CfgWatchDogTime_pargs() noexcept {
}


uint32_t HalApi_BOARD_CfgWatchDogTime_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_CfgWatchDogTime_pargs");

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucTimeout", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucTimeout)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_CfgWatchDogTime_result::~HalApi_BOARD_CfgWatchDogTime_result() noexcept {
}


uint32_t HalApi_BOARD_CfgWatchDogTime_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_CfgWatchDogTime_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_CfgWatchDogTime_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_CfgWatchDogTime_presult::~HalApi_BOARD_CfgWatchDogTime_presult() noexcept {
}


uint32_t HalApi_BOARD_CfgWatchDogTime_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetApsdStatus_args::~HalApi_BOARD_GetApsdStatus_args() noexcept {
}


uint32_t HalApi_BOARD_GetApsdStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIndex);
          this->__isset.iIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetApsdStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetApsdStatus_args");

  xfer += oprot->writeFieldBegin("iIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetApsdStatus_pargs::~HalApi_BOARD_GetApsdStatus_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetApsdStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetApsdStatus_pargs");

  xfer += oprot->writeFieldBegin("iIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetApsdStatus_result::~HalApi_BOARD_GetApsdStatus_result() noexcept {
}


uint32_t HalApi_BOARD_GetApsdStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetApsdStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetApsdStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetApsdStatus_presult::~HalApi_BOARD_GetApsdStatus_presult() noexcept {
}


uint32_t HalApi_BOARD_GetApsdStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetLedState_args::~HalApi_BOARD_SetLedState_args() noexcept {
}


uint32_t HalApi_BOARD_SetLedState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiState);
          this->__isset.uiState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetLedState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetLedState_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetLedState_pargs::~HalApi_BOARD_SetLedState_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetLedState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetLedState_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiState)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetLedState_result::~HalApi_BOARD_SetLedState_result() noexcept {
}


uint32_t HalApi_BOARD_SetLedState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetLedState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetLedState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetLedState_presult::~HalApi_BOARD_SetLedState_presult() noexcept {
}


uint32_t HalApi_BOARD_SetLedState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_ResetLogic_args::~HalApi_BOARD_ResetLogic_args() noexcept {
}


uint32_t HalApi_BOARD_ResetLogic_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_ResetLogic_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_ResetLogic_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_ResetLogic_pargs::~HalApi_BOARD_ResetLogic_pargs() noexcept {
}


uint32_t HalApi_BOARD_ResetLogic_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_ResetLogic_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_ResetLogic_result::~HalApi_BOARD_ResetLogic_result() noexcept {
}


uint32_t HalApi_BOARD_ResetLogic_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_ResetLogic_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_ResetLogic_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_ResetLogic_presult::~HalApi_BOARD_ResetLogic_presult() noexcept {
}


uint32_t HalApi_BOARD_ResetLogic_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_UpgradeLogic_args::~HalApi_BOARD_UpgradeLogic_args() noexcept {
}


uint32_t HalApi_BOARD_UpgradeLogic_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_UpgradeLogic_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_UpgradeLogic_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_UpgradeLogic_pargs::~HalApi_BOARD_UpgradeLogic_pargs() noexcept {
}


uint32_t HalApi_BOARD_UpgradeLogic_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_UpgradeLogic_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_UpgradeLogic_result::~HalApi_BOARD_UpgradeLogic_result() noexcept {
}


uint32_t HalApi_BOARD_UpgradeLogic_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_UpgradeLogic_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_UpgradeLogic_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_UpgradeLogic_presult::~HalApi_BOARD_UpgradeLogic_presult() noexcept {
}


uint32_t HalApi_BOARD_UpgradeLogic_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetUpgadeStatus_args::~HalApi_BOARD_GetUpgadeStatus_args() noexcept {
}


uint32_t HalApi_BOARD_GetUpgadeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetUpgadeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetUpgadeStatus_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetUpgadeStatus_pargs::~HalApi_BOARD_GetUpgadeStatus_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetUpgadeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetUpgadeStatus_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetUpgadeStatus_result::~HalApi_BOARD_GetUpgadeStatus_result() noexcept {
}


uint32_t HalApi_BOARD_GetUpgadeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetUpgadeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetUpgadeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetUpgadeStatus_presult::~HalApi_BOARD_GetUpgadeStatus_presult() noexcept {
}


uint32_t HalApi_BOARD_GetUpgadeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_FAN_GetMfg_args::~HalApi_FAN_GetMfg_args() noexcept {
}


uint32_t HalApi_FAN_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_GetMfg_pargs::~HalApi_FAN_GetMfg_pargs() noexcept {
}


uint32_t HalApi_FAN_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_GetMfg_result::~HalApi_FAN_GetMfg_result() noexcept {
}


uint32_t HalApi_FAN_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_FAN_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_GetMfg_presult::~HalApi_FAN_GetMfg_presult() noexcept {
}


uint32_t HalApi_FAN_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_FAN_SetMfg_args::~HalApi_FAN_SetMfg_args() noexcept {
}


uint32_t HalApi_FAN_SetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetMfg_pargs::~HalApi_FAN_SetMfg_pargs() noexcept {
}


uint32_t HalApi_FAN_SetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetMfg_result::~HalApi_FAN_SetMfg_result() noexcept {
}


uint32_t HalApi_FAN_SetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_FAN_SetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetMfg_presult::~HalApi_FAN_SetMfg_presult() noexcept {
}


uint32_t HalApi_FAN_SetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_FAN_SetSpeed_args::~HalApi_FAN_SetSpeed_args() noexcept {
}


uint32_t HalApi_FAN_SetSpeed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDuty);
          this->__isset.uiDuty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetSpeed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetSpeed_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiDuty", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiDuty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetSpeed_pargs::~HalApi_FAN_SetSpeed_pargs() noexcept {
}


uint32_t HalApi_FAN_SetSpeed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetSpeed_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiDuty", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiDuty)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetSpeed_result::~HalApi_FAN_SetSpeed_result() noexcept {
}


uint32_t HalApi_FAN_SetSpeed_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetSpeed_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_FAN_SetSpeed_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetSpeed_presult::~HalApi_FAN_SetSpeed_presult() noexcept {
}


uint32_t HalApi_FAN_SetSpeed_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_FAN_SetControllerEEP_args::~HalApi_FAN_SetControllerEEP_args() noexcept {
}


uint32_t HalApi_FAN_SetControllerEEP_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetControllerEEP_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetControllerEEP_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetControllerEEP_pargs::~HalApi_FAN_SetControllerEEP_pargs() noexcept {
}


uint32_t HalApi_FAN_SetControllerEEP_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetControllerEEP_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetControllerEEP_result::~HalApi_FAN_SetControllerEEP_result() noexcept {
}


uint32_t HalApi_FAN_SetControllerEEP_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetControllerEEP_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_FAN_SetControllerEEP_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetControllerEEP_presult::~HalApi_FAN_SetControllerEEP_presult() noexcept {
}


uint32_t HalApi_FAN_SetControllerEEP_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_FAN_SetLed_args::~HalApi_FAN_SetLed_args() noexcept {
}


uint32_t HalApi_FAN_SetLed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiValue);
          this->__isset.uiValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetLed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetLed_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiValue", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetLed_pargs::~HalApi_FAN_SetLed_pargs() noexcept {
}


uint32_t HalApi_FAN_SetLed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_FAN_SetLed_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiValue", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiValue)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetLed_result::~HalApi_FAN_SetLed_result() noexcept {
}


uint32_t HalApi_FAN_SetLed_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_FAN_SetLed_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_FAN_SetLed_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_FAN_SetLed_presult::~HalApi_FAN_SetLed_presult() noexcept {
}


uint32_t HalApi_FAN_SetLed_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_POWER_GetMfg_args::~HalApi_POWER_GetMfg_args() noexcept {
}


uint32_t HalApi_POWER_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_POWER_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_POWER_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_POWER_GetMfg_pargs::~HalApi_POWER_GetMfg_pargs() noexcept {
}


uint32_t HalApi_POWER_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_POWER_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_POWER_GetMfg_result::~HalApi_POWER_GetMfg_result() noexcept {
}


uint32_t HalApi_POWER_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_POWER_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_POWER_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_POWER_GetMfg_presult::~HalApi_POWER_GetMfg_presult() noexcept {
}


uint32_t HalApi_POWER_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetProductName_args::~HalApi_BOARD_GetProductName_args() noexcept {
}


uint32_t HalApi_BOARD_GetProductName_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nSize);
          this->__isset.nSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetProductName_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetProductName_args");

  xfer += oprot->writeFieldBegin("nSize", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->nSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetProductName_pargs::~HalApi_BOARD_GetProductName_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetProductName_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetProductName_pargs");

  xfer += oprot->writeFieldBegin("nSize", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->nSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetProductName_result::~HalApi_BOARD_GetProductName_result() noexcept {
}


uint32_t HalApi_BOARD_GetProductName_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetProductName_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetProductName_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetProductName_presult::~HalApi_BOARD_GetProductName_presult() noexcept {
}


uint32_t HalApi_BOARD_GetProductName_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetConfigType_args::~HalApi_BOARD_GetConfigType_args() noexcept {
}


uint32_t HalApi_BOARD_GetConfigType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nSize);
          this->__isset.nSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetConfigType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetConfigType_args");

  xfer += oprot->writeFieldBegin("nSize", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->nSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetConfigType_pargs::~HalApi_BOARD_GetConfigType_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetConfigType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetConfigType_pargs");

  xfer += oprot->writeFieldBegin("nSize", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->nSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetConfigType_result::~HalApi_BOARD_GetConfigType_result() noexcept {
}


uint32_t HalApi_BOARD_GetConfigType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetConfigType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetConfigType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetConfigType_presult::~HalApi_BOARD_GetConfigType_presult() noexcept {
}


uint32_t HalApi_BOARD_GetConfigType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_GetProductType_args::~HalApi_BOARD_GetProductType_args() noexcept {
}


uint32_t HalApi_BOARD_GetProductType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetProductType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetProductType_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetProductType_pargs::~HalApi_BOARD_GetProductType_pargs() noexcept {
}


uint32_t HalApi_BOARD_GetProductType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_GetProductType_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetProductType_result::~HalApi_BOARD_GetProductType_result() noexcept {
}


uint32_t HalApi_BOARD_GetProductType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_GetProductType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_GetProductType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_GetProductType_presult::~HalApi_BOARD_GetProductType_presult() noexcept {
}


uint32_t HalApi_BOARD_GetProductType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_SetLogLevel_args::~HalApi_BOARD_SetLogLevel_args() noexcept {
}


uint32_t HalApi_BOARD_SetLogLevel_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLogLevel);
          this->__isset.uiLogLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetLogLevel_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetLogLevel_args");

  xfer += oprot->writeFieldBegin("uiLogLevel", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiLogLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetLogLevel_pargs::~HalApi_BOARD_SetLogLevel_pargs() noexcept {
}


uint32_t HalApi_BOARD_SetLogLevel_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_SetLogLevel_pargs");

  xfer += oprot->writeFieldBegin("uiLogLevel", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiLogLevel)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetLogLevel_result::~HalApi_BOARD_SetLogLevel_result() noexcept {
}


uint32_t HalApi_BOARD_SetLogLevel_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_SetLogLevel_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_SetLogLevel_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_SetLogLevel_presult::~HalApi_BOARD_SetLogLevel_presult() noexcept {
}


uint32_t HalApi_BOARD_SetLogLevel_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_BOARD_ConvertDevType_args::~HalApi_BOARD_ConvertDevType_args() noexcept {
}


uint32_t HalApi_BOARD_ConvertDevType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcName);
          this->__isset.pcName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_ConvertDevType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_ConvertDevType_args");

  xfer += oprot->writeFieldBegin("pcName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pcName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_ConvertDevType_pargs::~HalApi_BOARD_ConvertDevType_pargs() noexcept {
}


uint32_t HalApi_BOARD_ConvertDevType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_BOARD_ConvertDevType_pargs");

  xfer += oprot->writeFieldBegin("pcName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->pcName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_ConvertDevType_result::~HalApi_BOARD_ConvertDevType_result() noexcept {
}


uint32_t HalApi_BOARD_ConvertDevType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_BOARD_ConvertDevType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_BOARD_ConvertDevType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_BOARD_ConvertDevType_presult::~HalApi_BOARD_ConvertDevType_presult() noexcept {
}


uint32_t HalApi_BOARD_ConvertDevType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_Cv_GetMuxStatusData_args::~HalApi_Cv_GetMuxStatusData_args() noexcept {
}


uint32_t HalApi_Cv_GetMuxStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->enCvLine);
          this->__isset.enCvLine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_Cv_GetMuxStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_Cv_GetMuxStatusData_args");

  xfer += oprot->writeFieldBegin("enCvLine", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->enCvLine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetMuxStatusData_pargs::~HalApi_Cv_GetMuxStatusData_pargs() noexcept {
}


uint32_t HalApi_Cv_GetMuxStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_Cv_GetMuxStatusData_pargs");

  xfer += oprot->writeFieldBegin("enCvLine", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->enCvLine)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetMuxStatusData_result::~HalApi_Cv_GetMuxStatusData_result() noexcept {
}


uint32_t HalApi_Cv_GetMuxStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_Cv_GetMuxStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_Cv_GetMuxStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetMuxStatusData_presult::~HalApi_Cv_GetMuxStatusData_presult() noexcept {
}


uint32_t HalApi_Cv_GetMuxStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_Cv_GetClientStatusData_args::~HalApi_Cv_GetClientStatusData_args() noexcept {
}


uint32_t HalApi_Cv_GetClientStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->enCvLine);
          this->__isset.enCvLine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_Cv_GetClientStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_Cv_GetClientStatusData_args");

  xfer += oprot->writeFieldBegin("enCvLine", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->enCvLine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetClientStatusData_pargs::~HalApi_Cv_GetClientStatusData_pargs() noexcept {
}


uint32_t HalApi_Cv_GetClientStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_Cv_GetClientStatusData_pargs");

  xfer += oprot->writeFieldBegin("enCvLine", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->enCvLine)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetClientStatusData_result::~HalApi_Cv_GetClientStatusData_result() noexcept {
}


uint32_t HalApi_Cv_GetClientStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_Cv_GetClientStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_Cv_GetClientStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetClientStatusData_presult::~HalApi_Cv_GetClientStatusData_presult() noexcept {
}


uint32_t HalApi_Cv_GetClientStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_Cv_GetRef_args::~HalApi_Cv_GetRef_args() noexcept {
}


uint32_t HalApi_Cv_GetRef_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_Cv_GetRef_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_Cv_GetRef_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetRef_pargs::~HalApi_Cv_GetRef_pargs() noexcept {
}


uint32_t HalApi_Cv_GetRef_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_Cv_GetRef_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetRef_result::~HalApi_Cv_GetRef_result() noexcept {
}


uint32_t HalApi_Cv_GetRef_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_Cv_GetRef_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_Cv_GetRef_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_Cv_GetRef_presult::~HalApi_Cv_GetRef_presult() noexcept {
}


uint32_t HalApi_Cv_GetRef_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_ReadLogicReg_args::~HalApi_DBG_ReadLogicReg_args() noexcept {
}


uint32_t HalApi_DBG_ReadLogicReg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ReadLogicReg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ReadLogicReg_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadLogicReg_pargs::~HalApi_DBG_ReadLogicReg_pargs() noexcept {
}


uint32_t HalApi_DBG_ReadLogicReg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ReadLogicReg_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadLogicReg_result::~HalApi_DBG_ReadLogicReg_result() noexcept {
}


uint32_t HalApi_DBG_ReadLogicReg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ReadLogicReg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_ReadLogicReg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadLogicReg_presult::~HalApi_DBG_ReadLogicReg_presult() noexcept {
}


uint32_t HalApi_DBG_ReadLogicReg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_WriteLogicReg_args::~HalApi_DBG_WriteLogicReg_args() noexcept {
}


uint32_t HalApi_DBG_WriteLogicReg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucVal);
          this->__isset.pucVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_WriteLogicReg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_WriteLogicReg_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->pucVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteLogicReg_pargs::~HalApi_DBG_WriteLogicReg_pargs() noexcept {
}


uint32_t HalApi_DBG_WriteLogicReg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_WriteLogicReg_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->pucVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteLogicReg_result::~HalApi_DBG_WriteLogicReg_result() noexcept {
}


uint32_t HalApi_DBG_WriteLogicReg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_WriteLogicReg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_WriteLogicReg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteLogicReg_presult::~HalApi_DBG_WriteLogicReg_presult() noexcept {
}


uint32_t HalApi_DBG_WriteLogicReg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_ReadLogicRegSlc_args::~HalApi_DBG_ReadLogicRegSlc_args() noexcept {
}


uint32_t HalApi_DBG_ReadLogicRegSlc_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ReadLogicRegSlc_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ReadLogicRegSlc_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadLogicRegSlc_pargs::~HalApi_DBG_ReadLogicRegSlc_pargs() noexcept {
}


uint32_t HalApi_DBG_ReadLogicRegSlc_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ReadLogicRegSlc_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadLogicRegSlc_result::~HalApi_DBG_ReadLogicRegSlc_result() noexcept {
}


uint32_t HalApi_DBG_ReadLogicRegSlc_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ReadLogicRegSlc_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_ReadLogicRegSlc_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadLogicRegSlc_presult::~HalApi_DBG_ReadLogicRegSlc_presult() noexcept {
}


uint32_t HalApi_DBG_ReadLogicRegSlc_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_WriteLogicRegSlc_args::~HalApi_DBG_WriteLogicRegSlc_args() noexcept {
}


uint32_t HalApi_DBG_WriteLogicRegSlc_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucVal);
          this->__isset.pucVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_WriteLogicRegSlc_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_WriteLogicRegSlc_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->pucVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteLogicRegSlc_pargs::~HalApi_DBG_WriteLogicRegSlc_pargs() noexcept {
}


uint32_t HalApi_DBG_WriteLogicRegSlc_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_WriteLogicRegSlc_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->pucVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteLogicRegSlc_result::~HalApi_DBG_WriteLogicRegSlc_result() noexcept {
}


uint32_t HalApi_DBG_WriteLogicRegSlc_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_WriteLogicRegSlc_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_WriteLogicRegSlc_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteLogicRegSlc_presult::~HalApi_DBG_WriteLogicRegSlc_presult() noexcept {
}


uint32_t HalApi_DBG_WriteLogicRegSlc_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_LoopEnable_args::~HalApi_DBG_LoopEnable_args() noexcept {
}


uint32_t HalApi_DBG_LoopEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_LoopEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_LoopEnable_args");

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_LoopEnable_pargs::~HalApi_DBG_LoopEnable_pargs() noexcept {
}


uint32_t HalApi_DBG_LoopEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_LoopEnable_pargs");

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_LoopEnable_result::~HalApi_DBG_LoopEnable_result() noexcept {
}


uint32_t HalApi_DBG_LoopEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_LoopEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_LoopEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_LoopEnable_presult::~HalApi_DBG_LoopEnable_presult() noexcept {
}


uint32_t HalApi_DBG_LoopEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_LoopInterval_args::~HalApi_DBG_LoopInterval_args() noexcept {
}


uint32_t HalApi_DBG_LoopInterval_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiInterval);
          this->__isset.uiInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_LoopInterval_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_LoopInterval_args");

  xfer += oprot->writeFieldBegin("uiInterval", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_LoopInterval_pargs::~HalApi_DBG_LoopInterval_pargs() noexcept {
}


uint32_t HalApi_DBG_LoopInterval_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_LoopInterval_pargs");

  xfer += oprot->writeFieldBegin("uiInterval", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiInterval)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_LoopInterval_result::~HalApi_DBG_LoopInterval_result() noexcept {
}


uint32_t HalApi_DBG_LoopInterval_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_LoopInterval_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_LoopInterval_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_LoopInterval_presult::~HalApi_DBG_LoopInterval_presult() noexcept {
}


uint32_t HalApi_DBG_LoopInterval_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_IdleEnable_args::~HalApi_DBG_IdleEnable_args() noexcept {
}


uint32_t HalApi_DBG_IdleEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_IdleEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_IdleEnable_args");

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_IdleEnable_pargs::~HalApi_DBG_IdleEnable_pargs() noexcept {
}


uint32_t HalApi_DBG_IdleEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_IdleEnable_pargs");

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_IdleEnable_result::~HalApi_DBG_IdleEnable_result() noexcept {
}


uint32_t HalApi_DBG_IdleEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_IdleEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_IdleEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_IdleEnable_presult::~HalApi_DBG_IdleEnable_presult() noexcept {
}


uint32_t HalApi_DBG_IdleEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_ApsdEnable_args::~HalApi_DBG_ApsdEnable_args() noexcept {
}


uint32_t HalApi_DBG_ApsdEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIndex);
          this->__isset.iIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ApsdEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ApsdEnable_args");

  xfer += oprot->writeFieldBegin("iIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ApsdEnable_pargs::~HalApi_DBG_ApsdEnable_pargs() noexcept {
}


uint32_t HalApi_DBG_ApsdEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ApsdEnable_pargs");

  xfer += oprot->writeFieldBegin("iIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ApsdEnable_result::~HalApi_DBG_ApsdEnable_result() noexcept {
}


uint32_t HalApi_DBG_ApsdEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ApsdEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_ApsdEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ApsdEnable_presult::~HalApi_DBG_ApsdEnable_presult() noexcept {
}


uint32_t HalApi_DBG_ApsdEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_GetAprStatus_args::~HalApi_DBG_GetAprStatus_args() noexcept {
}


uint32_t HalApi_DBG_GetAprStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIndex);
          this->__isset.uiIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_GetAprStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_GetAprStatus_args");

  xfer += oprot->writeFieldBegin("uiIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_GetAprStatus_pargs::~HalApi_DBG_GetAprStatus_pargs() noexcept {
}


uint32_t HalApi_DBG_GetAprStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_GetAprStatus_pargs");

  xfer += oprot->writeFieldBegin("uiIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIndex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_GetAprStatus_result::~HalApi_DBG_GetAprStatus_result() noexcept {
}


uint32_t HalApi_DBG_GetAprStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_GetAprStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_GetAprStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_GetAprStatus_presult::~HalApi_DBG_GetAprStatus_presult() noexcept {
}


uint32_t HalApi_DBG_GetAprStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_SpiSendCommand_args::~HalApi_DBG_SpiSendCommand_args() noexcept {
}


uint32_t HalApi_DBG_SpiSendCommand_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulChip);
          this->__isset.ulChip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucBufW);
          this->__isset.pucBufW = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SpiSendCommand_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SpiSendCommand_args");

  xfer += oprot->writeFieldBegin("ulChip", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulChip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBufW", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pucBufW);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiSendCommand_pargs::~HalApi_DBG_SpiSendCommand_pargs() noexcept {
}


uint32_t HalApi_DBG_SpiSendCommand_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SpiSendCommand_pargs");

  xfer += oprot->writeFieldBegin("ulChip", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulChip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBufW", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->pucBufW)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiSendCommand_result::~HalApi_DBG_SpiSendCommand_result() noexcept {
}


uint32_t HalApi_DBG_SpiSendCommand_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SpiSendCommand_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_SpiSendCommand_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiSendCommand_presult::~HalApi_DBG_SpiSendCommand_presult() noexcept {
}


uint32_t HalApi_DBG_SpiSendCommand_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_SpiFlashRead_args::~HalApi_DBG_SpiFlashRead_args() noexcept {
}


uint32_t HalApi_DBG_SpiFlashRead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulChip);
          this->__isset.ulChip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SpiFlashRead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SpiFlashRead_args");

  xfer += oprot->writeFieldBegin("ulChip", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ulChip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiFlashRead_pargs::~HalApi_DBG_SpiFlashRead_pargs() noexcept {
}


uint32_t HalApi_DBG_SpiFlashRead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SpiFlashRead_pargs");

  xfer += oprot->writeFieldBegin("ulChip", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->ulChip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiFlashRead_result::~HalApi_DBG_SpiFlashRead_result() noexcept {
}


uint32_t HalApi_DBG_SpiFlashRead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SpiFlashRead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_SpiFlashRead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiFlashRead_presult::~HalApi_DBG_SpiFlashRead_presult() noexcept {
}


uint32_t HalApi_DBG_SpiFlashRead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_SpiFlashWrite_args::~HalApi_DBG_SpiFlashWrite_args() noexcept {
}


uint32_t HalApi_DBG_SpiFlashWrite_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulChip);
          this->__isset.ulChip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucVal);
          this->__isset.pucVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SpiFlashWrite_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SpiFlashWrite_args");

  xfer += oprot->writeFieldBegin("ulChip", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ulChip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->pucVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiFlashWrite_pargs::~HalApi_DBG_SpiFlashWrite_pargs() noexcept {
}


uint32_t HalApi_DBG_SpiFlashWrite_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SpiFlashWrite_pargs");

  xfer += oprot->writeFieldBegin("ulChip", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64((*(this->ulChip)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->pucVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiFlashWrite_result::~HalApi_DBG_SpiFlashWrite_result() noexcept {
}


uint32_t HalApi_DBG_SpiFlashWrite_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SpiFlashWrite_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_SpiFlashWrite_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SpiFlashWrite_presult::~HalApi_DBG_SpiFlashWrite_presult() noexcept {
}


uint32_t HalApi_DBG_SpiFlashWrite_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_MdioRead_args::~HalApi_DBG_MdioRead_args() noexcept {
}


uint32_t HalApi_DBG_MdioRead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPhyAddr);
          this->__isset.ulPhyAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulRegAddr);
          this->__isset.ulRegAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_MdioRead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_MdioRead_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulPhyAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ulRegAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_MdioRead_pargs::~HalApi_DBG_MdioRead_pargs() noexcept {
}


uint32_t HalApi_DBG_MdioRead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_MdioRead_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulPhyAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->ulRegAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_MdioRead_result::~HalApi_DBG_MdioRead_result() noexcept {
}


uint32_t HalApi_DBG_MdioRead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_MdioRead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_MdioRead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_MdioRead_presult::~HalApi_DBG_MdioRead_presult() noexcept {
}


uint32_t HalApi_DBG_MdioRead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_MdioWrite_args::~HalApi_DBG_MdioWrite_args() noexcept {
}


uint32_t HalApi_DBG_MdioWrite_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPhyAddr);
          this->__isset.ulPhyAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulRegAddr);
          this->__isset.ulRegAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usData);
          this->__isset.usData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_MdioWrite_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_MdioWrite_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulPhyAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ulRegAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usData", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->usData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_MdioWrite_pargs::~HalApi_DBG_MdioWrite_pargs() noexcept {
}


uint32_t HalApi_DBG_MdioWrite_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_MdioWrite_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulPhyAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->ulRegAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usData", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->usData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_MdioWrite_result::~HalApi_DBG_MdioWrite_result() noexcept {
}


uint32_t HalApi_DBG_MdioWrite_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_MdioWrite_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_MdioWrite_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_MdioWrite_presult::~HalApi_DBG_MdioWrite_presult() noexcept {
}


uint32_t HalApi_DBG_MdioWrite_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_NetSwitchRead_args::~HalApi_DBG_NetSwitchRead_args() noexcept {
}


uint32_t HalApi_DBG_NetSwitchRead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPhyAddr);
          this->__isset.ulPhyAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulRegAddr);
          this->__isset.ulRegAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_NetSwitchRead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_NetSwitchRead_args");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulPhyAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulRegAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_NetSwitchRead_pargs::~HalApi_DBG_NetSwitchRead_pargs() noexcept {
}


uint32_t HalApi_DBG_NetSwitchRead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_NetSwitchRead_pargs");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulPhyAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulRegAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_NetSwitchRead_result::~HalApi_DBG_NetSwitchRead_result() noexcept {
}


uint32_t HalApi_DBG_NetSwitchRead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_NetSwitchRead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_NetSwitchRead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_NetSwitchRead_presult::~HalApi_DBG_NetSwitchRead_presult() noexcept {
}


uint32_t HalApi_DBG_NetSwitchRead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_NetSwitchWrite_args::~HalApi_DBG_NetSwitchWrite_args() noexcept {
}


uint32_t HalApi_DBG_NetSwitchWrite_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPhyAddr);
          this->__isset.ulPhyAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulRegAddr);
          this->__isset.ulRegAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usData);
          this->__isset.usData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_NetSwitchWrite_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_NetSwitchWrite_args");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulPhyAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulRegAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usData", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->usData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_NetSwitchWrite_pargs::~HalApi_DBG_NetSwitchWrite_pargs() noexcept {
}


uint32_t HalApi_DBG_NetSwitchWrite_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_NetSwitchWrite_pargs");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulPhyAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulRegAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usData", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->usData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_NetSwitchWrite_result::~HalApi_DBG_NetSwitchWrite_result() noexcept {
}


uint32_t HalApi_DBG_NetSwitchWrite_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_NetSwitchWrite_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_NetSwitchWrite_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_NetSwitchWrite_presult::~HalApi_DBG_NetSwitchWrite_presult() noexcept {
}


uint32_t HalApi_DBG_NetSwitchWrite_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_SwitchPhyRead_args::~HalApi_DBG_SwitchPhyRead_args() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyRead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPhyAddr);
          this->__isset.ulPhyAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulRegAddr);
          this->__isset.ulRegAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SwitchPhyRead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SwitchPhyRead_args");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulPhyAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulRegAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SwitchPhyRead_pargs::~HalApi_DBG_SwitchPhyRead_pargs() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyRead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SwitchPhyRead_pargs");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulPhyAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulRegAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SwitchPhyRead_result::~HalApi_DBG_SwitchPhyRead_result() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyRead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SwitchPhyRead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_SwitchPhyRead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SwitchPhyRead_presult::~HalApi_DBG_SwitchPhyRead_presult() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyRead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_SwitchPhyWrite_args::~HalApi_DBG_SwitchPhyWrite_args() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyWrite_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPhyAddr);
          this->__isset.ulPhyAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulRegAddr);
          this->__isset.ulRegAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->usData);
          this->__isset.usData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SwitchPhyWrite_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SwitchPhyWrite_args");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulPhyAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulRegAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usData", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->usData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SwitchPhyWrite_pargs::~HalApi_DBG_SwitchPhyWrite_pargs() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyWrite_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_SwitchPhyWrite_pargs");

  xfer += oprot->writeFieldBegin("ulPhyAddr", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulPhyAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulRegAddr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulRegAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usData", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->usData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SwitchPhyWrite_result::~HalApi_DBG_SwitchPhyWrite_result() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyWrite_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_SwitchPhyWrite_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_SwitchPhyWrite_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_SwitchPhyWrite_presult::~HalApi_DBG_SwitchPhyWrite_presult() noexcept {
}


uint32_t HalApi_DBG_SwitchPhyWrite_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_ReadEeprom_args::~HalApi_DBG_ReadEeprom_args() noexcept {
}


uint32_t HalApi_DBG_ReadEeprom_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ReadEeprom_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ReadEeprom_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadEeprom_pargs::~HalApi_DBG_ReadEeprom_pargs() noexcept {
}


uint32_t HalApi_DBG_ReadEeprom_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_ReadEeprom_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadEeprom_result::~HalApi_DBG_ReadEeprom_result() noexcept {
}


uint32_t HalApi_DBG_ReadEeprom_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_ReadEeprom_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_ReadEeprom_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_ReadEeprom_presult::~HalApi_DBG_ReadEeprom_presult() noexcept {
}


uint32_t HalApi_DBG_ReadEeprom_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_DBG_WriteEeprom_args::~HalApi_DBG_WriteEeprom_args() noexcept {
}


uint32_t HalApi_DBG_WriteEeprom_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucVal);
          this->__isset.pucVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_WriteEeprom_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_WriteEeprom_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->pucVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteEeprom_pargs::~HalApi_DBG_WriteEeprom_pargs() noexcept {
}


uint32_t HalApi_DBG_WriteEeprom_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_DBG_WriteEeprom_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->pucVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteEeprom_result::~HalApi_DBG_WriteEeprom_result() noexcept {
}


uint32_t HalApi_DBG_WriteEeprom_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_DBG_WriteEeprom_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_DBG_WriteEeprom_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_DBG_WriteEeprom_presult::~HalApi_DBG_WriteEeprom_presult() noexcept {
}


uint32_t HalApi_DBG_WriteEeprom_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetMfg_args::~HalApi_EDFA_GetMfg_args() noexcept {
}


uint32_t HalApi_EDFA_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetMfg_pargs::~HalApi_EDFA_GetMfg_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetMfg_result::~HalApi_EDFA_GetMfg_result() noexcept {
}


uint32_t HalApi_EDFA_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetMfg_presult::~HalApi_EDFA_GetMfg_presult() noexcept {
}


uint32_t HalApi_EDFA_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetStatusData_args::~HalApi_EDFA_GetStatusData_args() noexcept {
}


uint32_t HalApi_EDFA_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetStatusData_pargs::~HalApi_EDFA_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetStatusData_result::~HalApi_EDFA_GetStatusData_result() noexcept {
}


uint32_t HalApi_EDFA_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetStatusData_presult::~HalApi_EDFA_GetStatusData_presult() noexcept {
}


uint32_t HalApi_EDFA_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetCfgData_args::~HalApi_EDFA_GetCfgData_args() noexcept {
}


uint32_t HalApi_EDFA_GetCfgData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetCfgData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetCfgData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetCfgData_pargs::~HalApi_EDFA_GetCfgData_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetCfgData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetCfgData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetCfgData_result::~HalApi_EDFA_GetCfgData_result() noexcept {
}


uint32_t HalApi_EDFA_GetCfgData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetCfgData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetCfgData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetCfgData_presult::~HalApi_EDFA_GetCfgData_presult() noexcept {
}


uint32_t HalApi_EDFA_GetCfgData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetDebugInfo_args::~HalApi_EDFA_GetDebugInfo_args() noexcept {
}


uint32_t HalApi_EDFA_GetDebugInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetDebugInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetDebugInfo_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetDebugInfo_pargs::~HalApi_EDFA_GetDebugInfo_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetDebugInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetDebugInfo_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetDebugInfo_result::~HalApi_EDFA_GetDebugInfo_result() noexcept {
}


uint32_t HalApi_EDFA_GetDebugInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetDebugInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetDebugInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetDebugInfo_presult::~HalApi_EDFA_GetDebugInfo_presult() noexcept {
}


uint32_t HalApi_EDFA_GetDebugInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetMcuDebugInfo_args::~HalApi_EDFA_GetMcuDebugInfo_args() noexcept {
}


uint32_t HalApi_EDFA_GetMcuDebugInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetMcuDebugInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetMcuDebugInfo_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetMcuDebugInfo_pargs::~HalApi_EDFA_GetMcuDebugInfo_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetMcuDebugInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetMcuDebugInfo_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetMcuDebugInfo_result::~HalApi_EDFA_GetMcuDebugInfo_result() noexcept {
}


uint32_t HalApi_EDFA_GetMcuDebugInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetMcuDebugInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetMcuDebugInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetMcuDebugInfo_presult::~HalApi_EDFA_GetMcuDebugInfo_presult() noexcept {
}


uint32_t HalApi_EDFA_GetMcuDebugInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetGainRange_args::~HalApi_EDFA_SetGainRange_args() noexcept {
}


uint32_t HalApi_EDFA_SetGainRange_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sGainRange);
          this->__isset.sGainRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetGainRange_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetGainRange_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sGainRange", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sGainRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetGainRange_pargs::~HalApi_EDFA_SetGainRange_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetGainRange_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetGainRange_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sGainRange", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sGainRange)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetGainRange_result::~HalApi_EDFA_SetGainRange_result() noexcept {
}


uint32_t HalApi_EDFA_SetGainRange_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetGainRange_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetGainRange_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetGainRange_presult::~HalApi_EDFA_SetGainRange_presult() noexcept {
}


uint32_t HalApi_EDFA_SetGainRange_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetGain_args::~HalApi_EDFA_SetGain_args() noexcept {
}


uint32_t HalApi_EDFA_SetGain_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sGain);
          this->__isset.sGain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetGain_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetGain_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sGain", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sGain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetGain_pargs::~HalApi_EDFA_SetGain_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetGain_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetGain_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sGain", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sGain)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetGain_result::~HalApi_EDFA_SetGain_result() noexcept {
}


uint32_t HalApi_EDFA_SetGain_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetGain_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetGain_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetGain_presult::~HalApi_EDFA_SetGain_presult() noexcept {
}


uint32_t HalApi_EDFA_SetGain_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetTilt_args::~HalApi_EDFA_SetTilt_args() noexcept {
}


uint32_t HalApi_EDFA_SetTilt_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sTilt);
          this->__isset.sTilt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetTilt_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetTilt_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTilt", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sTilt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetTilt_pargs::~HalApi_EDFA_SetTilt_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetTilt_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetTilt_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sTilt", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sTilt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetTilt_result::~HalApi_EDFA_SetTilt_result() noexcept {
}


uint32_t HalApi_EDFA_SetTilt_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetTilt_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetTilt_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetTilt_presult::~HalApi_EDFA_SetTilt_presult() noexcept {
}


uint32_t HalApi_EDFA_SetTilt_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetMode_args::~HalApi_EDFA_SetMode_args() noexcept {
}


uint32_t HalApi_EDFA_SetMode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucMode);
          this->__isset.ucMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sVal);
          this->__isset.sVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetMode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetMode_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucMode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVal", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetMode_pargs::~HalApi_EDFA_SetMode_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetMode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetMode_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucMode", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucMode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sVal", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetMode_result::~HalApi_EDFA_SetMode_result() noexcept {
}


uint32_t HalApi_EDFA_SetMode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetMode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetMode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetMode_presult::~HalApi_EDFA_SetMode_presult() noexcept {
}


uint32_t HalApi_EDFA_SetMode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetPumpEnable_args::~HalApi_EDFA_SetPumpEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetPumpEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetPumpEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPumpEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPumpEnable_pargs::~HalApi_EDFA_SetPumpEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetPumpEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPumpEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPumpEnable_result::~HalApi_EDFA_SetPumpEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetPumpEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetPumpEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPumpEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPumpEnable_presult::~HalApi_EDFA_SetPumpEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetPumpEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetAprEnable_args::~HalApi_EDFA_SetAprEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetAprEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAprEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAprEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAprEnable_pargs::~HalApi_EDFA_SetAprEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetAprEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAprEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAprEnable_result::~HalApi_EDFA_SetAprEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetAprEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAprEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAprEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAprEnable_presult::~HalApi_EDFA_SetAprEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetAprEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetAutolosEnable_args::~HalApi_EDFA_SetAutolosEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetAutolosEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAutolosEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAutolosEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAutolosEnable_pargs::~HalApi_EDFA_SetAutolosEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetAutolosEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAutolosEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAutolosEnable_result::~HalApi_EDFA_SetAutolosEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetAutolosEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAutolosEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAutolosEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAutolosEnable_presult::~HalApi_EDFA_SetAutolosEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetAutolosEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetRxLosThr_args::~HalApi_EDFA_SetRxLosThr_args() noexcept {
}


uint32_t HalApi_EDFA_SetRxLosThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetRxLosThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetRxLosThr_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetRxLosThr_pargs::~HalApi_EDFA_SetRxLosThr_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetRxLosThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetRxLosThr_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetRxLosThr_result::~HalApi_EDFA_SetRxLosThr_result() noexcept {
}


uint32_t HalApi_EDFA_SetRxLosThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetRxLosThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetRxLosThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetRxLosThr_presult::~HalApi_EDFA_SetRxLosThr_presult() noexcept {
}


uint32_t HalApi_EDFA_SetRxLosThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetAttn_args::~HalApi_EDFA_SetAttn_args() noexcept {
}


uint32_t HalApi_EDFA_SetAttn_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAttn);
          this->__isset.sAttn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAttn_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAttn_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAttn", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sAttn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAttn_pargs::~HalApi_EDFA_SetAttn_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetAttn_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAttn_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAttn", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sAttn)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAttn_result::~HalApi_EDFA_SetAttn_result() noexcept {
}


uint32_t HalApi_EDFA_SetAttn_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAttn_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAttn_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAttn_presult::~HalApi_EDFA_SetAttn_presult() noexcept {
}


uint32_t HalApi_EDFA_SetAttn_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetAttn_args::~HalApi_EDFA_GetAttn_args() noexcept {
}


uint32_t HalApi_EDFA_GetAttn_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetAttn_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetAttn_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetAttn_pargs::~HalApi_EDFA_GetAttn_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetAttn_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetAttn_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetAttn_result::~HalApi_EDFA_GetAttn_result() noexcept {
}


uint32_t HalApi_EDFA_GetAttn_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetAttn_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetAttn_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetAttn_presult::~HalApi_EDFA_GetAttn_presult() noexcept {
}


uint32_t HalApi_EDFA_GetAttn_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_Reset_args::~HalApi_EDFA_Reset_args() noexcept {
}


uint32_t HalApi_EDFA_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Reset_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Reset_pargs::~HalApi_EDFA_Reset_pargs() noexcept {
}


uint32_t HalApi_EDFA_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Reset_result::~HalApi_EDFA_Reset_result() noexcept {
}


uint32_t HalApi_EDFA_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Reset_presult::~HalApi_EDFA_Reset_presult() noexcept {
}


uint32_t HalApi_EDFA_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_Upgrade_args::~HalApi_EDFA_Upgrade_args() noexcept {
}


uint32_t HalApi_EDFA_Upgrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Upgrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Upgrade_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Upgrade_pargs::~HalApi_EDFA_Upgrade_pargs() noexcept {
}


uint32_t HalApi_EDFA_Upgrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Upgrade_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Upgrade_result::~HalApi_EDFA_Upgrade_result() noexcept {
}


uint32_t HalApi_EDFA_Upgrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Upgrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_Upgrade_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Upgrade_presult::~HalApi_EDFA_Upgrade_presult() noexcept {
}


uint32_t HalApi_EDFA_Upgrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_Swap_args::~HalApi_EDFA_Swap_args() noexcept {
}


uint32_t HalApi_EDFA_Swap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Swap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Swap_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Swap_pargs::~HalApi_EDFA_Swap_pargs() noexcept {
}


uint32_t HalApi_EDFA_Swap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Swap_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Swap_result::~HalApi_EDFA_Swap_result() noexcept {
}


uint32_t HalApi_EDFA_Swap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Swap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_Swap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Swap_presult::~HalApi_EDFA_Swap_presult() noexcept {
}


uint32_t HalApi_EDFA_Swap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_Commit_args::~HalApi_EDFA_Commit_args() noexcept {
}


uint32_t HalApi_EDFA_Commit_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Commit_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Commit_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Commit_pargs::~HalApi_EDFA_Commit_pargs() noexcept {
}


uint32_t HalApi_EDFA_Commit_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_Commit_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Commit_result::~HalApi_EDFA_Commit_result() noexcept {
}


uint32_t HalApi_EDFA_Commit_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_Commit_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_Commit_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_Commit_presult::~HalApi_EDFA_Commit_presult() noexcept {
}


uint32_t HalApi_EDFA_Commit_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetUpgadeStatus_args::~HalApi_EDFA_GetUpgadeStatus_args() noexcept {
}


uint32_t HalApi_EDFA_GetUpgadeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetUpgadeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetUpgadeStatus_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetUpgadeStatus_pargs::~HalApi_EDFA_GetUpgadeStatus_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetUpgadeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetUpgadeStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetUpgadeStatus_result::~HalApi_EDFA_GetUpgadeStatus_result() noexcept {
}


uint32_t HalApi_EDFA_GetUpgadeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetUpgadeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetUpgadeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetUpgadeStatus_presult::~HalApi_EDFA_GetUpgadeStatus_presult() noexcept {
}


uint32_t HalApi_EDFA_GetUpgadeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_DbgRead_args::~HalApi_EDFA_DbgRead_args() noexcept {
}


uint32_t HalApi_EDFA_DbgRead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLen);
          this->__isset.uiLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_DbgRead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_DbgRead_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_DbgRead_pargs::~HalApi_EDFA_DbgRead_pargs() noexcept {
}


uint32_t HalApi_EDFA_DbgRead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_DbgRead_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_DbgRead_result::~HalApi_EDFA_DbgRead_result() noexcept {
}


uint32_t HalApi_EDFA_DbgRead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_DbgRead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_DbgRead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_DbgRead_presult::~HalApi_EDFA_DbgRead_presult() noexcept {
}


uint32_t HalApi_EDFA_DbgRead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_DbgWrite_args::~HalApi_EDFA_DbgWrite_args() noexcept {
}


uint32_t HalApi_EDFA_DbgWrite_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucBuf);
          this->__isset.pucBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLen);
          this->__isset.uiLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_DbgWrite_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_DbgWrite_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pucBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_DbgWrite_pargs::~HalApi_EDFA_DbgWrite_pargs() noexcept {
}


uint32_t HalApi_EDFA_DbgWrite_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_DbgWrite_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->pucBuf)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_DbgWrite_result::~HalApi_EDFA_DbgWrite_result() noexcept {
}


uint32_t HalApi_EDFA_DbgWrite_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_DbgWrite_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_DbgWrite_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_DbgWrite_presult::~HalApi_EDFA_DbgWrite_presult() noexcept {
}


uint32_t HalApi_EDFA_DbgWrite_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetDfbEnable_args::~HalApi_EDFA_SetDfbEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetDfbEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPower);
          this->__isset.iPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetDfbEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetDfbEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iPower", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetDfbEnable_pargs::~HalApi_EDFA_SetDfbEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetDfbEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetDfbEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iPower", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iPower)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetDfbEnable_result::~HalApi_EDFA_SetDfbEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetDfbEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetDfbEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetDfbEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetDfbEnable_presult::~HalApi_EDFA_SetDfbEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetDfbEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetOscEnable_args::~HalApi_EDFA_SetOscEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetOscEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscEnable_pargs::~HalApi_EDFA_SetOscEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetOscEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscEnable_result::~HalApi_EDFA_SetOscEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetOscEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscEnable_presult::~HalApi_EDFA_SetOscEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetOscEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetOtdrSwitchPos_args::~HalApi_EDFA_SetOtdrSwitchPos_args() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrSwitchPos_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPos);
          this->__isset.uiPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOtdrSwitchPos_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOtdrSwitchPos_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOtdrSwitchPos_pargs::~HalApi_EDFA_SetOtdrSwitchPos_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrSwitchPos_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOtdrSwitchPos_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOtdrSwitchPos_result::~HalApi_EDFA_SetOtdrSwitchPos_result() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrSwitchPos_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOtdrSwitchPos_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOtdrSwitchPos_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOtdrSwitchPos_presult::~HalApi_EDFA_SetOtdrSwitchPos_presult() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrSwitchPos_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetOscAddThrHys_args::~HalApi_EDFA_SetOscAddThrHys_args() noexcept {
}


uint32_t HalApi_EDFA_SetOscAddThrHys_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscAddThrHys_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscAddThrHys_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscAddThrHys_pargs::~HalApi_EDFA_SetOscAddThrHys_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetOscAddThrHys_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscAddThrHys_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscAddThrHys_result::~HalApi_EDFA_SetOscAddThrHys_result() noexcept {
}


uint32_t HalApi_EDFA_SetOscAddThrHys_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscAddThrHys_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscAddThrHys_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscAddThrHys_presult::~HalApi_EDFA_SetOscAddThrHys_presult() noexcept {
}


uint32_t HalApi_EDFA_SetOscAddThrHys_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetOscDropThrHys_args::~HalApi_EDFA_SetOscDropThrHys_args() noexcept {
}


uint32_t HalApi_EDFA_SetOscDropThrHys_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscDropThrHys_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscDropThrHys_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscDropThrHys_pargs::~HalApi_EDFA_SetOscDropThrHys_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetOscDropThrHys_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscDropThrHys_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscDropThrHys_result::~HalApi_EDFA_SetOscDropThrHys_result() noexcept {
}


uint32_t HalApi_EDFA_SetOscDropThrHys_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscDropThrHys_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscDropThrHys_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscDropThrHys_presult::~HalApi_EDFA_SetOscDropThrHys_presult() noexcept {
}


uint32_t HalApi_EDFA_SetOscDropThrHys_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetOscRxThrHys_args::~HalApi_EDFA_SetOscRxThrHys_args() noexcept {
}


uint32_t HalApi_EDFA_SetOscRxThrHys_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscRxThrHys_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscRxThrHys_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscRxThrHys_pargs::~HalApi_EDFA_SetOscRxThrHys_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetOscRxThrHys_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscRxThrHys_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscRxThrHys_result::~HalApi_EDFA_SetOscRxThrHys_result() noexcept {
}


uint32_t HalApi_EDFA_SetOscRxThrHys_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOscRxThrHys_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOscRxThrHys_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOscRxThrHys_presult::~HalApi_EDFA_SetOscRxThrHys_presult() noexcept {
}


uint32_t HalApi_EDFA_SetOscRxThrHys_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetApsdEnable_args::~HalApi_EDFA_SetApsdEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetApsdEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetApsdEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetApsdEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetApsdEnable_pargs::~HalApi_EDFA_SetApsdEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetApsdEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetApsdEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetApsdEnable_result::~HalApi_EDFA_SetApsdEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetApsdEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetApsdEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetApsdEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetApsdEnable_presult::~HalApi_EDFA_SetApsdEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetApsdEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetApsdStatus_args::~HalApi_EDFA_GetApsdStatus_args() noexcept {
}


uint32_t HalApi_EDFA_GetApsdStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetApsdStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetApsdStatus_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetApsdStatus_pargs::~HalApi_EDFA_GetApsdStatus_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetApsdStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetApsdStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetApsdStatus_result::~HalApi_EDFA_GetApsdStatus_result() noexcept {
}


uint32_t HalApi_EDFA_GetApsdStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetApsdStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetApsdStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetApsdStatus_presult::~HalApi_EDFA_GetApsdStatus_presult() noexcept {
}


uint32_t HalApi_EDFA_GetApsdStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetOcmAttn_args::~HalApi_EDFA_GetOcmAttn_args() noexcept {
}


uint32_t HalApi_EDFA_GetOcmAttn_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetOcmAttn_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetOcmAttn_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetOcmAttn_pargs::~HalApi_EDFA_GetOcmAttn_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetOcmAttn_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetOcmAttn_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetOcmAttn_result::~HalApi_EDFA_GetOcmAttn_result() noexcept {
}


uint32_t HalApi_EDFA_GetOcmAttn_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetOcmAttn_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetOcmAttn_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetOcmAttn_presult::~HalApi_EDFA_GetOcmAttn_presult() noexcept {
}


uint32_t HalApi_EDFA_GetOcmAttn_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetUpgState_args::~HalApi_EDFA_SetUpgState_args() noexcept {
}


uint32_t HalApi_EDFA_SetUpgState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sState);
          this->__isset.sState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetUpgState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetUpgState_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sState", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetUpgState_pargs::~HalApi_EDFA_SetUpgState_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetUpgState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetUpgState_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sState", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sState)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetUpgState_result::~HalApi_EDFA_SetUpgState_result() noexcept {
}


uint32_t HalApi_EDFA_SetUpgState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetUpgState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetUpgState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetUpgState_presult::~HalApi_EDFA_SetUpgState_presult() noexcept {
}


uint32_t HalApi_EDFA_SetUpgState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetLedState_args::~HalApi_EDFA_SetLedState_args() noexcept {
}


uint32_t HalApi_EDFA_SetLedState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sState);
          this->__isset.sState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetLedState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetLedState_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sState", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetLedState_pargs::~HalApi_EDFA_SetLedState_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetLedState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetLedState_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sState", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sState)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetLedState_result::~HalApi_EDFA_SetLedState_result() noexcept {
}


uint32_t HalApi_EDFA_SetLedState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetLedState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetLedState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetLedState_presult::~HalApi_EDFA_SetLedState_presult() noexcept {
}


uint32_t HalApi_EDFA_SetLedState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetLedAlm_args::~HalApi_EDFA_SetLedAlm_args() noexcept {
}


uint32_t HalApi_EDFA_SetLedAlm_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sState);
          this->__isset.sState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetLedAlm_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetLedAlm_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sState", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetLedAlm_pargs::~HalApi_EDFA_SetLedAlm_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetLedAlm_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetLedAlm_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sState", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sState)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetLedAlm_result::~HalApi_EDFA_SetLedAlm_result() noexcept {
}


uint32_t HalApi_EDFA_SetLedAlm_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetLedAlm_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetLedAlm_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetLedAlm_presult::~HalApi_EDFA_SetLedAlm_presult() noexcept {
}


uint32_t HalApi_EDFA_SetLedAlm_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetCali_args::~HalApi_EDFA_GetCali_args() noexcept {
}


uint32_t HalApi_EDFA_GetCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetCali_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetCali_pargs::~HalApi_EDFA_GetCali_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetCali_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetCali_result::~HalApi_EDFA_GetCali_result() noexcept {
}


uint32_t HalApi_EDFA_GetCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetCali_presult::~HalApi_EDFA_GetCali_presult() noexcept {
}


uint32_t HalApi_EDFA_GetCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetOtdrCali_args::~HalApi_EDFA_SetOtdrCali_args() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOtdrCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOtdrCali_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOtdrCali_pargs::~HalApi_EDFA_SetOtdrCali_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOtdrCali_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOtdrCali_result::~HalApi_EDFA_SetOtdrCali_result() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOtdrCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOtdrCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOtdrCali_presult::~HalApi_EDFA_SetOtdrCali_presult() noexcept {
}


uint32_t HalApi_EDFA_SetOtdrCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetOcmCali_args::~HalApi_EDFA_SetOcmCali_args() noexcept {
}


uint32_t HalApi_EDFA_SetOcmCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcFilePath);
          this->__isset.pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOcmCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOcmCali_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOcmCali_pargs::~HalApi_EDFA_SetOcmCali_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetOcmCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOcmCali_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOcmCali_result::~HalApi_EDFA_SetOcmCali_result() noexcept {
}


uint32_t HalApi_EDFA_SetOcmCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetOcmCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetOcmCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetOcmCali_presult::~HalApi_EDFA_SetOcmCali_presult() noexcept {
}


uint32_t HalApi_EDFA_SetOcmCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetManualVoaEnable_args::~HalApi_EDFA_SetManualVoaEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetManualVoaEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetManualVoaEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetManualVoaEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetManualVoaEnable_pargs::~HalApi_EDFA_SetManualVoaEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetManualVoaEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetManualVoaEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetManualVoaEnable_result::~HalApi_EDFA_SetManualVoaEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetManualVoaEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetManualVoaEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetManualVoaEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetManualVoaEnable_presult::~HalApi_EDFA_SetManualVoaEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetManualVoaEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetPaddingVoaConfigPower_args::~HalApi_EDFA_SetPaddingVoaConfigPower_args() noexcept {
}


uint32_t HalApi_EDFA_SetPaddingVoaConfigPower_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOutPower);
          this->__isset.sOutPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetPaddingVoaConfigPower_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPaddingVoaConfigPower_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutPower", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sOutPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPaddingVoaConfigPower_pargs::~HalApi_EDFA_SetPaddingVoaConfigPower_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetPaddingVoaConfigPower_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPaddingVoaConfigPower_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOutPower", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sOutPower)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPaddingVoaConfigPower_result::~HalApi_EDFA_SetPaddingVoaConfigPower_result() noexcept {
}


uint32_t HalApi_EDFA_SetPaddingVoaConfigPower_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetPaddingVoaConfigPower_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPaddingVoaConfigPower_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPaddingVoaConfigPower_presult::~HalApi_EDFA_SetPaddingVoaConfigPower_presult() noexcept {
}


uint32_t HalApi_EDFA_SetPaddingVoaConfigPower_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetManualGainEnable_args::~HalApi_EDFA_SetManualGainEnable_args() noexcept {
}


uint32_t HalApi_EDFA_SetManualGainEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetManualGainEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetManualGainEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetManualGainEnable_pargs::~HalApi_EDFA_SetManualGainEnable_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetManualGainEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetManualGainEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetManualGainEnable_result::~HalApi_EDFA_SetManualGainEnable_result() noexcept {
}


uint32_t HalApi_EDFA_SetManualGainEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetManualGainEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetManualGainEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetManualGainEnable_presult::~HalApi_EDFA_SetManualGainEnable_presult() noexcept {
}


uint32_t HalApi_EDFA_SetManualGainEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetThr_args::~HalApi_EDFA_SetThr_args() noexcept {
}


uint32_t HalApi_EDFA_SetThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortIdx);
          this->__isset.uiPortIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiType);
          this->__isset.uiType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetThr_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetThr_pargs::~HalApi_EDFA_SetThr_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetThr_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetThr_result::~HalApi_EDFA_SetThr_result() noexcept {
}


uint32_t HalApi_EDFA_SetThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetThr_presult::~HalApi_EDFA_SetThr_presult() noexcept {
}


uint32_t HalApi_EDFA_SetThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetPumpCurrent_args::~HalApi_EDFA_SetPumpCurrent_args() noexcept {
}


uint32_t HalApi_EDFA_SetPumpCurrent_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPumpIdx);
          this->__isset.uiPumpIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sCurrent);
          this->__isset.sCurrent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetPumpCurrent_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPumpCurrent_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPumpIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPumpIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sCurrent", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sCurrent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPumpCurrent_pargs::~HalApi_EDFA_SetPumpCurrent_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetPumpCurrent_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPumpCurrent_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPumpIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPumpIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sCurrent", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sCurrent)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPumpCurrent_result::~HalApi_EDFA_SetPumpCurrent_result() noexcept {
}


uint32_t HalApi_EDFA_SetPumpCurrent_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetPumpCurrent_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetPumpCurrent_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetPumpCurrent_presult::~HalApi_EDFA_SetPumpCurrent_presult() noexcept {
}


uint32_t HalApi_EDFA_SetPumpCurrent_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetAlmMask_args::~HalApi_EDFA_SetAlmMask_args() noexcept {
}


uint32_t HalApi_EDFA_SetAlmMask_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMaskIdx);
          this->__isset.iMaskIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMaskVal);
          this->__isset.iMaskVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAlmMask_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAlmMask_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iMaskIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskVal", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iMaskVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAlmMask_pargs::~HalApi_EDFA_SetAlmMask_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetAlmMask_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAlmMask_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iMaskIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskVal", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iMaskVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAlmMask_result::~HalApi_EDFA_SetAlmMask_result() noexcept {
}


uint32_t HalApi_EDFA_SetAlmMask_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetAlmMask_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetAlmMask_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetAlmMask_presult::~HalApi_EDFA_SetAlmMask_presult() noexcept {
}


uint32_t HalApi_EDFA_SetAlmMask_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetEventLog_args::~HalApi_EDFA_GetEventLog_args() noexcept {
}


uint32_t HalApi_EDFA_GetEventLog_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetEventLog_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetEventLog_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetEventLog_pargs::~HalApi_EDFA_GetEventLog_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetEventLog_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetEventLog_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetEventLog_result::~HalApi_EDFA_GetEventLog_result() noexcept {
}


uint32_t HalApi_EDFA_GetEventLog_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetEventLog_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetEventLog_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetEventLog_presult::~HalApi_EDFA_GetEventLog_presult() noexcept {
}


uint32_t HalApi_EDFA_GetEventLog_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_SetShutterState_args::~HalApi_EDFA_SetShutterState_args() noexcept {
}


uint32_t HalApi_EDFA_SetShutterState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->block);
          this->__isset.block = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetShutterState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetShutterState_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->block);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetShutterState_pargs::~HalApi_EDFA_SetShutterState_pargs() noexcept {
}


uint32_t HalApi_EDFA_SetShutterState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_SetShutterState_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->block)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetShutterState_result::~HalApi_EDFA_SetShutterState_result() noexcept {
}


uint32_t HalApi_EDFA_SetShutterState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_SetShutterState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_SetShutterState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_SetShutterState_presult::~HalApi_EDFA_SetShutterState_presult() noexcept {
}


uint32_t HalApi_EDFA_SetShutterState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EDFA_GetShutterState_args::~HalApi_EDFA_GetShutterState_args() noexcept {
}


uint32_t HalApi_EDFA_GetShutterState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetShutterState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetShutterState_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetShutterState_pargs::~HalApi_EDFA_GetShutterState_pargs() noexcept {
}


uint32_t HalApi_EDFA_GetShutterState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EDFA_GetShutterState_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetShutterState_result::~HalApi_EDFA_GetShutterState_result() noexcept {
}


uint32_t HalApi_EDFA_GetShutterState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EDFA_GetShutterState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EDFA_GetShutterState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EDFA_GetShutterState_presult::~HalApi_EDFA_GetShutterState_presult() noexcept {
}


uint32_t HalApi_EDFA_GetShutterState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_GetMfg_args::~HalApi_EXTEND_GetMfg_args() noexcept {
}


uint32_t HalApi_EXTEND_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetMfg_pargs::~HalApi_EXTEND_GetMfg_pargs() noexcept {
}


uint32_t HalApi_EXTEND_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetMfg_result::~HalApi_EXTEND_GetMfg_result() noexcept {
}


uint32_t HalApi_EXTEND_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetMfg_presult::~HalApi_EXTEND_GetMfg_presult() noexcept {
}


uint32_t HalApi_EXTEND_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_GetStatusData_args::~HalApi_EXTEND_GetStatusData_args() noexcept {
}


uint32_t HalApi_EXTEND_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetStatusData_pargs::~HalApi_EXTEND_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_EXTEND_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetStatusData_result::~HalApi_EXTEND_GetStatusData_result() noexcept {
}


uint32_t HalApi_EXTEND_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetStatusData_presult::~HalApi_EXTEND_GetStatusData_presult() noexcept {
}


uint32_t HalApi_EXTEND_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_Reset_args::~HalApi_EXTEND_Reset_args() noexcept {
}


uint32_t HalApi_EXTEND_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_Reset_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_Reset_pargs::~HalApi_EXTEND_Reset_pargs() noexcept {
}


uint32_t HalApi_EXTEND_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_Reset_result::~HalApi_EXTEND_Reset_result() noexcept {
}


uint32_t HalApi_EXTEND_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_Reset_presult::~HalApi_EXTEND_Reset_presult() noexcept {
}


uint32_t HalApi_EXTEND_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_Upgrade_args::~HalApi_EXTEND_Upgrade_args() noexcept {
}


uint32_t HalApi_EXTEND_Upgrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_Upgrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_Upgrade_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_Upgrade_pargs::~HalApi_EXTEND_Upgrade_pargs() noexcept {
}


uint32_t HalApi_EXTEND_Upgrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_Upgrade_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_Upgrade_result::~HalApi_EXTEND_Upgrade_result() noexcept {
}


uint32_t HalApi_EXTEND_Upgrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_Upgrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_Upgrade_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_Upgrade_presult::~HalApi_EXTEND_Upgrade_presult() noexcept {
}


uint32_t HalApi_EXTEND_Upgrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_GetUpgadeStatus_args::~HalApi_EXTEND_GetUpgadeStatus_args() noexcept {
}


uint32_t HalApi_EXTEND_GetUpgadeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_GetUpgadeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetUpgadeStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetUpgadeStatus_pargs::~HalApi_EXTEND_GetUpgadeStatus_pargs() noexcept {
}


uint32_t HalApi_EXTEND_GetUpgadeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetUpgadeStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetUpgadeStatus_result::~HalApi_EXTEND_GetUpgadeStatus_result() noexcept {
}


uint32_t HalApi_EXTEND_GetUpgadeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_GetUpgadeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_GetUpgadeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_GetUpgadeStatus_presult::~HalApi_EXTEND_GetUpgadeStatus_presult() noexcept {
}


uint32_t HalApi_EXTEND_GetUpgadeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_DbgRead_args::~HalApi_EXTEND_DbgRead_args() noexcept {
}


uint32_t HalApi_EXTEND_DbgRead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLen);
          this->__isset.uiLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_DbgRead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_DbgRead_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_DbgRead_pargs::~HalApi_EXTEND_DbgRead_pargs() noexcept {
}


uint32_t HalApi_EXTEND_DbgRead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_DbgRead_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_DbgRead_result::~HalApi_EXTEND_DbgRead_result() noexcept {
}


uint32_t HalApi_EXTEND_DbgRead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_DbgRead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_DbgRead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_DbgRead_presult::~HalApi_EXTEND_DbgRead_presult() noexcept {
}


uint32_t HalApi_EXTEND_DbgRead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_DbgWrite_args::~HalApi_EXTEND_DbgWrite_args() noexcept {
}


uint32_t HalApi_EXTEND_DbgWrite_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucBuf);
          this->__isset.pucBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLen);
          this->__isset.uiLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_DbgWrite_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_DbgWrite_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pucBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_DbgWrite_pargs::~HalApi_EXTEND_DbgWrite_pargs() noexcept {
}


uint32_t HalApi_EXTEND_DbgWrite_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_DbgWrite_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->pucBuf)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_DbgWrite_result::~HalApi_EXTEND_DbgWrite_result() noexcept {
}


uint32_t HalApi_EXTEND_DbgWrite_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_DbgWrite_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_DbgWrite_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_DbgWrite_presult::~HalApi_EXTEND_DbgWrite_presult() noexcept {
}


uint32_t HalApi_EXTEND_DbgWrite_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_EXTEND_SetSfp_args::~HalApi_EXTEND_SetSfp_args() noexcept {
}


uint32_t HalApi_EXTEND_SetSfp_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulVal);
          this->__isset.ulVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_SetSfp_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_SetSfp_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulVal", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_SetSfp_pargs::~HalApi_EXTEND_SetSfp_pargs() noexcept {
}


uint32_t HalApi_EXTEND_SetSfp_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_EXTEND_SetSfp_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulVal", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_SetSfp_result::~HalApi_EXTEND_SetSfp_result() noexcept {
}


uint32_t HalApi_EXTEND_SetSfp_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_EXTEND_SetSfp_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_EXTEND_SetSfp_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_EXTEND_SetSfp_presult::~HalApi_EXTEND_SetSfp_presult() noexcept {
}


uint32_t HalApi_EXTEND_SetSfp_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_MIRROR_GetStatusData_args::~HalApi_MIRROR_GetStatusData_args() noexcept {
}


uint32_t HalApi_MIRROR_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MIRROR_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MIRROR_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MIRROR_GetStatusData_pargs::~HalApi_MIRROR_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_MIRROR_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MIRROR_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MIRROR_GetStatusData_result::~HalApi_MIRROR_GetStatusData_result() noexcept {
}


uint32_t HalApi_MIRROR_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MIRROR_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_MIRROR_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MIRROR_GetStatusData_presult::~HalApi_MIRROR_GetStatusData_presult() noexcept {
}


uint32_t HalApi_MIRROR_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SWITCH_Pos_args::~HalApi_SWITCH_Pos_args() noexcept {
}


uint32_t HalApi_SWITCH_Pos_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPort);
          this->__isset.uiPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SWITCH_Pos_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SWITCH_Pos_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPort", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SWITCH_Pos_pargs::~HalApi_SWITCH_Pos_pargs() noexcept {
}


uint32_t HalApi_SWITCH_Pos_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SWITCH_Pos_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPort", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPort)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SWITCH_Pos_result::~HalApi_SWITCH_Pos_result() noexcept {
}


uint32_t HalApi_SWITCH_Pos_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SWITCH_Pos_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SWITCH_Pos_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SWITCH_Pos_presult::~HalApi_SWITCH_Pos_presult() noexcept {
}


uint32_t HalApi_SWITCH_Pos_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_MUX_GetMfg_args::~HalApi_MUX_GetMfg_args() noexcept {
}


uint32_t HalApi_MUX_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MUX_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MUX_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetMfg_pargs::~HalApi_MUX_GetMfg_pargs() noexcept {
}


uint32_t HalApi_MUX_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MUX_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetMfg_result::~HalApi_MUX_GetMfg_result() noexcept {
}


uint32_t HalApi_MUX_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MUX_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_MUX_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetMfg_presult::~HalApi_MUX_GetMfg_presult() noexcept {
}


uint32_t HalApi_MUX_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_MUX_GetStatusData_args::~HalApi_MUX_GetStatusData_args() noexcept {
}


uint32_t HalApi_MUX_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MUX_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MUX_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetStatusData_pargs::~HalApi_MUX_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_MUX_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MUX_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetStatusData_result::~HalApi_MUX_GetStatusData_result() noexcept {
}


uint32_t HalApi_MUX_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MUX_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_MUX_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetStatusData_presult::~HalApi_MUX_GetStatusData_presult() noexcept {
}


uint32_t HalApi_MUX_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_MUX_GetCali_args::~HalApi_MUX_GetCali_args() noexcept {
}


uint32_t HalApi_MUX_GetCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MUX_GetCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MUX_GetCali_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetCali_pargs::~HalApi_MUX_GetCali_pargs() noexcept {
}


uint32_t HalApi_MUX_GetCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_MUX_GetCali_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetCali_result::~HalApi_MUX_GetCali_result() noexcept {
}


uint32_t HalApi_MUX_GetCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_MUX_GetCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_MUX_GetCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_MUX_GetCali_presult::~HalApi_MUX_GetCali_presult() noexcept {
}


uint32_t HalApi_MUX_GetCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetMfg_args::~HalApi_OCM_GetMfg_args() noexcept {
}


uint32_t HalApi_OCM_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetMfg_pargs::~HalApi_OCM_GetMfg_pargs() noexcept {
}


uint32_t HalApi_OCM_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetMfg_result::~HalApi_OCM_GetMfg_result() noexcept {
}


uint32_t HalApi_OCM_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetMfg_presult::~HalApi_OCM_GetMfg_presult() noexcept {
}


uint32_t HalApi_OCM_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetStatusData_args::~HalApi_OCM_GetStatusData_args() noexcept {
}


uint32_t HalApi_OCM_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetStatusData_pargs::~HalApi_OCM_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_OCM_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetStatusData_result::~HalApi_OCM_GetStatusData_result() noexcept {
}


uint32_t HalApi_OCM_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetStatusData_presult::~HalApi_OCM_GetStatusData_presult() noexcept {
}


uint32_t HalApi_OCM_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetChPower_args::~HalApi_OCM_GetChPower_args() noexcept {
}


uint32_t HalApi_OCM_GetChPower_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetChPower_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetChPower_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetChPower_pargs::~HalApi_OCM_GetChPower_pargs() noexcept {
}


uint32_t HalApi_OCM_GetChPower_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetChPower_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetChPower_result::~HalApi_OCM_GetChPower_result() noexcept {
}


uint32_t HalApi_OCM_GetChPower_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetChPower_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetChPower_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetChPower_presult::~HalApi_OCM_GetChPower_presult() noexcept {
}


uint32_t HalApi_OCM_GetChPower_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetOsaData_args::~HalApi_OCM_GetOsaData_args() noexcept {
}


uint32_t HalApi_OCM_GetOsaData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetOsaData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetOsaData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetOsaData_pargs::~HalApi_OCM_GetOsaData_pargs() noexcept {
}


uint32_t HalApi_OCM_GetOsaData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetOsaData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetOsaData_result::~HalApi_OCM_GetOsaData_result() noexcept {
}


uint32_t HalApi_OCM_GetOsaData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetOsaData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetOsaData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetOsaData_presult::~HalApi_OCM_GetOsaData_presult() noexcept {
}


uint32_t HalApi_OCM_GetOsaData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetRealTimeOsaData_args::~HalApi_OCM_GetRealTimeOsaData_args() noexcept {
}


uint32_t HalApi_OCM_GetRealTimeOsaData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetRealTimeOsaData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetRealTimeOsaData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetRealTimeOsaData_pargs::~HalApi_OCM_GetRealTimeOsaData_pargs() noexcept {
}


uint32_t HalApi_OCM_GetRealTimeOsaData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetRealTimeOsaData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetRealTimeOsaData_result::~HalApi_OCM_GetRealTimeOsaData_result() noexcept {
}


uint32_t HalApi_OCM_GetRealTimeOsaData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetRealTimeOsaData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetRealTimeOsaData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetRealTimeOsaData_presult::~HalApi_OCM_GetRealTimeOsaData_presult() noexcept {
}


uint32_t HalApi_OCM_GetRealTimeOsaData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_SetWaveplan_args::~HalApi_OCM_SetWaveplan_args() noexcept {
}


uint32_t HalApi_OCM_SetWaveplan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiChCnt);
          this->__isset.uiChCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pstWavePlan.clear();
            uint32_t _size1118;
            ::apache::thrift::protocol::TType _etype1121;
            xfer += iprot->readListBegin(_etype1121, _size1118);
            this->pstWavePlan.resize(_size1118);
            uint32_t _i1122;
            for (_i1122 = 0; _i1122 < _size1118; ++_i1122)
            {
              xfer += this->pstWavePlan[_i1122].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pstWavePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_SetWaveplan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_SetWaveplan_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiChCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWavePlan", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pstWavePlan.size()));
    std::vector<CWavePlanSlice_t> ::const_iterator _iter1123;
    for (_iter1123 = this->pstWavePlan.begin(); _iter1123 != this->pstWavePlan.end(); ++_iter1123)
    {
      xfer += (*_iter1123).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetWaveplan_pargs::~HalApi_OCM_SetWaveplan_pargs() noexcept {
}


uint32_t HalApi_OCM_SetWaveplan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_SetWaveplan_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiChCnt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWavePlan", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->pstWavePlan)).size()));
    std::vector<CWavePlanSlice_t> ::const_iterator _iter1124;
    for (_iter1124 = (*(this->pstWavePlan)).begin(); _iter1124 != (*(this->pstWavePlan)).end(); ++_iter1124)
    {
      xfer += (*_iter1124).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetWaveplan_result::~HalApi_OCM_SetWaveplan_result() noexcept {
}


uint32_t HalApi_OCM_SetWaveplan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_SetWaveplan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_SetWaveplan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetWaveplan_presult::~HalApi_OCM_SetWaveplan_presult() noexcept {
}


uint32_t HalApi_OCM_SetWaveplan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_SetOcmWaveplan_args::~HalApi_OCM_SetOcmWaveplan_args() noexcept {
}


uint32_t HalApi_OCM_SetOcmWaveplan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiChCnt);
          this->__isset.uiChCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pstWavePlan.clear();
            uint32_t _size1125;
            ::apache::thrift::protocol::TType _etype1128;
            xfer += iprot->readListBegin(_etype1128, _size1125);
            this->pstWavePlan.resize(_size1125);
            uint32_t _i1129;
            for (_i1129 = 0; _i1129 < _size1125; ++_i1129)
            {
              xfer += this->pstWavePlan[_i1129].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pstWavePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_SetOcmWaveplan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_SetOcmWaveplan_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiChCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWavePlan", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pstWavePlan.size()));
    std::vector<STChannelGrid_t> ::const_iterator _iter1130;
    for (_iter1130 = this->pstWavePlan.begin(); _iter1130 != this->pstWavePlan.end(); ++_iter1130)
    {
      xfer += (*_iter1130).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetOcmWaveplan_pargs::~HalApi_OCM_SetOcmWaveplan_pargs() noexcept {
}


uint32_t HalApi_OCM_SetOcmWaveplan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_SetOcmWaveplan_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiChCnt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWavePlan", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->pstWavePlan)).size()));
    std::vector<STChannelGrid_t> ::const_iterator _iter1131;
    for (_iter1131 = (*(this->pstWavePlan)).begin(); _iter1131 != (*(this->pstWavePlan)).end(); ++_iter1131)
    {
      xfer += (*_iter1131).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetOcmWaveplan_result::~HalApi_OCM_SetOcmWaveplan_result() noexcept {
}


uint32_t HalApi_OCM_SetOcmWaveplan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_SetOcmWaveplan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_SetOcmWaveplan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetOcmWaveplan_presult::~HalApi_OCM_SetOcmWaveplan_presult() noexcept {
}


uint32_t HalApi_OCM_SetOcmWaveplan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_Reset_args::~HalApi_OCM_Reset_args() noexcept {
}


uint32_t HalApi_OCM_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_Reset_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Reset_pargs::~HalApi_OCM_Reset_pargs() noexcept {
}


uint32_t HalApi_OCM_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Reset_result::~HalApi_OCM_Reset_result() noexcept {
}


uint32_t HalApi_OCM_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Reset_presult::~HalApi_OCM_Reset_presult() noexcept {
}


uint32_t HalApi_OCM_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_Upgrade_args::~HalApi_OCM_Upgrade_args() noexcept {
}


uint32_t HalApi_OCM_Upgrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_Upgrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_Upgrade_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Upgrade_pargs::~HalApi_OCM_Upgrade_pargs() noexcept {
}


uint32_t HalApi_OCM_Upgrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_Upgrade_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Upgrade_result::~HalApi_OCM_Upgrade_result() noexcept {
}


uint32_t HalApi_OCM_Upgrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_Upgrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_Upgrade_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Upgrade_presult::~HalApi_OCM_Upgrade_presult() noexcept {
}


uint32_t HalApi_OCM_Upgrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_Commit_args::~HalApi_OCM_Commit_args() noexcept {
}


uint32_t HalApi_OCM_Commit_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_Commit_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_Commit_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Commit_pargs::~HalApi_OCM_Commit_pargs() noexcept {
}


uint32_t HalApi_OCM_Commit_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_Commit_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Commit_result::~HalApi_OCM_Commit_result() noexcept {
}


uint32_t HalApi_OCM_Commit_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_Commit_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_Commit_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_Commit_presult::~HalApi_OCM_Commit_presult() noexcept {
}


uint32_t HalApi_OCM_Commit_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetUpgradeStatus_args::~HalApi_OCM_GetUpgradeStatus_args() noexcept {
}


uint32_t HalApi_OCM_GetUpgradeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetUpgradeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetUpgradeStatus_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetUpgradeStatus_pargs::~HalApi_OCM_GetUpgradeStatus_pargs() noexcept {
}


uint32_t HalApi_OCM_GetUpgradeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetUpgradeStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetUpgradeStatus_result::~HalApi_OCM_GetUpgradeStatus_result() noexcept {
}


uint32_t HalApi_OCM_GetUpgradeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetUpgradeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetUpgradeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetUpgradeStatus_presult::~HalApi_OCM_GetUpgradeStatus_presult() noexcept {
}


uint32_t HalApi_OCM_GetUpgradeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_SetVoa_args::~HalApi_OCM_SetVoa_args() noexcept {
}


uint32_t HalApi_OCM_SetVoa_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAttn);
          this->__isset.sAttn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_SetVoa_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_SetVoa_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAttn", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sAttn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetVoa_pargs::~HalApi_OCM_SetVoa_pargs() noexcept {
}


uint32_t HalApi_OCM_SetVoa_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_SetVoa_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAttn", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sAttn)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetVoa_result::~HalApi_OCM_SetVoa_result() noexcept {
}


uint32_t HalApi_OCM_SetVoa_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_SetVoa_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_SetVoa_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_SetVoa_presult::~HalApi_OCM_SetVoa_presult() noexcept {
}


uint32_t HalApi_OCM_SetVoa_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetVoa_args::~HalApi_OCM_GetVoa_args() noexcept {
}


uint32_t HalApi_OCM_GetVoa_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetVoa_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetVoa_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetVoa_pargs::~HalApi_OCM_GetVoa_pargs() noexcept {
}


uint32_t HalApi_OCM_GetVoa_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetVoa_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetVoa_result::~HalApi_OCM_GetVoa_result() noexcept {
}


uint32_t HalApi_OCM_GetVoa_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetVoa_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetVoa_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetVoa_presult::~HalApi_OCM_GetVoa_presult() noexcept {
}


uint32_t HalApi_OCM_GetVoa_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCM_GetVoaPd_args::~HalApi_OCM_GetVoaPd_args() noexcept {
}


uint32_t HalApi_OCM_GetVoaPd_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetVoaPd_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetVoaPd_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetVoaPd_pargs::~HalApi_OCM_GetVoaPd_pargs() noexcept {
}


uint32_t HalApi_OCM_GetVoaPd_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCM_GetVoaPd_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetVoaPd_result::~HalApi_OCM_GetVoaPd_result() noexcept {
}


uint32_t HalApi_OCM_GetVoaPd_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCM_GetVoaPd_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCM_GetVoaPd_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCM_GetVoaPd_presult::~HalApi_OCM_GetVoaPd_presult() noexcept {
}


uint32_t HalApi_OCM_GetVoaPd_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_GetMfg_args::~HalApi_OCS_GetMfg_args() noexcept {
}


uint32_t HalApi_OCS_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetMfg_pargs::~HalApi_OCS_GetMfg_pargs() noexcept {
}


uint32_t HalApi_OCS_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetMfg_result::~HalApi_OCS_GetMfg_result() noexcept {
}


uint32_t HalApi_OCS_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetMfg_presult::~HalApi_OCS_GetMfg_presult() noexcept {
}


uint32_t HalApi_OCS_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_GetStatusData_args::~HalApi_OCS_GetStatusData_args() noexcept {
}


uint32_t HalApi_OCS_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetStatusData_pargs::~HalApi_OCS_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_OCS_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetStatusData_result::~HalApi_OCS_GetStatusData_result() noexcept {
}


uint32_t HalApi_OCS_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetStatusData_presult::~HalApi_OCS_GetStatusData_presult() noexcept {
}


uint32_t HalApi_OCS_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_SetConnection_args::~HalApi_OCS_SetConnection_args() noexcept {
}


uint32_t HalApi_OCS_SetConnection_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pstConnection.read(iprot);
          this->__isset.pstConnection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetConnection_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetConnection_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstConnection", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pstConnection.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetConnection_pargs::~HalApi_OCS_SetConnection_pargs() noexcept {
}


uint32_t HalApi_OCS_SetConnection_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetConnection_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstConnection", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->pstConnection)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetConnection_result::~HalApi_OCS_SetConnection_result() noexcept {
}


uint32_t HalApi_OCS_SetConnection_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetConnection_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_SetConnection_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetConnection_presult::~HalApi_OCS_SetConnection_presult() noexcept {
}


uint32_t HalApi_OCS_SetConnection_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_SetConnections_args::~HalApi_OCS_SetConnections_args() noexcept {
}


uint32_t HalApi_OCS_SetConnections_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pstConnections.read(iprot);
          this->__isset.pstConnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetConnections_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetConnections_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstConnections", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pstConnections.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetConnections_pargs::~HalApi_OCS_SetConnections_pargs() noexcept {
}


uint32_t HalApi_OCS_SetConnections_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetConnections_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstConnections", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->pstConnections)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetConnections_result::~HalApi_OCS_SetConnections_result() noexcept {
}


uint32_t HalApi_OCS_SetConnections_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetConnections_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_SetConnections_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetConnections_presult::~HalApi_OCS_SetConnections_presult() noexcept {
}


uint32_t HalApi_OCS_SetConnections_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_SetLedState_args::~HalApi_OCS_SetLedState_args() noexcept {
}


uint32_t HalApi_OCS_SetLedState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiState);
          this->__isset.uiState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetLedState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetLedState_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetLedState_pargs::~HalApi_OCS_SetLedState_pargs() noexcept {
}


uint32_t HalApi_OCS_SetLedState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetLedState_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->index)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiState)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetLedState_result::~HalApi_OCS_SetLedState_result() noexcept {
}


uint32_t HalApi_OCS_SetLedState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetLedState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_SetLedState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetLedState_presult::~HalApi_OCS_SetLedState_presult() noexcept {
}


uint32_t HalApi_OCS_SetLedState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_SetLedMode_args::~HalApi_OCS_SetLedMode_args() noexcept {
}


uint32_t HalApi_OCS_SetLedMode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMode);
          this->__isset.uiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetLedMode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetLedMode_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetLedMode_pargs::~HalApi_OCS_SetLedMode_pargs() noexcept {
}


uint32_t HalApi_OCS_SetLedMode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_SetLedMode_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiMode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetLedMode_result::~HalApi_OCS_SetLedMode_result() noexcept {
}


uint32_t HalApi_OCS_SetLedMode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_SetLedMode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_SetLedMode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_SetLedMode_presult::~HalApi_OCS_SetLedMode_presult() noexcept {
}


uint32_t HalApi_OCS_SetLedMode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_Reset_args::~HalApi_OCS_Reset_args() noexcept {
}


uint32_t HalApi_OCS_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_Reset_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_Reset_pargs::~HalApi_OCS_Reset_pargs() noexcept {
}


uint32_t HalApi_OCS_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_Reset_result::~HalApi_OCS_Reset_result() noexcept {
}


uint32_t HalApi_OCS_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_Reset_presult::~HalApi_OCS_Reset_presult() noexcept {
}


uint32_t HalApi_OCS_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_Upgrade_args::~HalApi_OCS_Upgrade_args() noexcept {
}


uint32_t HalApi_OCS_Upgrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcPath);
          this->__isset.pcPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_Upgrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_Upgrade_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pcPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_Upgrade_pargs::~HalApi_OCS_Upgrade_pargs() noexcept {
}


uint32_t HalApi_OCS_Upgrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_Upgrade_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pcPath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->pcPath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_Upgrade_result::~HalApi_OCS_Upgrade_result() noexcept {
}


uint32_t HalApi_OCS_Upgrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_Upgrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_Upgrade_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_Upgrade_presult::~HalApi_OCS_Upgrade_presult() noexcept {
}


uint32_t HalApi_OCS_Upgrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OCS_GetUpgradeStatus_args::~HalApi_OCS_GetUpgradeStatus_args() noexcept {
}


uint32_t HalApi_OCS_GetUpgradeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_GetUpgradeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_GetUpgradeStatus_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetUpgradeStatus_pargs::~HalApi_OCS_GetUpgradeStatus_pargs() noexcept {
}


uint32_t HalApi_OCS_GetUpgradeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OCS_GetUpgradeStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetUpgradeStatus_result::~HalApi_OCS_GetUpgradeStatus_result() noexcept {
}


uint32_t HalApi_OCS_GetUpgradeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OCS_GetUpgradeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OCS_GetUpgradeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OCS_GetUpgradeStatus_presult::~HalApi_OCS_GetUpgradeStatus_presult() noexcept {
}


uint32_t HalApi_OCS_GetUpgradeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetMfg_args::~HalApi_OPS_GetMfg_args() noexcept {
}


uint32_t HalApi_OPS_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetMfg_pargs::~HalApi_OPS_GetMfg_pargs() noexcept {
}


uint32_t HalApi_OPS_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetMfg_result::~HalApi_OPS_GetMfg_result() noexcept {
}


uint32_t HalApi_OPS_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetMfg_presult::~HalApi_OPS_GetMfg_presult() noexcept {
}


uint32_t HalApi_OPS_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetCommStatusData_args::~HalApi_OPS_GetCommStatusData_args() noexcept {
}


uint32_t HalApi_OPS_GetCommStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetCommStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetCommStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetCommStatusData_pargs::~HalApi_OPS_GetCommStatusData_pargs() noexcept {
}


uint32_t HalApi_OPS_GetCommStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetCommStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetCommStatusData_result::~HalApi_OPS_GetCommStatusData_result() noexcept {
}


uint32_t HalApi_OPS_GetCommStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetCommStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetCommStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetCommStatusData_presult::~HalApi_OPS_GetCommStatusData_presult() noexcept {
}


uint32_t HalApi_OPS_GetCommStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetCfgData_args::~HalApi_OPS_GetCfgData_args() noexcept {
}


uint32_t HalApi_OPS_GetCfgData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetCfgData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetCfgData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetCfgData_pargs::~HalApi_OPS_GetCfgData_pargs() noexcept {
}


uint32_t HalApi_OPS_GetCfgData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetCfgData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetCfgData_result::~HalApi_OPS_GetCfgData_result() noexcept {
}


uint32_t HalApi_OPS_GetCfgData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetCfgData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetCfgData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetCfgData_presult::~HalApi_OPS_GetCfgData_presult() noexcept {
}


uint32_t HalApi_OPS_GetCfgData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetStatusData_args::~HalApi_OPS_GetStatusData_args() noexcept {
}


uint32_t HalApi_OPS_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetStatusData_pargs::~HalApi_OPS_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_OPS_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetStatusData_result::~HalApi_OPS_GetStatusData_result() noexcept {
}


uint32_t HalApi_OPS_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetStatusData_presult::~HalApi_OPS_GetStatusData_presult() noexcept {
}


uint32_t HalApi_OPS_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetHistoryData_args::~HalApi_OPS_GetHistoryData_args() noexcept {
}


uint32_t HalApi_OPS_GetHistoryData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetHistoryData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetHistoryData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetHistoryData_pargs::~HalApi_OPS_GetHistoryData_pargs() noexcept {
}


uint32_t HalApi_OPS_GetHistoryData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetHistoryData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetHistoryData_result::~HalApi_OPS_GetHistoryData_result() noexcept {
}


uint32_t HalApi_OPS_GetHistoryData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetHistoryData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetHistoryData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetHistoryData_presult::~HalApi_OPS_GetHistoryData_presult() noexcept {
}


uint32_t HalApi_OPS_GetHistoryData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetLedStatus_args::~HalApi_OPS_GetLedStatus_args() noexcept {
}


uint32_t HalApi_OPS_GetLedStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetLedStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetLedStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetLedStatus_pargs::~HalApi_OPS_GetLedStatus_pargs() noexcept {
}


uint32_t HalApi_OPS_GetLedStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetLedStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetLedStatus_result::~HalApi_OPS_GetLedStatus_result() noexcept {
}


uint32_t HalApi_OPS_GetLedStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetLedStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetLedStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetLedStatus_presult::~HalApi_OPS_GetLedStatus_presult() noexcept {
}


uint32_t HalApi_OPS_GetLedStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_ClearAlarmDuration_args::~HalApi_OPS_ClearAlarmDuration_args() noexcept {
}


uint32_t HalApi_OPS_ClearAlarmDuration_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_ClearAlarmDuration_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_ClearAlarmDuration_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_ClearAlarmDuration_pargs::~HalApi_OPS_ClearAlarmDuration_pargs() noexcept {
}


uint32_t HalApi_OPS_ClearAlarmDuration_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_ClearAlarmDuration_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_ClearAlarmDuration_result::~HalApi_OPS_ClearAlarmDuration_result() noexcept {
}


uint32_t HalApi_OPS_ClearAlarmDuration_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_ClearAlarmDuration_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_ClearAlarmDuration_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_ClearAlarmDuration_presult::~HalApi_OPS_ClearAlarmDuration_presult() noexcept {
}


uint32_t HalApi_OPS_ClearAlarmDuration_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetThrPwrDiff_args::~HalApi_OPS_SetThrPwrDiff_args() noexcept {
}


uint32_t HalApi_OPS_SetThrPwrDiff_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetThrPwrDiff_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetThrPwrDiff_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetThrPwrDiff_pargs::~HalApi_OPS_SetThrPwrDiff_pargs() noexcept {
}


uint32_t HalApi_OPS_SetThrPwrDiff_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetThrPwrDiff_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetThrPwrDiff_result::~HalApi_OPS_SetThrPwrDiff_result() noexcept {
}


uint32_t HalApi_OPS_SetThrPwrDiff_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetThrPwrDiff_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetThrPwrDiff_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetThrPwrDiff_presult::~HalApi_OPS_SetThrPwrDiff_presult() noexcept {
}


uint32_t HalApi_OPS_SetThrPwrDiff_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetThrLine_args::~HalApi_OPS_SetThrLine_args() noexcept {
}


uint32_t HalApi_OPS_SetThrLine_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortIdx);
          this->__isset.uiPortIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetThrLine_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetThrLine_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetThrLine_pargs::~HalApi_OPS_SetThrLine_pargs() noexcept {
}


uint32_t HalApi_OPS_SetThrLine_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetThrLine_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetThrLine_result::~HalApi_OPS_SetThrLine_result() noexcept {
}


uint32_t HalApi_OPS_SetThrLine_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetThrLine_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetThrLine_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetThrLine_presult::~HalApi_OPS_SetThrLine_presult() noexcept {
}


uint32_t HalApi_OPS_SetThrLine_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetPortPowerThr_args::~HalApi_OPS_SetPortPowerThr_args() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortIdx);
          this->__isset.uiPortIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiType);
          this->__isset.uiType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetPortPowerThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetPortPowerThr_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetPortPowerThr_pargs::~HalApi_OPS_SetPortPowerThr_pargs() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetPortPowerThr_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetPortPowerThr_result::~HalApi_OPS_SetPortPowerThr_result() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetPortPowerThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetPortPowerThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetPortPowerThr_presult::~HalApi_OPS_SetPortPowerThr_presult() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetPortPowerHys_args::~HalApi_OPS_SetPortPowerHys_args() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerHys_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortIdx);
          this->__isset.uiPortIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiType);
          this->__isset.uiType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetPortPowerHys_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetPortPowerHys_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetPortPowerHys_pargs::~HalApi_OPS_SetPortPowerHys_pargs() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerHys_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetPortPowerHys_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetPortPowerHys_result::~HalApi_OPS_SetPortPowerHys_result() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerHys_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetPortPowerHys_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetPortPowerHys_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetPortPowerHys_presult::~HalApi_OPS_SetPortPowerHys_presult() noexcept {
}


uint32_t HalApi_OPS_SetPortPowerHys_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetWtr_args::~HalApi_OPS_SetWtr_args() noexcept {
}


uint32_t HalApi_OPS_SetWtr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiWtr);
          this->__isset.uiWtr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetWtr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetWtr_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiWtr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiWtr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetWtr_pargs::~HalApi_OPS_SetWtr_pargs() noexcept {
}


uint32_t HalApi_OPS_SetWtr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetWtr_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiWtr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiWtr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetWtr_result::~HalApi_OPS_SetWtr_result() noexcept {
}


uint32_t HalApi_OPS_SetWtr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetWtr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetWtr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetWtr_presult::~HalApi_OPS_SetWtr_presult() noexcept {
}


uint32_t HalApi_OPS_SetWtr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetHoldOffTime_args::~HalApi_OPS_SetHoldOffTime_args() noexcept {
}


uint32_t HalApi_OPS_SetHoldOffTime_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiHoldOffTime);
          this->__isset.uiHoldOffTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetHoldOffTime_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetHoldOffTime_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiHoldOffTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiHoldOffTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetHoldOffTime_pargs::~HalApi_OPS_SetHoldOffTime_pargs() noexcept {
}


uint32_t HalApi_OPS_SetHoldOffTime_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetHoldOffTime_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiHoldOffTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiHoldOffTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetHoldOffTime_result::~HalApi_OPS_SetHoldOffTime_result() noexcept {
}


uint32_t HalApi_OPS_SetHoldOffTime_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetHoldOffTime_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetHoldOffTime_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetHoldOffTime_presult::~HalApi_OPS_SetHoldOffTime_presult() noexcept {
}


uint32_t HalApi_OPS_SetHoldOffTime_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetRevertive_args::~HalApi_OPS_SetRevertive_args() noexcept {
}


uint32_t HalApi_OPS_SetRevertive_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bRevertive);
          this->__isset.bRevertive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRevertive_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRevertive_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bRevertive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bRevertive);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRevertive_pargs::~HalApi_OPS_SetRevertive_pargs() noexcept {
}


uint32_t HalApi_OPS_SetRevertive_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRevertive_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bRevertive", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bRevertive)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRevertive_result::~HalApi_OPS_SetRevertive_result() noexcept {
}


uint32_t HalApi_OPS_SetRevertive_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRevertive_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetRevertive_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRevertive_presult::~HalApi_OPS_SetRevertive_presult() noexcept {
}


uint32_t HalApi_OPS_SetRevertive_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetMode_args::~HalApi_OPS_SetMode_args() noexcept {
}


uint32_t HalApi_OPS_SetMode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMode);
          this->__isset.uiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetMode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetMode_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetMode_pargs::~HalApi_OPS_SetMode_pargs() noexcept {
}


uint32_t HalApi_OPS_SetMode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetMode_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiMode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetMode_result::~HalApi_OPS_SetMode_result() noexcept {
}


uint32_t HalApi_OPS_SetMode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetMode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetMode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetMode_presult::~HalApi_OPS_SetMode_presult() noexcept {
}


uint32_t HalApi_OPS_SetMode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetRelativeThr_args::~HalApi_OPS_SetRelativeThr_args() noexcept {
}


uint32_t HalApi_OPS_SetRelativeThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRelativeThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRelativeThr_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRelativeThr_pargs::~HalApi_OPS_SetRelativeThr_pargs() noexcept {
}


uint32_t HalApi_OPS_SetRelativeThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRelativeThr_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRelativeThr_result::~HalApi_OPS_SetRelativeThr_result() noexcept {
}


uint32_t HalApi_OPS_SetRelativeThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRelativeThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetRelativeThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRelativeThr_presult::~HalApi_OPS_SetRelativeThr_presult() noexcept {
}


uint32_t HalApi_OPS_SetRelativeThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetRelativeOffset_args::~HalApi_OPS_SetRelativeOffset_args() noexcept {
}


uint32_t HalApi_OPS_SetRelativeOffset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sOffset);
          this->__isset.sOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRelativeOffset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRelativeOffset_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOffset", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->sOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRelativeOffset_pargs::~HalApi_OPS_SetRelativeOffset_pargs() noexcept {
}


uint32_t HalApi_OPS_SetRelativeOffset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRelativeOffset_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sOffset", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16((*(this->sOffset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRelativeOffset_result::~HalApi_OPS_SetRelativeOffset_result() noexcept {
}


uint32_t HalApi_OPS_SetRelativeOffset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRelativeOffset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetRelativeOffset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRelativeOffset_presult::~HalApi_OPS_SetRelativeOffset_presult() noexcept {
}


uint32_t HalApi_OPS_SetRelativeOffset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetSwitchThr_args::~HalApi_OPS_SetSwitchThr_args() noexcept {
}


uint32_t HalApi_OPS_SetSwitchThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPos);
          this->__isset.uiPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iThr);
          this->__isset.iThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetSwitchThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchThr_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iThr", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchThr_pargs::~HalApi_OPS_SetSwitchThr_pargs() noexcept {
}


uint32_t HalApi_OPS_SetSwitchThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchThr_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iThr", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchThr_result::~HalApi_OPS_SetSwitchThr_result() noexcept {
}


uint32_t HalApi_OPS_SetSwitchThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetSwitchThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchThr_presult::~HalApi_OPS_SetSwitchThr_presult() noexcept {
}


uint32_t HalApi_OPS_SetSwitchThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetSwitchHys_args::~HalApi_OPS_SetSwitchHys_args() noexcept {
}


uint32_t HalApi_OPS_SetSwitchHys_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPos);
          this->__isset.uiPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iHys);
          this->__isset.iHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetSwitchHys_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchHys_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iHys", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchHys_pargs::~HalApi_OPS_SetSwitchHys_pargs() noexcept {
}


uint32_t HalApi_OPS_SetSwitchHys_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchHys_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iHys", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchHys_result::~HalApi_OPS_SetSwitchHys_result() noexcept {
}


uint32_t HalApi_OPS_SetSwitchHys_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetSwitchHys_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchHys_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchHys_presult::~HalApi_OPS_SetSwitchHys_presult() noexcept {
}


uint32_t HalApi_OPS_SetSwitchHys_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_Reset_args::~HalApi_OPS_Reset_args() noexcept {
}


uint32_t HalApi_OPS_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_Reset_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_Reset_pargs::~HalApi_OPS_Reset_pargs() noexcept {
}


uint32_t HalApi_OPS_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_Reset_result::~HalApi_OPS_Reset_result() noexcept {
}


uint32_t HalApi_OPS_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_Reset_presult::~HalApi_OPS_Reset_presult() noexcept {
}


uint32_t HalApi_OPS_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_Upgrade_args::~HalApi_OPS_Upgrade_args() noexcept {
}


uint32_t HalApi_OPS_Upgrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_Upgrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_Upgrade_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_Upgrade_pargs::~HalApi_OPS_Upgrade_pargs() noexcept {
}


uint32_t HalApi_OPS_Upgrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_Upgrade_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_Upgrade_result::~HalApi_OPS_Upgrade_result() noexcept {
}


uint32_t HalApi_OPS_Upgrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_Upgrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_Upgrade_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_Upgrade_presult::~HalApi_OPS_Upgrade_presult() noexcept {
}


uint32_t HalApi_OPS_Upgrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetUpgadeStatus_args::~HalApi_OPS_GetUpgadeStatus_args() noexcept {
}


uint32_t HalApi_OPS_GetUpgadeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetUpgadeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetUpgadeStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetUpgadeStatus_pargs::~HalApi_OPS_GetUpgadeStatus_pargs() noexcept {
}


uint32_t HalApi_OPS_GetUpgadeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetUpgadeStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetUpgadeStatus_result::~HalApi_OPS_GetUpgadeStatus_result() noexcept {
}


uint32_t HalApi_OPS_GetUpgadeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetUpgadeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetUpgadeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetUpgadeStatus_presult::~HalApi_OPS_GetUpgadeStatus_presult() noexcept {
}


uint32_t HalApi_OPS_GetUpgadeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetLedDebugMode_args::~HalApi_OPS_SetLedDebugMode_args() noexcept {
}


uint32_t HalApi_OPS_SetLedDebugMode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMode);
          this->__isset.uiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetLedDebugMode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetLedDebugMode_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetLedDebugMode_pargs::~HalApi_OPS_SetLedDebugMode_pargs() noexcept {
}


uint32_t HalApi_OPS_SetLedDebugMode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetLedDebugMode_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiMode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetLedDebugMode_result::~HalApi_OPS_SetLedDebugMode_result() noexcept {
}


uint32_t HalApi_OPS_SetLedDebugMode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetLedDebugMode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetLedDebugMode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetLedDebugMode_presult::~HalApi_OPS_SetLedDebugMode_presult() noexcept {
}


uint32_t HalApi_OPS_SetLedDebugMode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetLedStatus_args::~HalApi_OPS_SetLedStatus_args() noexcept {
}


uint32_t HalApi_OPS_SetLedStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLedIdx);
          this->__isset.uiLedIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiStatus);
          this->__isset.uiStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetLedStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetLedStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiLedIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiStatus", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetLedStatus_pargs::~HalApi_OPS_SetLedStatus_pargs() noexcept {
}


uint32_t HalApi_OPS_SetLedStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetLedStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiLedIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiStatus", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiStatus)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetLedStatus_result::~HalApi_OPS_SetLedStatus_result() noexcept {
}


uint32_t HalApi_OPS_SetLedStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetLedStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetLedStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetLedStatus_presult::~HalApi_OPS_SetLedStatus_presult() noexcept {
}


uint32_t HalApi_OPS_SetLedStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetConnectionPdThr_args::~HalApi_OPS_SetConnectionPdThr_args() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPdIdx);
          this->__isset.uiPdIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiType);
          this->__isset.uiType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetConnectionPdThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetConnectionPdThr_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPdIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPdIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetConnectionPdThr_pargs::~HalApi_OPS_SetConnectionPdThr_pargs() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetConnectionPdThr_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPdIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPdIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetConnectionPdThr_result::~HalApi_OPS_SetConnectionPdThr_result() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetConnectionPdThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetConnectionPdThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetConnectionPdThr_presult::~HalApi_OPS_SetConnectionPdThr_presult() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetConnectionPdHys_args::~HalApi_OPS_SetConnectionPdHys_args() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdHys_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPdIdx);
          this->__isset.uiPdIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiType);
          this->__isset.uiType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetConnectionPdHys_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetConnectionPdHys_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPdIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPdIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetConnectionPdHys_pargs::~HalApi_OPS_SetConnectionPdHys_pargs() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdHys_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetConnectionPdHys_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPdIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPdIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetConnectionPdHys_result::~HalApi_OPS_SetConnectionPdHys_result() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdHys_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetConnectionPdHys_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetConnectionPdHys_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetConnectionPdHys_presult::~HalApi_OPS_SetConnectionPdHys_presult() noexcept {
}


uint32_t HalApi_OPS_SetConnectionPdHys_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetAlmMask_args::~HalApi_OPS_SetAlmMask_args() noexcept {
}


uint32_t HalApi_OPS_SetAlmMask_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMaskIdx);
          this->__isset.iMaskIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMaskVal);
          this->__isset.iMaskVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetAlmMask_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetAlmMask_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iMaskIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskVal", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iMaskVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetAlmMask_pargs::~HalApi_OPS_SetAlmMask_pargs() noexcept {
}


uint32_t HalApi_OPS_SetAlmMask_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetAlmMask_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iMaskIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMaskVal", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iMaskVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetAlmMask_result::~HalApi_OPS_SetAlmMask_result() noexcept {
}


uint32_t HalApi_OPS_SetAlmMask_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetAlmMask_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetAlmMask_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetAlmMask_presult::~HalApi_OPS_SetAlmMask_presult() noexcept {
}


uint32_t HalApi_OPS_SetAlmMask_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetEventLog_args::~HalApi_OPS_GetEventLog_args() noexcept {
}


uint32_t HalApi_OPS_GetEventLog_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetEventLog_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetEventLog_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetEventLog_pargs::~HalApi_OPS_GetEventLog_pargs() noexcept {
}


uint32_t HalApi_OPS_GetEventLog_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetEventLog_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetEventLog_result::~HalApi_OPS_GetEventLog_result() noexcept {
}


uint32_t HalApi_OPS_GetEventLog_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetEventLog_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetEventLog_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetEventLog_presult::~HalApi_OPS_GetEventLog_presult() noexcept {
}


uint32_t HalApi_OPS_GetEventLog_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetRemoteStatus_args::~HalApi_OPS_SetRemoteStatus_args() noexcept {
}


uint32_t HalApi_OPS_SetRemoteStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pstStatus.read(iprot);
          this->__isset.pstStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRemoteStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRemoteStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstStatus", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pstStatus.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRemoteStatus_pargs::~HalApi_OPS_SetRemoteStatus_pargs() noexcept {
}


uint32_t HalApi_OPS_SetRemoteStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetRemoteStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstStatus", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->pstStatus)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRemoteStatus_result::~HalApi_OPS_SetRemoteStatus_result() noexcept {
}


uint32_t HalApi_OPS_SetRemoteStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetRemoteStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetRemoteStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetRemoteStatus_presult::~HalApi_OPS_SetRemoteStatus_presult() noexcept {
}


uint32_t HalApi_OPS_SetRemoteStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetRequestStatus_args::~HalApi_OPS_GetRequestStatus_args() noexcept {
}


uint32_t HalApi_OPS_GetRequestStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetRequestStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetRequestStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetRequestStatus_pargs::~HalApi_OPS_GetRequestStatus_pargs() noexcept {
}


uint32_t HalApi_OPS_GetRequestStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetRequestStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetRequestStatus_result::~HalApi_OPS_GetRequestStatus_result() noexcept {
}


uint32_t HalApi_OPS_GetRequestStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetRequestStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetRequestStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetRequestStatus_presult::~HalApi_OPS_GetRequestStatus_presult() noexcept {
}


uint32_t HalApi_OPS_GetRequestStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_SetSwitchingType_args::~HalApi_OPS_SetSwitchingType_args() noexcept {
}


uint32_t HalApi_OPS_SetSwitchingType_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucType);
          this->__isset.ucType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortId);
          this->__isset.uiPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetSwitchingType_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchingType_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchingType_pargs::~HalApi_OPS_SetSwitchingType_pargs() noexcept {
}


uint32_t HalApi_OPS_SetSwitchingType_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchingType_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchingType_result::~HalApi_OPS_SetSwitchingType_result() noexcept {
}


uint32_t HalApi_OPS_SetSwitchingType_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_SetSwitchingType_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_SetSwitchingType_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_SetSwitchingType_presult::~HalApi_OPS_SetSwitchingType_presult() noexcept {
}


uint32_t HalApi_OPS_SetSwitchingType_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OPS_GetOpsDevIdByKey_args::~HalApi_OPS_GetOpsDevIdByKey_args() noexcept {
}


uint32_t HalApi_OPS_GetOpsDevIdByKey_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pcName);
          this->__isset.pcName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetOpsDevIdByKey_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetOpsDevIdByKey_args");

  xfer += oprot->writeFieldBegin("pcName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pcName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetOpsDevIdByKey_pargs::~HalApi_OPS_GetOpsDevIdByKey_pargs() noexcept {
}


uint32_t HalApi_OPS_GetOpsDevIdByKey_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OPS_GetOpsDevIdByKey_pargs");

  xfer += oprot->writeFieldBegin("pcName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->pcName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetOpsDevIdByKey_result::~HalApi_OPS_GetOpsDevIdByKey_result() noexcept {
}


uint32_t HalApi_OPS_GetOpsDevIdByKey_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OPS_GetOpsDevIdByKey_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OPS_GetOpsDevIdByKey_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OPS_GetOpsDevIdByKey_presult::~HalApi_OPS_GetOpsDevIdByKey_presult() noexcept {
}


uint32_t HalApi_OPS_GetOpsDevIdByKey_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OSC_GetStatusData_args::~HalApi_OSC_GetStatusData_args() noexcept {
}


uint32_t HalApi_OSC_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetStatusData_pargs::~HalApi_OSC_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_OSC_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetStatusData_result::~HalApi_OSC_GetStatusData_result() noexcept {
}


uint32_t HalApi_OSC_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OSC_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetStatusData_presult::~HalApi_OSC_GetStatusData_presult() noexcept {
}


uint32_t HalApi_OSC_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OSC_GetCfgData_args::~HalApi_OSC_GetCfgData_args() noexcept {
}


uint32_t HalApi_OSC_GetCfgData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetCfgData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetCfgData_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetCfgData_pargs::~HalApi_OSC_GetCfgData_pargs() noexcept {
}


uint32_t HalApi_OSC_GetCfgData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetCfgData_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetCfgData_result::~HalApi_OSC_GetCfgData_result() noexcept {
}


uint32_t HalApi_OSC_GetCfgData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetCfgData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OSC_GetCfgData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetCfgData_presult::~HalApi_OSC_GetCfgData_presult() noexcept {
}


uint32_t HalApi_OSC_GetCfgData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OSC_SetEnable_args::~HalApi_OSC_SetEnable_args() noexcept {
}


uint32_t HalApi_OSC_SetEnable_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_SetEnable_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_SetEnable_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetEnable_pargs::~HalApi_OSC_SetEnable_pargs() noexcept {
}


uint32_t HalApi_OSC_SetEnable_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_SetEnable_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bEnable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetEnable_result::~HalApi_OSC_SetEnable_result() noexcept {
}


uint32_t HalApi_OSC_SetEnable_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_SetEnable_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OSC_SetEnable_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetEnable_presult::~HalApi_OSC_SetEnable_presult() noexcept {
}


uint32_t HalApi_OSC_SetEnable_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OSC_SetVoa_args::~HalApi_OSC_SetVoa_args() noexcept {
}


uint32_t HalApi_OSC_SetVoa_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiTxRx);
          this->__isset.uiTxRx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sAttn);
          this->__isset.sAttn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_SetVoa_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_SetVoa_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiTxRx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiTxRx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAttn", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->sAttn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetVoa_pargs::~HalApi_OSC_SetVoa_pargs() noexcept {
}


uint32_t HalApi_OSC_SetVoa_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_SetVoa_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiTxRx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiTxRx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sAttn", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16((*(this->sAttn)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetVoa_result::~HalApi_OSC_SetVoa_result() noexcept {
}


uint32_t HalApi_OSC_SetVoa_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_SetVoa_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OSC_SetVoa_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetVoa_presult::~HalApi_OSC_SetVoa_presult() noexcept {
}


uint32_t HalApi_OSC_SetVoa_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OSC_GetVoa_args::~HalApi_OSC_GetVoa_args() noexcept {
}


uint32_t HalApi_OSC_GetVoa_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiTxRx);
          this->__isset.uiTxRx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetVoa_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetVoa_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiTxRx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiTxRx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetVoa_pargs::~HalApi_OSC_GetVoa_pargs() noexcept {
}


uint32_t HalApi_OSC_GetVoa_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetVoa_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiTxRx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiTxRx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetVoa_result::~HalApi_OSC_GetVoa_result() noexcept {
}


uint32_t HalApi_OSC_GetVoa_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetVoa_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OSC_GetVoa_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetVoa_presult::~HalApi_OSC_GetVoa_presult() noexcept {
}


uint32_t HalApi_OSC_GetVoa_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OSC_SetSwitchPos_args::~HalApi_OSC_SetSwitchPos_args() noexcept {
}


uint32_t HalApi_OSC_SetSwitchPos_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rstSwitchPos.read(iprot);
          this->__isset.rstSwitchPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_SetSwitchPos_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_SetSwitchPos_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rstSwitchPos", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->rstSwitchPos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetSwitchPos_pargs::~HalApi_OSC_SetSwitchPos_pargs() noexcept {
}


uint32_t HalApi_OSC_SetSwitchPos_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_SetSwitchPos_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rstSwitchPos", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->rstSwitchPos)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetSwitchPos_result::~HalApi_OSC_SetSwitchPos_result() noexcept {
}


uint32_t HalApi_OSC_SetSwitchPos_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_SetSwitchPos_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OSC_SetSwitchPos_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_SetSwitchPos_presult::~HalApi_OSC_SetSwitchPos_presult() noexcept {
}


uint32_t HalApi_OSC_SetSwitchPos_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OSC_GetSwitchPos_args::~HalApi_OSC_GetSwitchPos_args() noexcept {
}


uint32_t HalApi_OSC_GetSwitchPos_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetSwitchPos_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetSwitchPos_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetSwitchPos_pargs::~HalApi_OSC_GetSwitchPos_pargs() noexcept {
}


uint32_t HalApi_OSC_GetSwitchPos_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OSC_GetSwitchPos_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetSwitchPos_result::~HalApi_OSC_GetSwitchPos_result() noexcept {
}


uint32_t HalApi_OSC_GetSwitchPos_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OSC_GetSwitchPos_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OSC_GetSwitchPos_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OSC_GetSwitchPos_presult::~HalApi_OSC_GetSwitchPos_presult() noexcept {
}


uint32_t HalApi_OSC_GetSwitchPos_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_GetMfg_args::~HalApi_OTDR_GetMfg_args() noexcept {
}


uint32_t HalApi_OTDR_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetMfg_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetMfg_pargs::~HalApi_OTDR_GetMfg_pargs() noexcept {
}


uint32_t HalApi_OTDR_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetMfg_result::~HalApi_OTDR_GetMfg_result() noexcept {
}


uint32_t HalApi_OTDR_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetMfg_presult::~HalApi_OTDR_GetMfg_presult() noexcept {
}


uint32_t HalApi_OTDR_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_GetStatusData_args::~HalApi_OTDR_GetStatusData_args() noexcept {
}


uint32_t HalApi_OTDR_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetStatusData_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetStatusData_pargs::~HalApi_OTDR_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_OTDR_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetStatusData_result::~HalApi_OTDR_GetStatusData_result() noexcept {
}


uint32_t HalApi_OTDR_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetStatusData_presult::~HalApi_OTDR_GetStatusData_presult() noexcept {
}


uint32_t HalApi_OTDR_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_GetCfgData_args::~HalApi_OTDR_GetCfgData_args() noexcept {
}


uint32_t HalApi_OTDR_GetCfgData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetCfgData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetCfgData_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetCfgData_pargs::~HalApi_OTDR_GetCfgData_pargs() noexcept {
}


uint32_t HalApi_OTDR_GetCfgData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetCfgData_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetCfgData_result::~HalApi_OTDR_GetCfgData_result() noexcept {
}


uint32_t HalApi_OTDR_GetCfgData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetCfgData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_GetCfgData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetCfgData_presult::~HalApi_OTDR_GetCfgData_presult() noexcept {
}


uint32_t HalApi_OTDR_GetCfgData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_StartScan_args::~HalApi_OTDR_StartScan_args() noexcept {
}


uint32_t HalApi_OTDR_StartScan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_StartScan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_StartScan_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_StartScan_pargs::~HalApi_OTDR_StartScan_pargs() noexcept {
}


uint32_t HalApi_OTDR_StartScan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_StartScan_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_StartScan_result::~HalApi_OTDR_StartScan_result() noexcept {
}


uint32_t HalApi_OTDR_StartScan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_StartScan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_StartScan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_StartScan_presult::~HalApi_OTDR_StartScan_presult() noexcept {
}


uint32_t HalApi_OTDR_StartScan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_SetPara_args::~HalApi_OTDR_SetPara_args() noexcept {
}


uint32_t HalApi_OTDR_SetPara_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDistRang);
          this->__isset.ulDistRang = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPulseWidth);
          this->__isset.ulPulseWidth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dSamplingResolution);
          this->__isset.dSamplingResolution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetPara_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetPara_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulDistRang", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulDistRang);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPulseWidth", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ulPulseWidth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dSamplingResolution", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->dSamplingResolution);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetPara_pargs::~HalApi_OTDR_SetPara_pargs() noexcept {
}


uint32_t HalApi_OTDR_SetPara_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetPara_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulDistRang", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulDistRang)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPulseWidth", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->ulPulseWidth)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dSamplingResolution", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->dSamplingResolution)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetPara_result::~HalApi_OTDR_SetPara_result() noexcept {
}


uint32_t HalApi_OTDR_SetPara_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetPara_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_SetPara_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetPara_presult::~HalApi_OTDR_SetPara_presult() noexcept {
}


uint32_t HalApi_OTDR_SetPara_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_SetMeasuringTime_args::~HalApi_OTDR_SetMeasuringTime_args() noexcept {
}


uint32_t HalApi_OTDR_SetMeasuringTime_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulMeasuringTime);
          this->__isset.ulMeasuringTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetMeasuringTime_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetMeasuringTime_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulMeasuringTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulMeasuringTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetMeasuringTime_pargs::~HalApi_OTDR_SetMeasuringTime_pargs() noexcept {
}


uint32_t HalApi_OTDR_SetMeasuringTime_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetMeasuringTime_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulMeasuringTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulMeasuringTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetMeasuringTime_result::~HalApi_OTDR_SetMeasuringTime_result() noexcept {
}


uint32_t HalApi_OTDR_SetMeasuringTime_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetMeasuringTime_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_SetMeasuringTime_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetMeasuringTime_presult::~HalApi_OTDR_SetMeasuringTime_presult() noexcept {
}


uint32_t HalApi_OTDR_SetMeasuringTime_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_SetUserIOR_args::~HalApi_OTDR_SetUserIOR_args() noexcept {
}


uint32_t HalApi_OTDR_SetUserIOR_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dUserIOR);
          this->__isset.dUserIOR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetUserIOR_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetUserIOR_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dUserIOR", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->dUserIOR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetUserIOR_pargs::~HalApi_OTDR_SetUserIOR_pargs() noexcept {
}


uint32_t HalApi_OTDR_SetUserIOR_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetUserIOR_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dUserIOR", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->dUserIOR)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetUserIOR_result::~HalApi_OTDR_SetUserIOR_result() noexcept {
}


uint32_t HalApi_OTDR_SetUserIOR_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetUserIOR_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_SetUserIOR_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetUserIOR_presult::~HalApi_OTDR_SetUserIOR_presult() noexcept {
}


uint32_t HalApi_OTDR_SetUserIOR_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_SetThr_args::~HalApi_OTDR_SetThr_args() noexcept {
}


uint32_t HalApi_OTDR_SetThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dRefThr);
          this->__isset.dRefThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dSpliceLosThr);
          this->__isset.dSpliceLosThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dFiberEndThr);
          this->__isset.dFiberEndThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetThr_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dRefThr", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->dRefThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dSpliceLosThr", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dSpliceLosThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dFiberEndThr", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->dFiberEndThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetThr_pargs::~HalApi_OTDR_SetThr_pargs() noexcept {
}


uint32_t HalApi_OTDR_SetThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetThr_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dRefThr", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->dRefThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dSpliceLosThr", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble((*(this->dSpliceLosThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dFiberEndThr", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->dFiberEndThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetThr_result::~HalApi_OTDR_SetThr_result() noexcept {
}


uint32_t HalApi_OTDR_SetThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_SetThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetThr_presult::~HalApi_OTDR_SetThr_presult() noexcept {
}


uint32_t HalApi_OTDR_SetThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_Reset_args::~HalApi_OTDR_Reset_args() noexcept {
}


uint32_t HalApi_OTDR_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_Reset_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_Reset_pargs::~HalApi_OTDR_Reset_pargs() noexcept {
}


uint32_t HalApi_OTDR_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_Reset_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_Reset_result::~HalApi_OTDR_Reset_result() noexcept {
}


uint32_t HalApi_OTDR_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_Reset_presult::~HalApi_OTDR_Reset_presult() noexcept {
}


uint32_t HalApi_OTDR_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_Upgrade_args::~HalApi_OTDR_Upgrade_args() noexcept {
}


uint32_t HalApi_OTDR_Upgrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_Upgrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_Upgrade_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_Upgrade_pargs::~HalApi_OTDR_Upgrade_pargs() noexcept {
}


uint32_t HalApi_OTDR_Upgrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_Upgrade_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_Upgrade_result::~HalApi_OTDR_Upgrade_result() noexcept {
}


uint32_t HalApi_OTDR_Upgrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_Upgrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_Upgrade_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_Upgrade_presult::~HalApi_OTDR_Upgrade_presult() noexcept {
}


uint32_t HalApi_OTDR_Upgrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_GetUpgadeStatus_args::~HalApi_OTDR_GetUpgadeStatus_args() noexcept {
}


uint32_t HalApi_OTDR_GetUpgadeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetUpgadeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetUpgadeStatus_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetUpgadeStatus_pargs::~HalApi_OTDR_GetUpgadeStatus_pargs() noexcept {
}


uint32_t HalApi_OTDR_GetUpgadeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetUpgadeStatus_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetUpgadeStatus_result::~HalApi_OTDR_GetUpgadeStatus_result() noexcept {
}


uint32_t HalApi_OTDR_GetUpgadeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetUpgadeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_GetUpgadeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetUpgadeStatus_presult::~HalApi_OTDR_GetUpgadeStatus_presult() noexcept {
}


uint32_t HalApi_OTDR_GetUpgadeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_DbgRead_args::~HalApi_OTDR_DbgRead_args() noexcept {
}


uint32_t HalApi_OTDR_DbgRead_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLen);
          this->__isset.uiLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_DbgRead_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_DbgRead_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_DbgRead_pargs::~HalApi_OTDR_DbgRead_pargs() noexcept {
}


uint32_t HalApi_OTDR_DbgRead_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_DbgRead_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_DbgRead_result::~HalApi_OTDR_DbgRead_result() noexcept {
}


uint32_t HalApi_OTDR_DbgRead_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_DbgRead_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_DbgRead_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_DbgRead_presult::~HalApi_OTDR_DbgRead_presult() noexcept {
}


uint32_t HalApi_OTDR_DbgRead_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_DbgWrite_args::~HalApi_OTDR_DbgWrite_args() noexcept {
}


uint32_t HalApi_OTDR_DbgWrite_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucBuf);
          this->__isset.pucBuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLen);
          this->__isset.uiLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_DbgWrite_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_DbgWrite_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pucBuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_DbgWrite_pargs::~HalApi_OTDR_DbgWrite_pargs() noexcept {
}


uint32_t HalApi_OTDR_DbgWrite_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_DbgWrite_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucBuf", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->pucBuf)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_DbgWrite_result::~HalApi_OTDR_DbgWrite_result() noexcept {
}


uint32_t HalApi_OTDR_DbgWrite_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_DbgWrite_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_DbgWrite_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_DbgWrite_presult::~HalApi_OTDR_DbgWrite_presult() noexcept {
}


uint32_t HalApi_OTDR_DbgWrite_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_SetScanMode_args::~HalApi_OTDR_SetScanMode_args() noexcept {
}


uint32_t HalApi_OTDR_SetScanMode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulScanMode);
          this->__isset.ulScanMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetScanMode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetScanMode_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulScanMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulScanMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetScanMode_pargs::~HalApi_OTDR_SetScanMode_pargs() noexcept {
}


uint32_t HalApi_OTDR_SetScanMode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetScanMode_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulScanMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulScanMode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetScanMode_result::~HalApi_OTDR_SetScanMode_result() noexcept {
}


uint32_t HalApi_OTDR_SetScanMode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetScanMode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_SetScanMode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetScanMode_presult::~HalApi_OTDR_SetScanMode_presult() noexcept {
}


uint32_t HalApi_OTDR_SetScanMode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_SetStartOffset_args::~HalApi_OTDR_SetStartOffset_args() noexcept {
}


uint32_t HalApi_OTDR_SetStartOffset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pstStartOffset.read(iprot);
          this->__isset.pstStartOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetStartOffset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetStartOffset_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstStartOffset", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pstStartOffset.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetStartOffset_pargs::~HalApi_OTDR_SetStartOffset_pargs() noexcept {
}


uint32_t HalApi_OTDR_SetStartOffset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_SetStartOffset_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstStartOffset", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->pstStartOffset)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetStartOffset_result::~HalApi_OTDR_SetStartOffset_result() noexcept {
}


uint32_t HalApi_OTDR_SetStartOffset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_SetStartOffset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_SetStartOffset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_SetStartOffset_presult::~HalApi_OTDR_SetStartOffset_presult() noexcept {
}


uint32_t HalApi_OTDR_SetStartOffset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_GetStartOffset_args::~HalApi_OTDR_GetStartOffset_args() noexcept {
}


uint32_t HalApi_OTDR_GetStartOffset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetStartOffset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetStartOffset_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetStartOffset_pargs::~HalApi_OTDR_GetStartOffset_pargs() noexcept {
}


uint32_t HalApi_OTDR_GetStartOffset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_GetStartOffset_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetStartOffset_result::~HalApi_OTDR_GetStartOffset_result() noexcept {
}


uint32_t HalApi_OTDR_GetStartOffset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_GetStartOffset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_GetStartOffset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_GetStartOffset_presult::~HalApi_OTDR_GetStartOffset_presult() noexcept {
}


uint32_t HalApi_OTDR_GetStartOffset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_OTDR_StartScanPort_args::~HalApi_OTDR_StartScanPort_args() noexcept {
}


uint32_t HalApi_OTDR_StartScanPort_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulDevIdx);
          this->__isset.ulDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ulPortId);
          this->__isset.ulPortId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_StartScanPort_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_StartScanPort_args");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ulDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ulPortId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_StartScanPort_pargs::~HalApi_OTDR_StartScanPort_pargs() noexcept {
}


uint32_t HalApi_OTDR_StartScanPort_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_OTDR_StartScanPort_pargs");

  xfer += oprot->writeFieldBegin("ulDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->ulDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulPortId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ulPortId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_StartScanPort_result::~HalApi_OTDR_StartScanPort_result() noexcept {
}


uint32_t HalApi_OTDR_StartScanPort_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_OTDR_StartScanPort_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_OTDR_StartScanPort_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_OTDR_StartScanPort_presult::~HalApi_OTDR_StartScanPort_presult() noexcept {
}


uint32_t HalApi_OTDR_StartScanPort_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_GetDevIdx_args::~HalApi_SLOT_GetDevIdx_args() noexcept {
}


uint32_t HalApi_SLOT_GetDevIdx_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevType);
          this->__isset.uiDevType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetDevIdx_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetDevIdx_args");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetDevIdx_pargs::~HalApi_SLOT_GetDevIdx_pargs() noexcept {
}


uint32_t HalApi_SLOT_GetDevIdx_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetDevIdx_pargs");

  xfer += oprot->writeFieldBegin("uiDevType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetDevIdx_result::~HalApi_SLOT_GetDevIdx_result() noexcept {
}


uint32_t HalApi_SLOT_GetDevIdx_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetDevIdx_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_GetDevIdx_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetDevIdx_presult::~HalApi_SLOT_GetDevIdx_presult() noexcept {
}


uint32_t HalApi_SLOT_GetDevIdx_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_SetOnline_args::~HalApi_SLOT_SetOnline_args() noexcept {
}


uint32_t HalApi_SLOT_SetOnline_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOnline);
          this->__isset.bOnline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetOnline_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetOnline_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOnline", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bOnline);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetOnline_pargs::~HalApi_SLOT_SetOnline_pargs() noexcept {
}


uint32_t HalApi_SLOT_SetOnline_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetOnline_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bOnline", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->bOnline)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetOnline_result::~HalApi_SLOT_SetOnline_result() noexcept {
}


uint32_t HalApi_SLOT_SetOnline_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetOnline_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_SetOnline_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetOnline_presult::~HalApi_SLOT_SetOnline_presult() noexcept {
}


uint32_t HalApi_SLOT_SetOnline_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_GetSlotNum_args::~HalApi_SLOT_GetSlotNum_args() noexcept {
}


uint32_t HalApi_SLOT_GetSlotNum_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetSlotNum_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetSlotNum_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetSlotNum_pargs::~HalApi_SLOT_GetSlotNum_pargs() noexcept {
}


uint32_t HalApi_SLOT_GetSlotNum_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetSlotNum_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetSlotNum_result::~HalApi_SLOT_GetSlotNum_result() noexcept {
}


uint32_t HalApi_SLOT_GetSlotNum_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetSlotNum_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_GetSlotNum_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetSlotNum_presult::~HalApi_SLOT_GetSlotNum_presult() noexcept {
}


uint32_t HalApi_SLOT_GetSlotNum_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_SetMfg_args::~HalApi_SLOT_SetMfg_args() noexcept {
}


uint32_t HalApi_SLOT_SetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetMfg_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetMfg_pargs::~HalApi_SLOT_SetMfg_pargs() noexcept {
}


uint32_t HalApi_SLOT_SetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetMfg_result::~HalApi_SLOT_SetMfg_result() noexcept {
}


uint32_t HalApi_SLOT_SetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_SetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetMfg_presult::~HalApi_SLOT_SetMfg_presult() noexcept {
}


uint32_t HalApi_SLOT_SetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_GetMfg_args::~HalApi_SLOT_GetMfg_args() noexcept {
}


uint32_t HalApi_SLOT_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetMfg_pargs::~HalApi_SLOT_GetMfg_pargs() noexcept {
}


uint32_t HalApi_SLOT_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetMfg_result::~HalApi_SLOT_GetMfg_result() noexcept {
}


uint32_t HalApi_SLOT_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetMfg_presult::~HalApi_SLOT_GetMfg_presult() noexcept {
}


uint32_t HalApi_SLOT_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_GetStatusData_args::~HalApi_SLOT_GetStatusData_args() noexcept {
}


uint32_t HalApi_SLOT_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetStatusData_pargs::~HalApi_SLOT_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_SLOT_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetStatusData_result::~HalApi_SLOT_GetStatusData_result() noexcept {
}


uint32_t HalApi_SLOT_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetStatusData_presult::~HalApi_SLOT_GetStatusData_presult() noexcept {
}


uint32_t HalApi_SLOT_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_ClearPlugFlag_args::~HalApi_SLOT_ClearPlugFlag_args() noexcept {
}


uint32_t HalApi_SLOT_ClearPlugFlag_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_ClearPlugFlag_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_ClearPlugFlag_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_ClearPlugFlag_pargs::~HalApi_SLOT_ClearPlugFlag_pargs() noexcept {
}


uint32_t HalApi_SLOT_ClearPlugFlag_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_ClearPlugFlag_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_ClearPlugFlag_result::~HalApi_SLOT_ClearPlugFlag_result() noexcept {
}


uint32_t HalApi_SLOT_ClearPlugFlag_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_ClearPlugFlag_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_ClearPlugFlag_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_ClearPlugFlag_presult::~HalApi_SLOT_ClearPlugFlag_presult() noexcept {
}


uint32_t HalApi_SLOT_ClearPlugFlag_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_GetInfo_args::~HalApi_SLOT_GetInfo_args() noexcept {
}


uint32_t HalApi_SLOT_GetInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetInfo_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetInfo_pargs::~HalApi_SLOT_GetInfo_pargs() noexcept {
}


uint32_t HalApi_SLOT_GetInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetInfo_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetInfo_result::~HalApi_SLOT_GetInfo_result() noexcept {
}


uint32_t HalApi_SLOT_GetInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_GetInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetInfo_presult::~HalApi_SLOT_GetInfo_presult() noexcept {
}


uint32_t HalApi_SLOT_GetInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_GetCali_args::~HalApi_SLOT_GetCali_args() noexcept {
}


uint32_t HalApi_SLOT_GetCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetCali_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetCali_pargs::~HalApi_SLOT_GetCali_pargs() noexcept {
}


uint32_t HalApi_SLOT_GetCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_GetCali_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetCali_result::~HalApi_SLOT_GetCali_result() noexcept {
}


uint32_t HalApi_SLOT_GetCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_GetCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_GetCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_GetCali_presult::~HalApi_SLOT_GetCali_presult() noexcept {
}


uint32_t HalApi_SLOT_GetCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_SetCali_args::~HalApi_SLOT_SetCali_args() noexcept {
}


uint32_t HalApi_SLOT_SetCali_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetCali_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetCali_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetCali_pargs::~HalApi_SLOT_SetCali_pargs() noexcept {
}


uint32_t HalApi_SLOT_SetCali_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetCali_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetCali_result::~HalApi_SLOT_SetCali_result() noexcept {
}


uint32_t HalApi_SLOT_SetCali_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetCali_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_SetCali_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetCali_presult::~HalApi_SLOT_SetCali_presult() noexcept {
}


uint32_t HalApi_SLOT_SetCali_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_Reset_args::~HalApi_SLOT_Reset_args() noexcept {
}


uint32_t HalApi_SLOT_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_Reset_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_Reset_pargs::~HalApi_SLOT_Reset_pargs() noexcept {
}


uint32_t HalApi_SLOT_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_Reset_result::~HalApi_SLOT_Reset_result() noexcept {
}


uint32_t HalApi_SLOT_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_Reset_presult::~HalApi_SLOT_Reset_presult() noexcept {
}


uint32_t HalApi_SLOT_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_SetLed_args::~HalApi_SLOT_SetLed_args() noexcept {
}


uint32_t HalApi_SLOT_SetLed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSlotIdx);
          this->__isset.uiSlotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLedIdx);
          this->__isset.uiLedIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiState);
          this->__isset.uiState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetLed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetLed_args");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiSlotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiLedIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetLed_pargs::~HalApi_SLOT_SetLed_pargs() noexcept {
}


uint32_t HalApi_SLOT_SetLed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_SetLed_pargs");

  xfer += oprot->writeFieldBegin("uiSlotIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiSlotIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiLedIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiState", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiState)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetLed_result::~HalApi_SLOT_SetLed_result() noexcept {
}


uint32_t HalApi_SLOT_SetLed_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_SetLed_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_SetLed_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_SetLed_presult::~HalApi_SLOT_SetLed_presult() noexcept {
}


uint32_t HalApi_SLOT_SetLed_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_ReadEeprom_args::~HalApi_SLOT_ReadEeprom_args() noexcept {
}


uint32_t HalApi_SLOT_ReadEeprom_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_ReadEeprom_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_ReadEeprom_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_ReadEeprom_pargs::~HalApi_SLOT_ReadEeprom_pargs() noexcept {
}


uint32_t HalApi_SLOT_ReadEeprom_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_ReadEeprom_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_ReadEeprom_result::~HalApi_SLOT_ReadEeprom_result() noexcept {
}


uint32_t HalApi_SLOT_ReadEeprom_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_ReadEeprom_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_ReadEeprom_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_ReadEeprom_presult::~HalApi_SLOT_ReadEeprom_presult() noexcept {
}


uint32_t HalApi_SLOT_ReadEeprom_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_SLOT_WriteEeprom_args::~HalApi_SLOT_WriteEeprom_args() noexcept {
}


uint32_t HalApi_SLOT_WriteEeprom_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiIdx);
          this->__isset.uiIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulAddr);
          this->__isset.ulAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ulLen);
          this->__isset.ulLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucVal);
          this->__isset.pucVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_WriteEeprom_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_WriteEeprom_args");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ulAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ulLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->pucVal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_WriteEeprom_pargs::~HalApi_SLOT_WriteEeprom_pargs() noexcept {
}


uint32_t HalApi_SLOT_WriteEeprom_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_SLOT_WriteEeprom_pargs");

  xfer += oprot->writeFieldBegin("uiIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulAddr", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->ulAddr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ulLen", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->ulLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucVal", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->pucVal)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_WriteEeprom_result::~HalApi_SLOT_WriteEeprom_result() noexcept {
}


uint32_t HalApi_SLOT_WriteEeprom_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_SLOT_WriteEeprom_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_SLOT_WriteEeprom_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_SLOT_WriteEeprom_presult::~HalApi_SLOT_WriteEeprom_presult() noexcept {
}


uint32_t HalApi_SLOT_WriteEeprom_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_TDCM_GetMfg_args::~HalApi_TDCM_GetMfg_args() noexcept {
}


uint32_t HalApi_TDCM_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetMfg_pargs::~HalApi_TDCM_GetMfg_pargs() noexcept {
}


uint32_t HalApi_TDCM_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetMfg_result::~HalApi_TDCM_GetMfg_result() noexcept {
}


uint32_t HalApi_TDCM_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_TDCM_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetMfg_presult::~HalApi_TDCM_GetMfg_presult() noexcept {
}


uint32_t HalApi_TDCM_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_TDCM_GetStatusData_args::~HalApi_TDCM_GetStatusData_args() noexcept {
}


uint32_t HalApi_TDCM_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetStatusData_pargs::~HalApi_TDCM_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_TDCM_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetStatusData_result::~HalApi_TDCM_GetStatusData_result() noexcept {
}


uint32_t HalApi_TDCM_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_TDCM_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetStatusData_presult::~HalApi_TDCM_GetStatusData_presult() noexcept {
}


uint32_t HalApi_TDCM_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_TDCM_GetCfgData_args::~HalApi_TDCM_GetCfgData_args() noexcept {
}


uint32_t HalApi_TDCM_GetCfgData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_GetCfgData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_GetCfgData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetCfgData_pargs::~HalApi_TDCM_GetCfgData_pargs() noexcept {
}


uint32_t HalApi_TDCM_GetCfgData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_GetCfgData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetCfgData_result::~HalApi_TDCM_GetCfgData_result() noexcept {
}


uint32_t HalApi_TDCM_GetCfgData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_GetCfgData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_TDCM_GetCfgData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_GetCfgData_presult::~HalApi_TDCM_GetCfgData_presult() noexcept {
}


uint32_t HalApi_TDCM_GetCfgData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_TDCM_SetFrequency_args::~HalApi_TDCM_SetFrequency_args() noexcept {
}


uint32_t HalApi_TDCM_SetFrequency_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fFrequency);
          this->__isset.fFrequency = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_SetFrequency_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_SetFrequency_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fFrequency", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->fFrequency);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_SetFrequency_pargs::~HalApi_TDCM_SetFrequency_pargs() noexcept {
}


uint32_t HalApi_TDCM_SetFrequency_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_SetFrequency_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fFrequency", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->fFrequency)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_SetFrequency_result::~HalApi_TDCM_SetFrequency_result() noexcept {
}


uint32_t HalApi_TDCM_SetFrequency_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_SetFrequency_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_TDCM_SetFrequency_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_SetFrequency_presult::~HalApi_TDCM_SetFrequency_presult() noexcept {
}


uint32_t HalApi_TDCM_SetFrequency_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_TDCM_SetDispersion_args::~HalApi_TDCM_SetDispersion_args() noexcept {
}


uint32_t HalApi_TDCM_SetDispersion_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fDispersion);
          this->__isset.fDispersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_SetDispersion_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_SetDispersion_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fDispersion", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->fDispersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_SetDispersion_pargs::~HalApi_TDCM_SetDispersion_pargs() noexcept {
}


uint32_t HalApi_TDCM_SetDispersion_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_SetDispersion_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fDispersion", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->fDispersion)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_SetDispersion_result::~HalApi_TDCM_SetDispersion_result() noexcept {
}


uint32_t HalApi_TDCM_SetDispersion_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_SetDispersion_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_TDCM_SetDispersion_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_SetDispersion_presult::~HalApi_TDCM_SetDispersion_presult() noexcept {
}


uint32_t HalApi_TDCM_SetDispersion_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_TDCM_Reset_args::~HalApi_TDCM_Reset_args() noexcept {
}


uint32_t HalApi_TDCM_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_Reset_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_Reset_pargs::~HalApi_TDCM_Reset_pargs() noexcept {
}


uint32_t HalApi_TDCM_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_TDCM_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_Reset_result::~HalApi_TDCM_Reset_result() noexcept {
}


uint32_t HalApi_TDCM_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_TDCM_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_TDCM_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_TDCM_Reset_presult::~HalApi_TDCM_Reset_presult() noexcept {
}


uint32_t HalApi_TDCM_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetMfg_args::~HalApi_WSS_GetMfg_args() noexcept {
}


uint32_t HalApi_WSS_GetMfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetMfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetMfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetMfg_pargs::~HalApi_WSS_GetMfg_pargs() noexcept {
}


uint32_t HalApi_WSS_GetMfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetMfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetMfg_result::~HalApi_WSS_GetMfg_result() noexcept {
}


uint32_t HalApi_WSS_GetMfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetMfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetMfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetMfg_presult::~HalApi_WSS_GetMfg_presult() noexcept {
}


uint32_t HalApi_WSS_GetMfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetCfg_args::~HalApi_WSS_GetCfg_args() noexcept {
}


uint32_t HalApi_WSS_GetCfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetCfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetCfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetCfg_pargs::~HalApi_WSS_GetCfg_pargs() noexcept {
}


uint32_t HalApi_WSS_GetCfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetCfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetCfg_result::~HalApi_WSS_GetCfg_result() noexcept {
}


uint32_t HalApi_WSS_GetCfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetCfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetCfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetCfg_presult::~HalApi_WSS_GetCfg_presult() noexcept {
}


uint32_t HalApi_WSS_GetCfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetOscCfg_args::~HalApi_WSS_GetOscCfg_args() noexcept {
}


uint32_t HalApi_WSS_GetOscCfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetOscCfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetOscCfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetOscCfg_pargs::~HalApi_WSS_GetOscCfg_pargs() noexcept {
}


uint32_t HalApi_WSS_GetOscCfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetOscCfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetOscCfg_result::~HalApi_WSS_GetOscCfg_result() noexcept {
}


uint32_t HalApi_WSS_GetOscCfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetOscCfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetOscCfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetOscCfg_presult::~HalApi_WSS_GetOscCfg_presult() noexcept {
}


uint32_t HalApi_WSS_GetOscCfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetStatusData_args::~HalApi_WSS_GetStatusData_args() noexcept {
}


uint32_t HalApi_WSS_GetStatusData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetStatusData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetStatusData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetStatusData_pargs::~HalApi_WSS_GetStatusData_pargs() noexcept {
}


uint32_t HalApi_WSS_GetStatusData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetStatusData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetStatusData_result::~HalApi_WSS_GetStatusData_result() noexcept {
}


uint32_t HalApi_WSS_GetStatusData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetStatusData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetStatusData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetStatusData_presult::~HalApi_WSS_GetStatusData_presult() noexcept {
}


uint32_t HalApi_WSS_GetStatusData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetAllChCfg_args::~HalApi_WSS_SetAllChCfg_args() noexcept {
}


uint32_t HalApi_WSS_SetAllChCfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSubIdx);
          this->__isset.uiSubIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiChCnt);
          this->__isset.uiChCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pstWssCfg.clear();
            uint32_t _size1132;
            ::apache::thrift::protocol::TType _etype1135;
            xfer += iprot->readListBegin(_etype1135, _size1132);
            this->pstWssCfg.resize(_size1132);
            uint32_t _i1136;
            for (_i1136 = 0; _i1136 < _size1132; ++_i1136)
            {
              xfer += this->pstWssCfg[_i1136].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pstWssCfg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetAllChCfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetAllChCfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSubIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiSubIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiChCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWssCfg", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pstWssCfg.size()));
    std::vector<CWssCfg_t> ::const_iterator _iter1137;
    for (_iter1137 = this->pstWssCfg.begin(); _iter1137 != this->pstWssCfg.end(); ++_iter1137)
    {
      xfer += (*_iter1137).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetAllChCfg_pargs::~HalApi_WSS_SetAllChCfg_pargs() noexcept {
}


uint32_t HalApi_WSS_SetAllChCfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetAllChCfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSubIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiSubIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiChCnt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWssCfg", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->pstWssCfg)).size()));
    std::vector<CWssCfg_t> ::const_iterator _iter1138;
    for (_iter1138 = (*(this->pstWssCfg)).begin(); _iter1138 != (*(this->pstWssCfg)).end(); ++_iter1138)
    {
      xfer += (*_iter1138).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetAllChCfg_result::~HalApi_WSS_SetAllChCfg_result() noexcept {
}


uint32_t HalApi_WSS_SetAllChCfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetAllChCfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetAllChCfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetAllChCfg_presult::~HalApi_WSS_SetAllChCfg_presult() noexcept {
}


uint32_t HalApi_WSS_SetAllChCfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetOscChCfg_args::~HalApi_WSS_SetOscChCfg_args() noexcept {
}


uint32_t HalApi_WSS_SetOscChCfg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSubIdx);
          this->__isset.uiSubIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiChCnt);
          this->__isset.uiChCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pstWssCfg.clear();
            uint32_t _size1139;
            ::apache::thrift::protocol::TType _etype1142;
            xfer += iprot->readListBegin(_etype1142, _size1139);
            this->pstWssCfg.resize(_size1139);
            uint32_t _i1143;
            for (_i1143 = 0; _i1143 < _size1139; ++_i1143)
            {
              xfer += this->pstWssCfg[_i1143].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pstWssCfg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetOscChCfg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetOscChCfg_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSubIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiSubIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiChCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWssCfg", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pstWssCfg.size()));
    std::vector<CWssCfg_t> ::const_iterator _iter1144;
    for (_iter1144 = this->pstWssCfg.begin(); _iter1144 != this->pstWssCfg.end(); ++_iter1144)
    {
      xfer += (*_iter1144).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetOscChCfg_pargs::~HalApi_WSS_SetOscChCfg_pargs() noexcept {
}


uint32_t HalApi_WSS_SetOscChCfg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetOscChCfg_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSubIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiSubIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiChCnt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWssCfg", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->pstWssCfg)).size()));
    std::vector<CWssCfg_t> ::const_iterator _iter1145;
    for (_iter1145 = (*(this->pstWssCfg)).begin(); _iter1145 != (*(this->pstWssCfg)).end(); ++_iter1145)
    {
      xfer += (*_iter1145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetOscChCfg_result::~HalApi_WSS_SetOscChCfg_result() noexcept {
}


uint32_t HalApi_WSS_SetOscChCfg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetOscChCfg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetOscChCfg_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetOscChCfg_presult::~HalApi_WSS_SetOscChCfg_presult() noexcept {
}


uint32_t HalApi_WSS_SetOscChCfg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetWaveplan_args::~HalApi_WSS_SetWaveplan_args() noexcept {
}


uint32_t HalApi_WSS_SetWaveplan_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiSubIdx);
          this->__isset.uiSubIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiChCnt);
          this->__isset.uiChCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pstWavePlan.clear();
            uint32_t _size1146;
            ::apache::thrift::protocol::TType _etype1149;
            xfer += iprot->readListBegin(_etype1149, _size1146);
            this->pstWavePlan.resize(_size1146);
            uint32_t _i1150;
            for (_i1150 = 0; _i1150 < _size1146; ++_i1150)
            {
              xfer += this->pstWavePlan[_i1150].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.pstWavePlan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetWaveplan_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetWaveplan_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSubIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiSubIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiChCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWavePlan", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pstWavePlan.size()));
    std::vector<CWavePlan_t> ::const_iterator _iter1151;
    for (_iter1151 = this->pstWavePlan.begin(); _iter1151 != this->pstWavePlan.end(); ++_iter1151)
    {
      xfer += (*_iter1151).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetWaveplan_pargs::~HalApi_WSS_SetWaveplan_pargs() noexcept {
}


uint32_t HalApi_WSS_SetWaveplan_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetWaveplan_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiSubIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiSubIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiChCnt", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiChCnt)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pstWavePlan", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->pstWavePlan)).size()));
    std::vector<CWavePlan_t> ::const_iterator _iter1152;
    for (_iter1152 = (*(this->pstWavePlan)).begin(); _iter1152 != (*(this->pstWavePlan)).end(); ++_iter1152)
    {
      xfer += (*_iter1152).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetWaveplan_result::~HalApi_WSS_SetWaveplan_result() noexcept {
}


uint32_t HalApi_WSS_SetWaveplan_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetWaveplan_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetWaveplan_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetWaveplan_presult::~HalApi_WSS_SetWaveplan_presult() noexcept {
}


uint32_t HalApi_WSS_SetWaveplan_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetPortPowerThr_args::~HalApi_WSS_SetPortPowerThr_args() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerThr_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortIdx);
          this->__isset.uiPortIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiType);
          this->__isset.uiType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sThr);
          this->__isset.sThr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetPortPowerThr_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetPortPowerThr_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sThr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPortPowerThr_pargs::~HalApi_WSS_SetPortPowerThr_pargs() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerThr_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetPortPowerThr_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sThr", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sThr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPortPowerThr_result::~HalApi_WSS_SetPortPowerThr_result() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerThr_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetPortPowerThr_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetPortPowerThr_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPortPowerThr_presult::~HalApi_WSS_SetPortPowerThr_presult() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerThr_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetPortPowerHys_args::~HalApi_WSS_SetPortPowerHys_args() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerHys_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiPortIdx);
          this->__isset.uiPortIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiType);
          this->__isset.uiType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sHys);
          this->__isset.sHys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetPortPowerHys_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetPortPowerHys_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiPortIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sHys);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPortPowerHys_pargs::~HalApi_WSS_SetPortPowerHys_pargs() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerHys_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetPortPowerHys_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiPortIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiPortIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sHys", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16((*(this->sHys)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPortPowerHys_result::~HalApi_WSS_SetPortPowerHys_result() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerHys_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetPortPowerHys_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetPortPowerHys_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPortPowerHys_presult::~HalApi_WSS_SetPortPowerHys_presult() noexcept {
}


uint32_t HalApi_WSS_SetPortPowerHys_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetPortPowerHistory_args::~HalApi_WSS_GetPortPowerHistory_args() noexcept {
}


uint32_t HalApi_WSS_GetPortPowerHistory_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetPortPowerHistory_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetPortPowerHistory_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetPortPowerHistory_pargs::~HalApi_WSS_GetPortPowerHistory_pargs() noexcept {
}


uint32_t HalApi_WSS_GetPortPowerHistory_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetPortPowerHistory_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetPortPowerHistory_result::~HalApi_WSS_GetPortPowerHistory_result() noexcept {
}


uint32_t HalApi_WSS_GetPortPowerHistory_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetPortPowerHistory_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetPortPowerHistory_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetPortPowerHistory_presult::~HalApi_WSS_GetPortPowerHistory_presult() noexcept {
}


uint32_t HalApi_WSS_GetPortPowerHistory_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetLedMode_args::~HalApi_WSS_SetLedMode_args() noexcept {
}


uint32_t HalApi_WSS_SetLedMode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMode);
          this->__isset.uiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetLedMode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedMode_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedMode_pargs::~HalApi_WSS_SetLedMode_pargs() noexcept {
}


uint32_t HalApi_WSS_SetLedMode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedMode_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiMode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedMode_result::~HalApi_WSS_SetLedMode_result() noexcept {
}


uint32_t HalApi_WSS_SetLedMode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetLedMode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedMode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedMode_presult::~HalApi_WSS_SetLedMode_presult() noexcept {
}


uint32_t HalApi_WSS_SetLedMode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetLedDebugMode_args::~HalApi_WSS_SetLedDebugMode_args() noexcept {
}


uint32_t HalApi_WSS_SetLedDebugMode_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiMode);
          this->__isset.uiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetLedDebugMode_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedDebugMode_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedDebugMode_pargs::~HalApi_WSS_SetLedDebugMode_pargs() noexcept {
}


uint32_t HalApi_WSS_SetLedDebugMode_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedDebugMode_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiMode)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedDebugMode_result::~HalApi_WSS_SetLedDebugMode_result() noexcept {
}


uint32_t HalApi_WSS_SetLedDebugMode_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetLedDebugMode_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedDebugMode_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedDebugMode_presult::~HalApi_WSS_SetLedDebugMode_presult() noexcept {
}


uint32_t HalApi_WSS_SetLedDebugMode_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetLedStatus_args::~HalApi_WSS_SetLedStatus_args() noexcept {
}


uint32_t HalApi_WSS_SetLedStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiLedIdx);
          this->__isset.uiLedIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiStatus);
          this->__isset.uiStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetLedStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiLedIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiStatus", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->uiStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedStatus_pargs::~HalApi_WSS_SetLedStatus_pargs() noexcept {
}


uint32_t HalApi_WSS_SetLedStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiLedIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->uiLedIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiStatus", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->uiStatus)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedStatus_result::~HalApi_WSS_SetLedStatus_result() noexcept {
}


uint32_t HalApi_WSS_SetLedStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetLedStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetLedStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetLedStatus_presult::~HalApi_WSS_SetLedStatus_presult() noexcept {
}


uint32_t HalApi_WSS_SetLedStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_Reset_args::~HalApi_WSS_Reset_args() noexcept {
}


uint32_t HalApi_WSS_Reset_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ucResetType);
          this->__isset.ucResetType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_Reset_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_Reset_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->ucResetType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_Reset_pargs::~HalApi_WSS_Reset_pargs() noexcept {
}


uint32_t HalApi_WSS_Reset_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_Reset_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ucResetType", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->ucResetType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_Reset_result::~HalApi_WSS_Reset_result() noexcept {
}


uint32_t HalApi_WSS_Reset_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_Reset_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_Reset_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_Reset_presult::~HalApi_WSS_Reset_presult() noexcept {
}


uint32_t HalApi_WSS_Reset_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_Upgrade_args::~HalApi_WSS_Upgrade_args() noexcept {
}


uint32_t HalApi_WSS_Upgrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c_pcFilePath);
          this->__isset.c_pcFilePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_Upgrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_Upgrade_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->c_pcFilePath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_Upgrade_pargs::~HalApi_WSS_Upgrade_pargs() noexcept {
}


uint32_t HalApi_WSS_Upgrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_Upgrade_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_pcFilePath", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->c_pcFilePath)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_Upgrade_result::~HalApi_WSS_Upgrade_result() noexcept {
}


uint32_t HalApi_WSS_Upgrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_Upgrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_Upgrade_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_Upgrade_presult::~HalApi_WSS_Upgrade_presult() noexcept {
}


uint32_t HalApi_WSS_Upgrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetUpgradeStatus_args::~HalApi_WSS_GetUpgradeStatus_args() noexcept {
}


uint32_t HalApi_WSS_GetUpgradeStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetUpgradeStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetUpgradeStatus_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetUpgradeStatus_pargs::~HalApi_WSS_GetUpgradeStatus_pargs() noexcept {
}


uint32_t HalApi_WSS_GetUpgradeStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetUpgradeStatus_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetUpgradeStatus_result::~HalApi_WSS_GetUpgradeStatus_result() noexcept {
}


uint32_t HalApi_WSS_GetUpgradeStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetUpgradeStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetUpgradeStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetUpgradeStatus_presult::~HalApi_WSS_GetUpgradeStatus_presult() noexcept {
}


uint32_t HalApi_WSS_GetUpgradeStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetUserData_args::~HalApi_WSS_SetUserData_args() noexcept {
}


uint32_t HalApi_WSS_SetUserData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucData);
          this->__isset.pucData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nLen);
          this->__isset.nLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetUserData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetUserData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucData", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pucData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->nLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetUserData_pargs::~HalApi_WSS_SetUserData_pargs() noexcept {
}


uint32_t HalApi_WSS_SetUserData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetUserData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucData", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->pucData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->nLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetUserData_result::~HalApi_WSS_SetUserData_result() noexcept {
}


uint32_t HalApi_WSS_SetUserData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetUserData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetUserData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetUserData_presult::~HalApi_WSS_SetUserData_presult() noexcept {
}


uint32_t HalApi_WSS_SetUserData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetUserData_args::~HalApi_WSS_GetUserData_args() noexcept {
}


uint32_t HalApi_WSS_GetUserData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nLen);
          this->__isset.nLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetUserData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetUserData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->nLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetUserData_pargs::~HalApi_WSS_GetUserData_pargs() noexcept {
}


uint32_t HalApi_WSS_GetUserData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetUserData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->nLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetUserData_result::~HalApi_WSS_GetUserData_result() noexcept {
}


uint32_t HalApi_WSS_GetUserData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetUserData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetUserData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetUserData_presult::~HalApi_WSS_GetUserData_presult() noexcept {
}


uint32_t HalApi_WSS_GetUserData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_SetPmUserData_args::~HalApi_WSS_SetPmUserData_args() noexcept {
}


uint32_t HalApi_WSS_SetPmUserData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->pucData);
          this->__isset.pucData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nLen);
          this->__isset.nLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetPmUserData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetPmUserData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucData", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->pucData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->nLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPmUserData_pargs::~HalApi_WSS_SetPmUserData_pargs() noexcept {
}


uint32_t HalApi_WSS_SetPmUserData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_SetPmUserData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pucData", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->pucData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->nLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPmUserData_result::~HalApi_WSS_SetPmUserData_result() noexcept {
}


uint32_t HalApi_WSS_SetPmUserData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_SetPmUserData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_SetPmUserData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_SetPmUserData_presult::~HalApi_WSS_SetPmUserData_presult() noexcept {
}


uint32_t HalApi_WSS_SetPmUserData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HalApi_WSS_GetPmUserData_args::~HalApi_WSS_GetPmUserData_args() noexcept {
}


uint32_t HalApi_WSS_GetPmUserData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiDevIdx);
          this->__isset.uiDevIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nLen);
          this->__isset.nLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetPmUserData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetPmUserData_args");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uiDevIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->nLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetPmUserData_pargs::~HalApi_WSS_GetPmUserData_pargs() noexcept {
}


uint32_t HalApi_WSS_GetPmUserData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HalApi_WSS_GetPmUserData_pargs");

  xfer += oprot->writeFieldBegin("uiDevIdx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->uiDevIdx)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nLen", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->nLen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetPmUserData_result::~HalApi_WSS_GetPmUserData_result() noexcept {
}


uint32_t HalApi_WSS_GetPmUserData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HalApi_WSS_GetPmUserData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HalApi_WSS_GetPmUserData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HalApi_WSS_GetPmUserData_presult::~HalApi_WSS_GetPmUserData_presult() noexcept {
}


uint32_t HalApi_WSS_GetPmUserData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void HalApiClient::BOARD_GetChassisMfg(CMfg_rsp& _return)
{
  send_BOARD_GetChassisMfg();
  recv_BOARD_GetChassisMfg(_return);
}

void HalApiClient::send_BOARD_GetChassisMfg()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetChassisMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetChassisMfg_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetChassisMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetChassisMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetChassisMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetChassisMfg failed: unknown result");
}

int32_t HalApiClient::BOARD_SetChassisMfg(const std::string& pcFilePath)
{
  send_BOARD_SetChassisMfg(pcFilePath);
  return recv_BOARD_SetChassisMfg();
}

void HalApiClient::send_BOARD_SetChassisMfg(const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetChassisMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisMfg_pargs args;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetChassisMfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetChassisMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetChassisMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisMfg failed: unknown result");
}

int32_t HalApiClient::BOARD_SetChassisConfigType(const std::string& pcConfigType)
{
  send_BOARD_SetChassisConfigType(pcConfigType);
  return recv_BOARD_SetChassisConfigType();
}

void HalApiClient::send_BOARD_SetChassisConfigType(const std::string& pcConfigType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetChassisConfigType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisConfigType_pargs args;
  args.pcConfigType = &pcConfigType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetChassisConfigType()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetChassisConfigType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetChassisConfigType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisConfigType failed: unknown result");
}

void HalApiClient::BOARD_GetChassisCali(CCali_rsp& _return)
{
  send_BOARD_GetChassisCali();
  recv_BOARD_GetChassisCali(_return);
}

void HalApiClient::send_BOARD_GetChassisCali()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetChassisCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetChassisCali_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetChassisCali(CCali_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetChassisCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetChassisCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetChassisCali failed: unknown result");
}

int32_t HalApiClient::BOARD_SetChassisCali(const std::string& pcFilePath)
{
  send_BOARD_SetChassisCali(pcFilePath);
  return recv_BOARD_SetChassisCali();
}

void HalApiClient::send_BOARD_SetChassisCali(const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetChassisCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisCali_pargs args;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetChassisCali()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetChassisCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetChassisCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisCali failed: unknown result");
}

int32_t HalApiClient::BOARD_GetChassisCfg(const int32_t uiAddrSlice, const std::string& pcFilePath)
{
  send_BOARD_GetChassisCfg(uiAddrSlice, pcFilePath);
  return recv_BOARD_GetChassisCfg();
}

void HalApiClient::send_BOARD_GetChassisCfg(const int32_t uiAddrSlice, const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetChassisCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetChassisCfg_pargs args;
  args.uiAddrSlice = &uiAddrSlice;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_GetChassisCfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetChassisCfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_GetChassisCfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetChassisCfg failed: unknown result");
}

int32_t HalApiClient::BOARD_SetChassisCfg(const int32_t uiAddrSlice, const int32_t uiSize, const std::string& pcFilePath)
{
  send_BOARD_SetChassisCfg(uiAddrSlice, uiSize, pcFilePath);
  return recv_BOARD_SetChassisCfg();
}

void HalApiClient::send_BOARD_SetChassisCfg(const int32_t uiAddrSlice, const int32_t uiSize, const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetChassisCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisCfg_pargs args;
  args.uiAddrSlice = &uiAddrSlice;
  args.uiSize = &uiSize;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetChassisCfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetChassisCfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetChassisCfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisCfg failed: unknown result");
}

void HalApiClient::BOARD_GetUpgInfo(binary_rsp& _return, const int32_t ulLen)
{
  send_BOARD_GetUpgInfo(ulLen);
  recv_BOARD_GetUpgInfo(_return);
}

void HalApiClient::send_BOARD_GetUpgInfo(const int32_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetUpgInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetUpgInfo_pargs args;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetUpgInfo(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetUpgInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetUpgInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetUpgInfo failed: unknown result");
}

int32_t HalApiClient::BOARD_SetUpgInfo(const std::string& pucBuf, const int32_t ulLen)
{
  send_BOARD_SetUpgInfo(pucBuf, ulLen);
  return recv_BOARD_SetUpgInfo();
}

void HalApiClient::send_BOARD_SetUpgInfo(const std::string& pucBuf, const int32_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetUpgInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetUpgInfo_pargs args;
  args.pucBuf = &pucBuf;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetUpgInfo()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetUpgInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetUpgInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetUpgInfo failed: unknown result");
}

void HalApiClient::BOARD_GetBdlHead(binary_rsp& _return, const int32_t ulLen)
{
  send_BOARD_GetBdlHead(ulLen);
  recv_BOARD_GetBdlHead(_return);
}

void HalApiClient::send_BOARD_GetBdlHead(const int32_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetBdlHead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetBdlHead_pargs args;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetBdlHead(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetBdlHead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetBdlHead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetBdlHead failed: unknown result");
}

int32_t HalApiClient::BOARD_SetBdlHead(const std::string& pucBuf, const int32_t ulLen)
{
  send_BOARD_SetBdlHead(pucBuf, ulLen);
  return recv_BOARD_SetBdlHead();
}

void HalApiClient::send_BOARD_SetBdlHead(const std::string& pucBuf, const int32_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetBdlHead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetBdlHead_pargs args;
  args.pucBuf = &pucBuf;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetBdlHead()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetBdlHead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetBdlHead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetBdlHead failed: unknown result");
}

void HalApiClient::BOARD_GetStatusData(CBoardStatusData_rsp& _return)
{
  send_BOARD_GetStatusData();
  recv_BOARD_GetStatusData(_return);
}

void HalApiClient::send_BOARD_GetStatusData()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetStatusData_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetStatusData(CBoardStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetStatusData failed: unknown result");
}

void HalApiClient::BOARD_GetSccMfg(CMfg_rsp& _return)
{
  send_BOARD_GetSccMfg();
  recv_BOARD_GetSccMfg(_return);
}

void HalApiClient::send_BOARD_GetSccMfg()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetSccMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetSccMfg_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetSccMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetSccMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetSccMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetSccMfg failed: unknown result");
}

int32_t HalApiClient::BOARD_SetSccMfg(const std::string& pcFilePath)
{
  send_BOARD_SetSccMfg(pcFilePath);
  return recv_BOARD_SetSccMfg();
}

void HalApiClient::send_BOARD_SetSccMfg(const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetSccMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetSccMfg_pargs args;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetSccMfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetSccMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetSccMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetSccMfg failed: unknown result");
}

int32_t HalApiClient::BOARD_SetResetType(const int8_t ucResetType)
{
  send_BOARD_SetResetType(ucResetType);
  return recv_BOARD_SetResetType();
}

void HalApiClient::send_BOARD_SetResetType(const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetResetType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetResetType_pargs args;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetResetType()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetResetType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetResetType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetResetType failed: unknown result");
}

void HalApiClient::BOARD_GetResetType(i8_rsp& _return, const int32_t iIndex)
{
  send_BOARD_GetResetType(iIndex);
  recv_BOARD_GetResetType(_return);
}

void HalApiClient::send_BOARD_GetResetType(const int32_t iIndex)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetResetType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetResetType_pargs args;
  args.iIndex = &iIndex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetResetType(i8_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetResetType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetResetType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetResetType failed: unknown result");
}

int32_t HalApiClient::BOARD_CfgWatchDogTime(const bool bEnable, const int8_t ucTimeout)
{
  send_BOARD_CfgWatchDogTime(bEnable, ucTimeout);
  return recv_BOARD_CfgWatchDogTime();
}

void HalApiClient::send_BOARD_CfgWatchDogTime(const bool bEnable, const int8_t ucTimeout)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_CfgWatchDogTime", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_CfgWatchDogTime_pargs args;
  args.bEnable = &bEnable;
  args.ucTimeout = &ucTimeout;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_CfgWatchDogTime()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_CfgWatchDogTime") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_CfgWatchDogTime_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_CfgWatchDogTime failed: unknown result");
}

void HalApiClient::BOARD_GetApsdStatus(bool_list_rsp& _return, const int32_t iIndex)
{
  send_BOARD_GetApsdStatus(iIndex);
  recv_BOARD_GetApsdStatus(_return);
}

void HalApiClient::send_BOARD_GetApsdStatus(const int32_t iIndex)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetApsdStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetApsdStatus_pargs args;
  args.iIndex = &iIndex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetApsdStatus(bool_list_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetApsdStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetApsdStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetApsdStatus failed: unknown result");
}

int32_t HalApiClient::BOARD_SetLedState(const int32_t uiDevIdx, const int32_t uiState)
{
  send_BOARD_SetLedState(uiDevIdx, uiState);
  return recv_BOARD_SetLedState();
}

void HalApiClient::send_BOARD_SetLedState(const int32_t uiDevIdx, const int32_t uiState)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetLedState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetLedState_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiState = &uiState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetLedState()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetLedState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetLedState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetLedState failed: unknown result");
}

int32_t HalApiClient::BOARD_ResetLogic(const int32_t uiDevIdx, const int8_t ucResetType)
{
  send_BOARD_ResetLogic(uiDevIdx, ucResetType);
  return recv_BOARD_ResetLogic();
}

void HalApiClient::send_BOARD_ResetLogic(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_ResetLogic", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_ResetLogic_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_ResetLogic()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_ResetLogic") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_ResetLogic_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_ResetLogic failed: unknown result");
}

int32_t HalApiClient::BOARD_UpgradeLogic(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  send_BOARD_UpgradeLogic(uiDevIdx, c_pcFilePath);
  return recv_BOARD_UpgradeLogic();
}

void HalApiClient::send_BOARD_UpgradeLogic(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_UpgradeLogic", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_UpgradeLogic_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_UpgradeLogic()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_UpgradeLogic") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_UpgradeLogic_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_UpgradeLogic failed: unknown result");
}

int32_t HalApiClient::BOARD_GetUpgadeStatus()
{
  send_BOARD_GetUpgadeStatus();
  return recv_BOARD_GetUpgadeStatus();
}

void HalApiClient::send_BOARD_GetUpgadeStatus()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetUpgadeStatus_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_GetUpgadeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetUpgadeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_GetUpgadeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetUpgadeStatus failed: unknown result");
}

void HalApiClient::FAN_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  send_FAN_GetMfg(uiDevIdx);
  recv_FAN_GetMfg(_return);
}

void HalApiClient::send_FAN_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("FAN_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_FAN_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("FAN_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_FAN_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_GetMfg failed: unknown result");
}

int32_t HalApiClient::FAN_SetMfg(const int32_t uiDevIdx, const std::string& pcFilePath)
{
  send_FAN_SetMfg(uiDevIdx, pcFilePath);
  return recv_FAN_SetMfg();
}

void HalApiClient::send_FAN_SetMfg(const int32_t uiDevIdx, const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("FAN_SetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_FAN_SetMfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("FAN_SetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_FAN_SetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetMfg failed: unknown result");
}

int32_t HalApiClient::FAN_SetSpeed(const int32_t uiDevIdx, const int32_t uiDuty)
{
  send_FAN_SetSpeed(uiDevIdx, uiDuty);
  return recv_FAN_SetSpeed();
}

void HalApiClient::send_FAN_SetSpeed(const int32_t uiDevIdx, const int32_t uiDuty)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("FAN_SetSpeed", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetSpeed_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiDuty = &uiDuty;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_FAN_SetSpeed()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("FAN_SetSpeed") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_FAN_SetSpeed_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetSpeed failed: unknown result");
}

int32_t HalApiClient::FAN_SetControllerEEP(const int32_t uiDevIdx)
{
  send_FAN_SetControllerEEP(uiDevIdx);
  return recv_FAN_SetControllerEEP();
}

void HalApiClient::send_FAN_SetControllerEEP(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("FAN_SetControllerEEP", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetControllerEEP_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_FAN_SetControllerEEP()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("FAN_SetControllerEEP") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_FAN_SetControllerEEP_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetControllerEEP failed: unknown result");
}

int32_t HalApiClient::FAN_SetLed(const int32_t uiDevIdx, const int32_t uiValue)
{
  send_FAN_SetLed(uiDevIdx, uiValue);
  return recv_FAN_SetLed();
}

void HalApiClient::send_FAN_SetLed(const int32_t uiDevIdx, const int32_t uiValue)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("FAN_SetLed", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetLed_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiValue = &uiValue;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_FAN_SetLed()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("FAN_SetLed") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_FAN_SetLed_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetLed failed: unknown result");
}

void HalApiClient::POWER_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  send_POWER_GetMfg(uiDevIdx);
  recv_POWER_GetMfg(_return);
}

void HalApiClient::send_POWER_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("POWER_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_POWER_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_POWER_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("POWER_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_POWER_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "POWER_GetMfg failed: unknown result");
}

void HalApiClient::BOARD_GetProductName(string_rsp& _return, const int32_t nSize)
{
  send_BOARD_GetProductName(nSize);
  recv_BOARD_GetProductName(_return);
}

void HalApiClient::send_BOARD_GetProductName(const int32_t nSize)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetProductName", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetProductName_pargs args;
  args.nSize = &nSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetProductName(string_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetProductName") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetProductName_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetProductName failed: unknown result");
}

void HalApiClient::BOARD_GetConfigType(string_rsp& _return, const int32_t nSize)
{
  send_BOARD_GetConfigType(nSize);
  recv_BOARD_GetConfigType(_return);
}

void HalApiClient::send_BOARD_GetConfigType(const int32_t nSize)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetConfigType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetConfigType_pargs args;
  args.nSize = &nSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_GetConfigType(string_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetConfigType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_GetConfigType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetConfigType failed: unknown result");
}

int32_t HalApiClient::BOARD_GetProductType()
{
  send_BOARD_GetProductType();
  return recv_BOARD_GetProductType();
}

void HalApiClient::send_BOARD_GetProductType()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_GetProductType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetProductType_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_GetProductType()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_GetProductType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_GetProductType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetProductType failed: unknown result");
}

int32_t HalApiClient::BOARD_SetLogLevel(const int32_t uiLogLevel)
{
  send_BOARD_SetLogLevel(uiLogLevel);
  return recv_BOARD_SetLogLevel();
}

void HalApiClient::send_BOARD_SetLogLevel(const int32_t uiLogLevel)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_SetLogLevel", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetLogLevel_pargs args;
  args.uiLogLevel = &uiLogLevel;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_BOARD_SetLogLevel()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_SetLogLevel") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_BOARD_SetLogLevel_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetLogLevel failed: unknown result");
}

void HalApiClient::BOARD_ConvertDevType(i32_rsp& _return, const std::string& pcName)
{
  send_BOARD_ConvertDevType(pcName);
  recv_BOARD_ConvertDevType(_return);
}

void HalApiClient::send_BOARD_ConvertDevType(const std::string& pcName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("BOARD_ConvertDevType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_ConvertDevType_pargs args;
  args.pcName = &pcName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_BOARD_ConvertDevType(i32_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("BOARD_ConvertDevType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_BOARD_ConvertDevType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_ConvertDevType failed: unknown result");
}

void HalApiClient::Cv_GetMuxStatusData(CCvMuxStatusData_rsp& _return, const int32_t enCvLine)
{
  send_Cv_GetMuxStatusData(enCvLine);
  recv_Cv_GetMuxStatusData(_return);
}

void HalApiClient::send_Cv_GetMuxStatusData(const int32_t enCvLine)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Cv_GetMuxStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_Cv_GetMuxStatusData_pargs args;
  args.enCvLine = &enCvLine;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_Cv_GetMuxStatusData(CCvMuxStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Cv_GetMuxStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_Cv_GetMuxStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Cv_GetMuxStatusData failed: unknown result");
}

void HalApiClient::Cv_GetClientStatusData(CCvClientStatusData_rsp& _return, const int32_t enCvLine)
{
  send_Cv_GetClientStatusData(enCvLine);
  recv_Cv_GetClientStatusData(_return);
}

void HalApiClient::send_Cv_GetClientStatusData(const int32_t enCvLine)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Cv_GetClientStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_Cv_GetClientStatusData_pargs args;
  args.enCvLine = &enCvLine;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_Cv_GetClientStatusData(CCvClientStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Cv_GetClientStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_Cv_GetClientStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Cv_GetClientStatusData failed: unknown result");
}

void HalApiClient::Cv_GetRef(CCvRef_rsp& _return)
{
  send_Cv_GetRef();
  recv_Cv_GetRef(_return);
}

void HalApiClient::send_Cv_GetRef()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("Cv_GetRef", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_Cv_GetRef_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_Cv_GetRef(CCvRef_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("Cv_GetRef") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_Cv_GetRef_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Cv_GetRef failed: unknown result");
}

void HalApiClient::DBG_ReadLogicReg(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  send_DBG_ReadLogicReg(uiIdx, ulAddr, ulLen);
  recv_DBG_ReadLogicReg(_return);
}

void HalApiClient::send_DBG_ReadLogicReg(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_ReadLogicReg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ReadLogicReg_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_ReadLogicReg(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_ReadLogicReg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_ReadLogicReg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ReadLogicReg failed: unknown result");
}

int32_t HalApiClient::DBG_WriteLogicReg(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  send_DBG_WriteLogicReg(uiIdx, ulAddr, ulLen, pucVal);
  return recv_DBG_WriteLogicReg();
}

void HalApiClient::send_DBG_WriteLogicReg(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_WriteLogicReg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_WriteLogicReg_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_WriteLogicReg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_WriteLogicReg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_WriteLogicReg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_WriteLogicReg failed: unknown result");
}

void HalApiClient::DBG_ReadLogicRegSlc(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  send_DBG_ReadLogicRegSlc(uiIdx, ulAddr, ulLen);
  recv_DBG_ReadLogicRegSlc(_return);
}

void HalApiClient::send_DBG_ReadLogicRegSlc(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_ReadLogicRegSlc", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ReadLogicRegSlc_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_ReadLogicRegSlc(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_ReadLogicRegSlc") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_ReadLogicRegSlc_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ReadLogicRegSlc failed: unknown result");
}

int32_t HalApiClient::DBG_WriteLogicRegSlc(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  send_DBG_WriteLogicRegSlc(uiIdx, ulAddr, ulLen, pucVal);
  return recv_DBG_WriteLogicRegSlc();
}

void HalApiClient::send_DBG_WriteLogicRegSlc(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_WriteLogicRegSlc", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_WriteLogicRegSlc_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_WriteLogicRegSlc()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_WriteLogicRegSlc") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_WriteLogicRegSlc_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_WriteLogicRegSlc failed: unknown result");
}

int32_t HalApiClient::DBG_LoopEnable(const bool bEnable)
{
  send_DBG_LoopEnable(bEnable);
  return recv_DBG_LoopEnable();
}

void HalApiClient::send_DBG_LoopEnable(const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_LoopEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_LoopEnable_pargs args;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_LoopEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_LoopEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_LoopEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_LoopEnable failed: unknown result");
}

int32_t HalApiClient::DBG_LoopInterval(const int32_t uiInterval)
{
  send_DBG_LoopInterval(uiInterval);
  return recv_DBG_LoopInterval();
}

void HalApiClient::send_DBG_LoopInterval(const int32_t uiInterval)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_LoopInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_LoopInterval_pargs args;
  args.uiInterval = &uiInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_LoopInterval()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_LoopInterval") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_LoopInterval_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_LoopInterval failed: unknown result");
}

int32_t HalApiClient::DBG_IdleEnable(const bool bEnable)
{
  send_DBG_IdleEnable(bEnable);
  return recv_DBG_IdleEnable();
}

void HalApiClient::send_DBG_IdleEnable(const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_IdleEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_IdleEnable_pargs args;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_IdleEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_IdleEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_IdleEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_IdleEnable failed: unknown result");
}

int32_t HalApiClient::DBG_ApsdEnable(const int32_t iIndex, const bool bEnable)
{
  send_DBG_ApsdEnable(iIndex, bEnable);
  return recv_DBG_ApsdEnable();
}

void HalApiClient::send_DBG_ApsdEnable(const int32_t iIndex, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_ApsdEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ApsdEnable_pargs args;
  args.iIndex = &iIndex;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_ApsdEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_ApsdEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_ApsdEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ApsdEnable failed: unknown result");
}

void HalApiClient::DBG_GetAprStatus(i8_rsp& _return, const int32_t uiIndex)
{
  send_DBG_GetAprStatus(uiIndex);
  recv_DBG_GetAprStatus(_return);
}

void HalApiClient::send_DBG_GetAprStatus(const int32_t uiIndex)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_GetAprStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_GetAprStatus_pargs args;
  args.uiIndex = &uiIndex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_GetAprStatus(i8_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_GetAprStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_GetAprStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_GetAprStatus failed: unknown result");
}

void HalApiClient::DBG_SpiSendCommand(binary_rsp& _return, const int32_t ulChip, const std::string& pucBufW, const int32_t ulLen)
{
  send_DBG_SpiSendCommand(ulChip, pucBufW, ulLen);
  recv_DBG_SpiSendCommand(_return);
}

void HalApiClient::send_DBG_SpiSendCommand(const int32_t ulChip, const std::string& pucBufW, const int32_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_SpiSendCommand", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SpiSendCommand_pargs args;
  args.ulChip = &ulChip;
  args.pucBufW = &pucBufW;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_SpiSendCommand(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_SpiSendCommand") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_SpiSendCommand_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SpiSendCommand failed: unknown result");
}

void HalApiClient::DBG_SpiFlashRead(binary_rsp& _return, const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen)
{
  send_DBG_SpiFlashRead(ulChip, ulAddr, ulLen);
  recv_DBG_SpiFlashRead(_return);
}

void HalApiClient::send_DBG_SpiFlashRead(const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_SpiFlashRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SpiFlashRead_pargs args;
  args.ulChip = &ulChip;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_SpiFlashRead(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_SpiFlashRead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_SpiFlashRead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SpiFlashRead failed: unknown result");
}

int32_t HalApiClient::DBG_SpiFlashWrite(const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  send_DBG_SpiFlashWrite(ulChip, ulAddr, ulLen, pucVal);
  return recv_DBG_SpiFlashWrite();
}

void HalApiClient::send_DBG_SpiFlashWrite(const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_SpiFlashWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SpiFlashWrite_pargs args;
  args.ulChip = &ulChip;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_SpiFlashWrite()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_SpiFlashWrite") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_SpiFlashWrite_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SpiFlashWrite failed: unknown result");
}

void HalApiClient::DBG_MdioRead(i16_rsp& _return, const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  send_DBG_MdioRead(uiIdx, ulPhyAddr, ulRegAddr);
  recv_DBG_MdioRead(_return);
}

void HalApiClient::send_DBG_MdioRead(const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_MdioRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_MdioRead_pargs args;
  args.uiIdx = &uiIdx;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_MdioRead(i16_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_MdioRead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_MdioRead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_MdioRead failed: unknown result");
}

int32_t HalApiClient::DBG_MdioWrite(const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  send_DBG_MdioWrite(uiIdx, ulPhyAddr, ulRegAddr, usData);
  return recv_DBG_MdioWrite();
}

void HalApiClient::send_DBG_MdioWrite(const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_MdioWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_MdioWrite_pargs args;
  args.uiIdx = &uiIdx;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.usData = &usData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_MdioWrite()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_MdioWrite") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_MdioWrite_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_MdioWrite failed: unknown result");
}

void HalApiClient::DBG_NetSwitchRead(i16_rsp& _return, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  send_DBG_NetSwitchRead(ulPhyAddr, ulRegAddr);
  recv_DBG_NetSwitchRead(_return);
}

void HalApiClient::send_DBG_NetSwitchRead(const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_NetSwitchRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_NetSwitchRead_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_NetSwitchRead(i16_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_NetSwitchRead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_NetSwitchRead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_NetSwitchRead failed: unknown result");
}

int32_t HalApiClient::DBG_NetSwitchWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  send_DBG_NetSwitchWrite(ulPhyAddr, ulRegAddr, usData);
  return recv_DBG_NetSwitchWrite();
}

void HalApiClient::send_DBG_NetSwitchWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_NetSwitchWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_NetSwitchWrite_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.usData = &usData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_NetSwitchWrite()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_NetSwitchWrite") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_NetSwitchWrite_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_NetSwitchWrite failed: unknown result");
}

void HalApiClient::DBG_SwitchPhyRead(i16_rsp& _return, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  send_DBG_SwitchPhyRead(ulPhyAddr, ulRegAddr);
  recv_DBG_SwitchPhyRead(_return);
}

void HalApiClient::send_DBG_SwitchPhyRead(const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_SwitchPhyRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SwitchPhyRead_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_SwitchPhyRead(i16_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_SwitchPhyRead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_SwitchPhyRead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SwitchPhyRead failed: unknown result");
}

int32_t HalApiClient::DBG_SwitchPhyWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  send_DBG_SwitchPhyWrite(ulPhyAddr, ulRegAddr, usData);
  return recv_DBG_SwitchPhyWrite();
}

void HalApiClient::send_DBG_SwitchPhyWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_SwitchPhyWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SwitchPhyWrite_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.usData = &usData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_SwitchPhyWrite()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_SwitchPhyWrite") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_SwitchPhyWrite_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SwitchPhyWrite failed: unknown result");
}

void HalApiClient::DBG_ReadEeprom(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  send_DBG_ReadEeprom(uiIdx, ulAddr, ulLen);
  recv_DBG_ReadEeprom(_return);
}

void HalApiClient::send_DBG_ReadEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_ReadEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ReadEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_DBG_ReadEeprom(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_ReadEeprom") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_DBG_ReadEeprom_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ReadEeprom failed: unknown result");
}

int32_t HalApiClient::DBG_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  send_DBG_WriteEeprom(uiIdx, ulAddr, ulLen, pucVal);
  return recv_DBG_WriteEeprom();
}

void HalApiClient::send_DBG_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DBG_WriteEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_WriteEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_DBG_WriteEeprom()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DBG_WriteEeprom") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_DBG_WriteEeprom_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_WriteEeprom failed: unknown result");
}

void HalApiClient::EDFA_GetMfg(CMfg_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetMfg(uiDevType);
  recv_EDFA_GetMfg(_return);
}

void HalApiClient::send_EDFA_GetMfg(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetMfg_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetMfg failed: unknown result");
}

void HalApiClient::EDFA_GetStatusData(COaStatusData_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetStatusData(uiDevType);
  recv_EDFA_GetStatusData(_return);
}

void HalApiClient::send_EDFA_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetStatusData(COaStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetStatusData failed: unknown result");
}

void HalApiClient::EDFA_GetCfgData(COaCfgData_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetCfgData(uiDevType);
  recv_EDFA_GetCfgData(_return);
}

void HalApiClient::send_EDFA_GetCfgData(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetCfgData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetCfgData(COaCfgData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetCfgData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetCfgData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetCfgData failed: unknown result");
}

int32_t HalApiClient::EDFA_GetDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  send_EDFA_GetDebugInfo(uiDevType, pcFilePath);
  return recv_EDFA_GetDebugInfo();
}

void HalApiClient::send_EDFA_GetDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetDebugInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetDebugInfo_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_GetDebugInfo()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetDebugInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_GetDebugInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetDebugInfo failed: unknown result");
}

int32_t HalApiClient::EDFA_GetMcuDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  send_EDFA_GetMcuDebugInfo(uiDevType, pcFilePath);
  return recv_EDFA_GetMcuDebugInfo();
}

void HalApiClient::send_EDFA_GetMcuDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetMcuDebugInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetMcuDebugInfo_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_GetMcuDebugInfo()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetMcuDebugInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_GetMcuDebugInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetMcuDebugInfo failed: unknown result");
}

int32_t HalApiClient::EDFA_SetGainRange(const int32_t uiDevType, const int16_t sGainRange)
{
  send_EDFA_SetGainRange(uiDevType, sGainRange);
  return recv_EDFA_SetGainRange();
}

void HalApiClient::send_EDFA_SetGainRange(const int32_t uiDevType, const int16_t sGainRange)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetGainRange", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetGainRange_pargs args;
  args.uiDevType = &uiDevType;
  args.sGainRange = &sGainRange;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetGainRange()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetGainRange") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetGainRange_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetGainRange failed: unknown result");
}

int32_t HalApiClient::EDFA_SetGain(const int32_t uiDevType, const int16_t sGain)
{
  send_EDFA_SetGain(uiDevType, sGain);
  return recv_EDFA_SetGain();
}

void HalApiClient::send_EDFA_SetGain(const int32_t uiDevType, const int16_t sGain)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetGain", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetGain_pargs args;
  args.uiDevType = &uiDevType;
  args.sGain = &sGain;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetGain()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetGain") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetGain_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetGain failed: unknown result");
}

int32_t HalApiClient::EDFA_SetTilt(const int32_t uiDevType, const int16_t sTilt)
{
  send_EDFA_SetTilt(uiDevType, sTilt);
  return recv_EDFA_SetTilt();
}

void HalApiClient::send_EDFA_SetTilt(const int32_t uiDevType, const int16_t sTilt)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetTilt", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetTilt_pargs args;
  args.uiDevType = &uiDevType;
  args.sTilt = &sTilt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetTilt()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetTilt") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetTilt_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetTilt failed: unknown result");
}

int32_t HalApiClient::EDFA_SetMode(const int32_t uiDevType, const int8_t ucMode, const int16_t sVal)
{
  send_EDFA_SetMode(uiDevType, ucMode, sVal);
  return recv_EDFA_SetMode();
}

void HalApiClient::send_EDFA_SetMode(const int32_t uiDevType, const int8_t ucMode, const int16_t sVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetMode_pargs args;
  args.uiDevType = &uiDevType;
  args.ucMode = &ucMode;
  args.sVal = &sVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetMode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetMode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetMode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetMode failed: unknown result");
}

int32_t HalApiClient::EDFA_SetPumpEnable(const int32_t uiDevType, const bool bEnable)
{
  send_EDFA_SetPumpEnable(uiDevType, bEnable);
  return recv_EDFA_SetPumpEnable();
}

void HalApiClient::send_EDFA_SetPumpEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetPumpEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetPumpEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetPumpEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetPumpEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetPumpEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetPumpEnable failed: unknown result");
}

int32_t HalApiClient::EDFA_SetAprEnable(const int32_t uiDevType, const bool bEnable)
{
  send_EDFA_SetAprEnable(uiDevType, bEnable);
  return recv_EDFA_SetAprEnable();
}

void HalApiClient::send_EDFA_SetAprEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetAprEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAprEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetAprEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetAprEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetAprEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAprEnable failed: unknown result");
}

int32_t HalApiClient::EDFA_SetAutolosEnable(const int32_t uiDevType, const bool bEnable)
{
  send_EDFA_SetAutolosEnable(uiDevType, bEnable);
  return recv_EDFA_SetAutolosEnable();
}

void HalApiClient::send_EDFA_SetAutolosEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetAutolosEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAutolosEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetAutolosEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetAutolosEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetAutolosEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAutolosEnable failed: unknown result");
}

int32_t HalApiClient::EDFA_SetRxLosThr(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  send_EDFA_SetRxLosThr(uiDevType, sThr, sHys);
  return recv_EDFA_SetRxLosThr();
}

void HalApiClient::send_EDFA_SetRxLosThr(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetRxLosThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetRxLosThr_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetRxLosThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetRxLosThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetRxLosThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetRxLosThr failed: unknown result");
}

int32_t HalApiClient::EDFA_SetAttn(const int32_t uiDevType, const int16_t sAttn)
{
  send_EDFA_SetAttn(uiDevType, sAttn);
  return recv_EDFA_SetAttn();
}

void HalApiClient::send_EDFA_SetAttn(const int32_t uiDevType, const int16_t sAttn)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetAttn", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAttn_pargs args;
  args.uiDevType = &uiDevType;
  args.sAttn = &sAttn;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetAttn()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetAttn") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetAttn_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAttn failed: unknown result");
}

void HalApiClient::EDFA_GetAttn(i16_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetAttn(uiDevType);
  recv_EDFA_GetAttn(_return);
}

void HalApiClient::send_EDFA_GetAttn(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetAttn", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetAttn_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetAttn(i16_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetAttn") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetAttn_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetAttn failed: unknown result");
}

int32_t HalApiClient::EDFA_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  send_EDFA_Reset(uiDevType, ucResetType);
  return recv_EDFA_Reset();
}

void HalApiClient::send_EDFA_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Reset_pargs args;
  args.uiDevType = &uiDevType;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Reset failed: unknown result");
}

int32_t HalApiClient::EDFA_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  send_EDFA_Upgrade(uiDevType, c_pcFilePath);
  return recv_EDFA_Upgrade();
}

void HalApiClient::send_EDFA_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Upgrade_pargs args;
  args.uiDevType = &uiDevType;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_Upgrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_Upgrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_Upgrade_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Upgrade failed: unknown result");
}

int32_t HalApiClient::EDFA_Swap(const int32_t uiDevType)
{
  send_EDFA_Swap(uiDevType);
  return recv_EDFA_Swap();
}

void HalApiClient::send_EDFA_Swap(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_Swap", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Swap_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_Swap()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_Swap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_Swap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Swap failed: unknown result");
}

int32_t HalApiClient::EDFA_Commit(const int32_t uiDevType)
{
  send_EDFA_Commit(uiDevType);
  return recv_EDFA_Commit();
}

void HalApiClient::send_EDFA_Commit(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_Commit", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Commit_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_Commit()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_Commit") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_Commit_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Commit failed: unknown result");
}

int32_t HalApiClient::EDFA_GetUpgadeStatus(const int32_t uiDevType)
{
  send_EDFA_GetUpgadeStatus(uiDevType);
  return recv_EDFA_GetUpgadeStatus();
}

void HalApiClient::send_EDFA_GetUpgadeStatus(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetUpgadeStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_GetUpgadeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetUpgadeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_GetUpgadeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetUpgadeStatus failed: unknown result");
}

void HalApiClient::EDFA_DbgRead(binary_rsp& _return, const int32_t uiDevType, const int32_t uiLen)
{
  send_EDFA_DbgRead(uiDevType, uiLen);
  recv_EDFA_DbgRead(_return);
}

void HalApiClient::send_EDFA_DbgRead(const int32_t uiDevType, const int32_t uiLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_DbgRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_DbgRead_pargs args;
  args.uiDevType = &uiDevType;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_DbgRead(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_DbgRead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_DbgRead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_DbgRead failed: unknown result");
}

int32_t HalApiClient::EDFA_DbgWrite(const int32_t uiDevType, const std::string& pucBuf, const int32_t uiLen)
{
  send_EDFA_DbgWrite(uiDevType, pucBuf, uiLen);
  return recv_EDFA_DbgWrite();
}

void HalApiClient::send_EDFA_DbgWrite(const int32_t uiDevType, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_DbgWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_DbgWrite_pargs args;
  args.uiDevType = &uiDevType;
  args.pucBuf = &pucBuf;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_DbgWrite()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_DbgWrite") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_DbgWrite_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_DbgWrite failed: unknown result");
}

int32_t HalApiClient::EDFA_SetDfbEnable(const int32_t uiDevType, const bool bEnable, const int32_t iPower)
{
  send_EDFA_SetDfbEnable(uiDevType, bEnable, iPower);
  return recv_EDFA_SetDfbEnable();
}

void HalApiClient::send_EDFA_SetDfbEnable(const int32_t uiDevType, const bool bEnable, const int32_t iPower)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetDfbEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetDfbEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.iPower = &iPower;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetDfbEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetDfbEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetDfbEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetDfbEnable failed: unknown result");
}

int32_t HalApiClient::EDFA_SetOscEnable(const int32_t uiDevType, const bool bEnable)
{
  send_EDFA_SetOscEnable(uiDevType, bEnable);
  return recv_EDFA_SetOscEnable();
}

void HalApiClient::send_EDFA_SetOscEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetOscEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetOscEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetOscEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetOscEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscEnable failed: unknown result");
}

int32_t HalApiClient::EDFA_SetOtdrSwitchPos(const int32_t uiDevType, const int32_t uiPos)
{
  send_EDFA_SetOtdrSwitchPos(uiDevType, uiPos);
  return recv_EDFA_SetOtdrSwitchPos();
}

void HalApiClient::send_EDFA_SetOtdrSwitchPos(const int32_t uiDevType, const int32_t uiPos)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetOtdrSwitchPos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOtdrSwitchPos_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPos = &uiPos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetOtdrSwitchPos()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetOtdrSwitchPos") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetOtdrSwitchPos_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOtdrSwitchPos failed: unknown result");
}

int32_t HalApiClient::EDFA_SetOscAddThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  send_EDFA_SetOscAddThrHys(uiDevType, sThr, sHys);
  return recv_EDFA_SetOscAddThrHys();
}

void HalApiClient::send_EDFA_SetOscAddThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetOscAddThrHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscAddThrHys_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetOscAddThrHys()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetOscAddThrHys") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetOscAddThrHys_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscAddThrHys failed: unknown result");
}

int32_t HalApiClient::EDFA_SetOscDropThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  send_EDFA_SetOscDropThrHys(uiDevType, sThr, sHys);
  return recv_EDFA_SetOscDropThrHys();
}

void HalApiClient::send_EDFA_SetOscDropThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetOscDropThrHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscDropThrHys_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetOscDropThrHys()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetOscDropThrHys") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetOscDropThrHys_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscDropThrHys failed: unknown result");
}

int32_t HalApiClient::EDFA_SetOscRxThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  send_EDFA_SetOscRxThrHys(uiDevType, sThr, sHys);
  return recv_EDFA_SetOscRxThrHys();
}

void HalApiClient::send_EDFA_SetOscRxThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetOscRxThrHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscRxThrHys_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetOscRxThrHys()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetOscRxThrHys") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetOscRxThrHys_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscRxThrHys failed: unknown result");
}

int32_t HalApiClient::EDFA_SetApsdEnable(const int32_t uiDevType, const bool bEnable)
{
  send_EDFA_SetApsdEnable(uiDevType, bEnable);
  return recv_EDFA_SetApsdEnable();
}

void HalApiClient::send_EDFA_SetApsdEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetApsdEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetApsdEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetApsdEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetApsdEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetApsdEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetApsdEnable failed: unknown result");
}

void HalApiClient::EDFA_GetApsdStatus(bool_list_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetApsdStatus(uiDevType);
  recv_EDFA_GetApsdStatus(_return);
}

void HalApiClient::send_EDFA_GetApsdStatus(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetApsdStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetApsdStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetApsdStatus(bool_list_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetApsdStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetApsdStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetApsdStatus failed: unknown result");
}

void HalApiClient::EDFA_GetOcmAttn(i16_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetOcmAttn(uiDevType);
  recv_EDFA_GetOcmAttn(_return);
}

void HalApiClient::send_EDFA_GetOcmAttn(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetOcmAttn", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetOcmAttn_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetOcmAttn(i16_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetOcmAttn") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetOcmAttn_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetOcmAttn failed: unknown result");
}

int32_t HalApiClient::EDFA_SetUpgState(const int32_t uiDevType, const int16_t sState)
{
  send_EDFA_SetUpgState(uiDevType, sState);
  return recv_EDFA_SetUpgState();
}

void HalApiClient::send_EDFA_SetUpgState(const int32_t uiDevType, const int16_t sState)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetUpgState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetUpgState_pargs args;
  args.uiDevType = &uiDevType;
  args.sState = &sState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetUpgState()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetUpgState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetUpgState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetUpgState failed: unknown result");
}

int32_t HalApiClient::EDFA_SetLedState(const int32_t uiDevType, const int16_t sState)
{
  send_EDFA_SetLedState(uiDevType, sState);
  return recv_EDFA_SetLedState();
}

void HalApiClient::send_EDFA_SetLedState(const int32_t uiDevType, const int16_t sState)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetLedState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetLedState_pargs args;
  args.uiDevType = &uiDevType;
  args.sState = &sState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetLedState()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetLedState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetLedState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetLedState failed: unknown result");
}

int32_t HalApiClient::EDFA_SetLedAlm(const int32_t uiDevType, const int16_t sState)
{
  send_EDFA_SetLedAlm(uiDevType, sState);
  return recv_EDFA_SetLedAlm();
}

void HalApiClient::send_EDFA_SetLedAlm(const int32_t uiDevType, const int16_t sState)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetLedAlm", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetLedAlm_pargs args;
  args.uiDevType = &uiDevType;
  args.sState = &sState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetLedAlm()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetLedAlm") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetLedAlm_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetLedAlm failed: unknown result");
}

void HalApiClient::EDFA_GetCali(COaCaliData_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetCali(uiDevType);
  recv_EDFA_GetCali(_return);
}

void HalApiClient::send_EDFA_GetCali(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetCali_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetCali(COaCaliData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetCali failed: unknown result");
}

int32_t HalApiClient::EDFA_SetOtdrCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  send_EDFA_SetOtdrCali(uiDevType, pcFilePath);
  return recv_EDFA_SetOtdrCali();
}

void HalApiClient::send_EDFA_SetOtdrCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetOtdrCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOtdrCali_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetOtdrCali()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetOtdrCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetOtdrCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOtdrCali failed: unknown result");
}

int32_t HalApiClient::EDFA_SetOcmCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  send_EDFA_SetOcmCali(uiDevType, pcFilePath);
  return recv_EDFA_SetOcmCali();
}

void HalApiClient::send_EDFA_SetOcmCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetOcmCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOcmCali_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetOcmCali()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetOcmCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetOcmCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOcmCali failed: unknown result");
}

int32_t HalApiClient::EDFA_SetManualVoaEnable(const int32_t uiDevType, const bool bEnable)
{
  send_EDFA_SetManualVoaEnable(uiDevType, bEnable);
  return recv_EDFA_SetManualVoaEnable();
}

void HalApiClient::send_EDFA_SetManualVoaEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetManualVoaEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetManualVoaEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetManualVoaEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetManualVoaEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetManualVoaEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetManualVoaEnable failed: unknown result");
}

int32_t HalApiClient::EDFA_SetPaddingVoaConfigPower(const int32_t uiDevType, const int16_t sOutPower)
{
  send_EDFA_SetPaddingVoaConfigPower(uiDevType, sOutPower);
  return recv_EDFA_SetPaddingVoaConfigPower();
}

void HalApiClient::send_EDFA_SetPaddingVoaConfigPower(const int32_t uiDevType, const int16_t sOutPower)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetPaddingVoaConfigPower", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetPaddingVoaConfigPower_pargs args;
  args.uiDevType = &uiDevType;
  args.sOutPower = &sOutPower;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetPaddingVoaConfigPower()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetPaddingVoaConfigPower") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetPaddingVoaConfigPower_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetPaddingVoaConfigPower failed: unknown result");
}

int32_t HalApiClient::EDFA_SetManualGainEnable(const int32_t uiDevType, const bool bEnable)
{
  send_EDFA_SetManualGainEnable(uiDevType, bEnable);
  return recv_EDFA_SetManualGainEnable();
}

void HalApiClient::send_EDFA_SetManualGainEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetManualGainEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetManualGainEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetManualGainEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetManualGainEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetManualGainEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetManualGainEnable failed: unknown result");
}

int32_t HalApiClient::EDFA_SetThr(const int32_t uiDevType, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int16_t sHys)
{
  send_EDFA_SetThr(uiDevType, uiPortIdx, uiType, sThr, sHys);
  return recv_EDFA_SetThr();
}

void HalApiClient::send_EDFA_SetThr(const int32_t uiDevType, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetThr_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetThr failed: unknown result");
}

int32_t HalApiClient::EDFA_SetPumpCurrent(const int32_t uiDevType, const int32_t uiPumpIdx, const int16_t sCurrent)
{
  send_EDFA_SetPumpCurrent(uiDevType, uiPumpIdx, sCurrent);
  return recv_EDFA_SetPumpCurrent();
}

void HalApiClient::send_EDFA_SetPumpCurrent(const int32_t uiDevType, const int32_t uiPumpIdx, const int16_t sCurrent)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetPumpCurrent", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetPumpCurrent_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPumpIdx = &uiPumpIdx;
  args.sCurrent = &sCurrent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetPumpCurrent()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetPumpCurrent") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetPumpCurrent_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetPumpCurrent failed: unknown result");
}

int32_t HalApiClient::EDFA_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal)
{
  send_EDFA_SetAlmMask(uiDevType, iMaskIdx, iMaskVal);
  return recv_EDFA_SetAlmMask();
}

void HalApiClient::send_EDFA_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetAlmMask", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAlmMask_pargs args;
  args.uiDevType = &uiDevType;
  args.iMaskIdx = &iMaskIdx;
  args.iMaskVal = &iMaskVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetAlmMask()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetAlmMask") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetAlmMask_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAlmMask failed: unknown result");
}

void HalApiClient::EDFA_GetEventLog(COaEventLogAllData_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetEventLog(uiDevType);
  recv_EDFA_GetEventLog(_return);
}

void HalApiClient::send_EDFA_GetEventLog(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetEventLog", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetEventLog_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetEventLog(COaEventLogAllData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetEventLog") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetEventLog_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetEventLog failed: unknown result");
}

int32_t HalApiClient::EDFA_SetShutterState(const int32_t uiDevType, const bool block)
{
  send_EDFA_SetShutterState(uiDevType, block);
  return recv_EDFA_SetShutterState();
}

void HalApiClient::send_EDFA_SetShutterState(const int32_t uiDevType, const bool block)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_SetShutterState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetShutterState_pargs args;
  args.uiDevType = &uiDevType;
  args.block = &block;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EDFA_SetShutterState()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_SetShutterState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EDFA_SetShutterState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetShutterState failed: unknown result");
}

void HalApiClient::EDFA_GetShutterState(bool_rsp& _return, const int32_t uiDevType)
{
  send_EDFA_GetShutterState(uiDevType);
  recv_EDFA_GetShutterState(_return);
}

void HalApiClient::send_EDFA_GetShutterState(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EDFA_GetShutterState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetShutterState_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EDFA_GetShutterState(bool_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EDFA_GetShutterState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EDFA_GetShutterState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetShutterState failed: unknown result");
}

void HalApiClient::EXTEND_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  send_EXTEND_GetMfg(uiDevIdx);
  recv_EXTEND_GetMfg(_return);
}

void HalApiClient::send_EXTEND_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EXTEND_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EXTEND_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_GetMfg failed: unknown result");
}

void HalApiClient::EXTEND_GetStatusData(CExtendStatusData_rsp& _return, const int32_t uiDevIdx)
{
  send_EXTEND_GetStatusData(uiDevIdx);
  recv_EXTEND_GetStatusData(_return);
}

void HalApiClient::send_EXTEND_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EXTEND_GetStatusData(CExtendStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EXTEND_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_GetStatusData failed: unknown result");
}

int32_t HalApiClient::EXTEND_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  send_EXTEND_Reset(uiDevIdx, ucResetType);
  return recv_EXTEND_Reset();
}

void HalApiClient::send_EXTEND_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EXTEND_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EXTEND_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_Reset failed: unknown result");
}

int32_t HalApiClient::EXTEND_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  send_EXTEND_Upgrade(uiDevIdx, c_pcFilePath);
  return recv_EXTEND_Upgrade();
}

void HalApiClient::send_EXTEND_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_Upgrade_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EXTEND_Upgrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_Upgrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EXTEND_Upgrade_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_Upgrade failed: unknown result");
}

int32_t HalApiClient::EXTEND_GetUpgadeStatus(const int32_t uiDevIdx)
{
  send_EXTEND_GetUpgadeStatus(uiDevIdx);
  return recv_EXTEND_GetUpgadeStatus();
}

void HalApiClient::send_EXTEND_GetUpgadeStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_GetUpgadeStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EXTEND_GetUpgadeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_GetUpgadeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EXTEND_GetUpgadeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_GetUpgadeStatus failed: unknown result");
}

void HalApiClient::EXTEND_DbgRead(binary_rsp& _return, const int32_t uiDevIdx, const int32_t uiLen)
{
  send_EXTEND_DbgRead(uiDevIdx, uiLen);
  recv_EXTEND_DbgRead(_return);
}

void HalApiClient::send_EXTEND_DbgRead(const int32_t uiDevIdx, const int32_t uiLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_DbgRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_DbgRead_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_EXTEND_DbgRead(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_DbgRead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_EXTEND_DbgRead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_DbgRead failed: unknown result");
}

int32_t HalApiClient::EXTEND_DbgWrite(const int32_t uiDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  send_EXTEND_DbgWrite(uiDevIdx, pucBuf, uiLen);
  return recv_EXTEND_DbgWrite();
}

void HalApiClient::send_EXTEND_DbgWrite(const int32_t uiDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_DbgWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_DbgWrite_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pucBuf = &pucBuf;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EXTEND_DbgWrite()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_DbgWrite") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EXTEND_DbgWrite_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_DbgWrite failed: unknown result");
}

int32_t HalApiClient::EXTEND_SetSfp(const int32_t uiDevIdx, const int32_t ulVal)
{
  send_EXTEND_SetSfp(uiDevIdx, ulVal);
  return recv_EXTEND_SetSfp();
}

void HalApiClient::send_EXTEND_SetSfp(const int32_t uiDevIdx, const int32_t ulVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("EXTEND_SetSfp", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_SetSfp_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ulVal = &ulVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_EXTEND_SetSfp()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("EXTEND_SetSfp") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_EXTEND_SetSfp_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_SetSfp failed: unknown result");
}

void HalApiClient::MIRROR_GetStatusData(CMirrorData_rsp& _return, const int32_t uiDevIdx)
{
  send_MIRROR_GetStatusData(uiDevIdx);
  recv_MIRROR_GetStatusData(_return);
}

void HalApiClient::send_MIRROR_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MIRROR_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MIRROR_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_MIRROR_GetStatusData(CMirrorData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MIRROR_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_MIRROR_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MIRROR_GetStatusData failed: unknown result");
}

int32_t HalApiClient::SWITCH_Pos(const int32_t uiDevIdx, const int32_t uiPort)
{
  send_SWITCH_Pos(uiDevIdx, uiPort);
  return recv_SWITCH_Pos();
}

void HalApiClient::send_SWITCH_Pos(const int32_t uiDevIdx, const int32_t uiPort)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SWITCH_Pos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SWITCH_Pos_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPort = &uiPort;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SWITCH_Pos()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SWITCH_Pos") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SWITCH_Pos_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SWITCH_Pos failed: unknown result");
}

void HalApiClient::MUX_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  send_MUX_GetMfg(uiDevIdx);
  recv_MUX_GetMfg(_return);
}

void HalApiClient::send_MUX_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MUX_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MUX_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_MUX_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MUX_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_MUX_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MUX_GetMfg failed: unknown result");
}

void HalApiClient::MUX_GetStatusData(CMuxStatusData_rsp& _return, const int32_t uiDevIdx)
{
  send_MUX_GetStatusData(uiDevIdx);
  recv_MUX_GetStatusData(_return);
}

void HalApiClient::send_MUX_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MUX_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MUX_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_MUX_GetStatusData(CMuxStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MUX_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_MUX_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MUX_GetStatusData failed: unknown result");
}

void HalApiClient::MUX_GetCali(CMuxCaliData_rsp& _return, const int32_t uiDevIdx)
{
  send_MUX_GetCali(uiDevIdx);
  recv_MUX_GetCali(_return);
}

void HalApiClient::send_MUX_GetCali(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MUX_GetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MUX_GetCali_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_MUX_GetCali(CMuxCaliData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MUX_GetCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_MUX_GetCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MUX_GetCali failed: unknown result");
}

void HalApiClient::OCM_GetMfg(CMfg_rsp& _return, const int32_t uiDevType)
{
  send_OCM_GetMfg(uiDevType);
  recv_OCM_GetMfg(_return);
}

void HalApiClient::send_OCM_GetMfg(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetMfg_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCM_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCM_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetMfg failed: unknown result");
}

void HalApiClient::OCM_GetStatusData(COcmStatusData_rsp& _return, const int32_t uiDevType)
{
  send_OCM_GetStatusData(uiDevType);
  recv_OCM_GetStatusData(_return);
}

void HalApiClient::send_OCM_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCM_GetStatusData(COcmStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCM_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetStatusData failed: unknown result");
}

void HalApiClient::OCM_GetChPower(COcmChPower_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  send_OCM_GetChPower(uiDevType, uiPortId);
  recv_OCM_GetChPower(_return);
}

void HalApiClient::send_OCM_GetChPower(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetChPower", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetChPower_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCM_GetChPower(COcmChPower_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetChPower") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCM_GetChPower_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetChPower failed: unknown result");
}

void HalApiClient::OCM_GetOsaData(COcmOsa_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  send_OCM_GetOsaData(uiDevType, uiPortId);
  recv_OCM_GetOsaData(_return);
}

void HalApiClient::send_OCM_GetOsaData(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetOsaData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetOsaData_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCM_GetOsaData(COcmOsa_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetOsaData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCM_GetOsaData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetOsaData failed: unknown result");
}

void HalApiClient::OCM_GetRealTimeOsaData(COcmOsa_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  send_OCM_GetRealTimeOsaData(uiDevType, uiPortId);
  recv_OCM_GetRealTimeOsaData(_return);
}

void HalApiClient::send_OCM_GetRealTimeOsaData(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetRealTimeOsaData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetRealTimeOsaData_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCM_GetRealTimeOsaData(COcmOsa_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetRealTimeOsaData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCM_GetRealTimeOsaData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetRealTimeOsaData failed: unknown result");
}

int32_t HalApiClient::OCM_SetWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<CWavePlanSlice_t> & pstWavePlan)
{
  send_OCM_SetWaveplan(uiDevType, uiPortId, uiChCnt, pstWavePlan);
  return recv_OCM_SetWaveplan();
}

void HalApiClient::send_OCM_SetWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<CWavePlanSlice_t> & pstWavePlan)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_SetWaveplan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_SetWaveplan_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.uiChCnt = &uiChCnt;
  args.pstWavePlan = &pstWavePlan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCM_SetWaveplan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_SetWaveplan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCM_SetWaveplan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_SetWaveplan failed: unknown result");
}

int32_t HalApiClient::OCM_SetOcmWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<STChannelGrid_t> & pstWavePlan)
{
  send_OCM_SetOcmWaveplan(uiDevType, uiPortId, uiChCnt, pstWavePlan);
  return recv_OCM_SetOcmWaveplan();
}

void HalApiClient::send_OCM_SetOcmWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<STChannelGrid_t> & pstWavePlan)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_SetOcmWaveplan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_SetOcmWaveplan_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.uiChCnt = &uiChCnt;
  args.pstWavePlan = &pstWavePlan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCM_SetOcmWaveplan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_SetOcmWaveplan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCM_SetOcmWaveplan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_SetOcmWaveplan failed: unknown result");
}

int32_t HalApiClient::OCM_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  send_OCM_Reset(uiDevType, ucResetType);
  return recv_OCM_Reset();
}

void HalApiClient::send_OCM_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_Reset_pargs args;
  args.uiDevType = &uiDevType;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCM_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCM_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_Reset failed: unknown result");
}

int32_t HalApiClient::OCM_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  send_OCM_Upgrade(uiDevType, c_pcFilePath);
  return recv_OCM_Upgrade();
}

void HalApiClient::send_OCM_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_Upgrade_pargs args;
  args.uiDevType = &uiDevType;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCM_Upgrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_Upgrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCM_Upgrade_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_Upgrade failed: unknown result");
}

int32_t HalApiClient::OCM_Commit(const int32_t uiDevType)
{
  send_OCM_Commit(uiDevType);
  return recv_OCM_Commit();
}

void HalApiClient::send_OCM_Commit(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_Commit", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_Commit_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCM_Commit()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_Commit") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCM_Commit_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_Commit failed: unknown result");
}

int32_t HalApiClient::OCM_GetUpgradeStatus(const int32_t uiDevType)
{
  send_OCM_GetUpgradeStatus(uiDevType);
  return recv_OCM_GetUpgradeStatus();
}

void HalApiClient::send_OCM_GetUpgradeStatus(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetUpgradeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetUpgradeStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCM_GetUpgradeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetUpgradeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCM_GetUpgradeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetUpgradeStatus failed: unknown result");
}

int32_t HalApiClient::OCM_SetVoa(const int32_t uiDevType, const int16_t sAttn)
{
  send_OCM_SetVoa(uiDevType, sAttn);
  return recv_OCM_SetVoa();
}

void HalApiClient::send_OCM_SetVoa(const int32_t uiDevType, const int16_t sAttn)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_SetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_SetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.sAttn = &sAttn;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCM_SetVoa()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_SetVoa") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCM_SetVoa_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_SetVoa failed: unknown result");
}

void HalApiClient::OCM_GetVoa(i16_rsp& _return, const int32_t uiDevType)
{
  send_OCM_GetVoa(uiDevType);
  recv_OCM_GetVoa(_return);
}

void HalApiClient::send_OCM_GetVoa(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCM_GetVoa(i16_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetVoa") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCM_GetVoa_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetVoa failed: unknown result");
}

void HalApiClient::OCM_GetVoaPd(i16_list_rsp& _return, const int32_t uiDevType)
{
  send_OCM_GetVoaPd(uiDevType);
  recv_OCM_GetVoaPd(_return);
}

void HalApiClient::send_OCM_GetVoaPd(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCM_GetVoaPd", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetVoaPd_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCM_GetVoaPd(i16_list_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCM_GetVoaPd") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCM_GetVoaPd_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetVoaPd failed: unknown result");
}

void HalApiClient::OCS_GetMfg(CMfg_rsp& _return, const int32_t uiDevType)
{
  send_OCS_GetMfg(uiDevType);
  recv_OCS_GetMfg(_return);
}

void HalApiClient::send_OCS_GetMfg(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_GetMfg_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCS_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCS_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_GetMfg failed: unknown result");
}

void HalApiClient::OCS_GetStatusData(COcsStatusData_rsp& _return, const int32_t uiDevType)
{
  send_OCS_GetStatusData(uiDevType);
  recv_OCS_GetStatusData(_return);
}

void HalApiClient::send_OCS_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OCS_GetStatusData(COcsStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OCS_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_GetStatusData failed: unknown result");
}

int32_t HalApiClient::OCS_SetConnection(const int32_t uiDevType, const COcsConnection_t& pstConnection)
{
  send_OCS_SetConnection(uiDevType, pstConnection);
  return recv_OCS_SetConnection();
}

void HalApiClient::send_OCS_SetConnection(const int32_t uiDevType, const COcsConnection_t& pstConnection)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_SetConnection", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetConnection_pargs args;
  args.uiDevType = &uiDevType;
  args.pstConnection = &pstConnection;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCS_SetConnection()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_SetConnection") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCS_SetConnection_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetConnection failed: unknown result");
}

int32_t HalApiClient::OCS_SetConnections(const int32_t uiDevType, const COcsConnections_t& pstConnections)
{
  send_OCS_SetConnections(uiDevType, pstConnections);
  return recv_OCS_SetConnections();
}

void HalApiClient::send_OCS_SetConnections(const int32_t uiDevType, const COcsConnections_t& pstConnections)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_SetConnections", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetConnections_pargs args;
  args.uiDevType = &uiDevType;
  args.pstConnections = &pstConnections;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCS_SetConnections()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_SetConnections") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCS_SetConnections_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetConnections failed: unknown result");
}

int32_t HalApiClient::OCS_SetLedState(const int32_t uiDevType, const int32_t index, const int32_t uiState)
{
  send_OCS_SetLedState(uiDevType, index, uiState);
  return recv_OCS_SetLedState();
}

void HalApiClient::send_OCS_SetLedState(const int32_t uiDevType, const int32_t index, const int32_t uiState)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_SetLedState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetLedState_pargs args;
  args.uiDevType = &uiDevType;
  args.index = &index;
  args.uiState = &uiState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCS_SetLedState()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_SetLedState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCS_SetLedState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetLedState failed: unknown result");
}

int32_t HalApiClient::OCS_SetLedMode(const int32_t uiDevType, const int32_t uiMode)
{
  send_OCS_SetLedMode(uiDevType, uiMode);
  return recv_OCS_SetLedMode();
}

void HalApiClient::send_OCS_SetLedMode(const int32_t uiDevType, const int32_t uiMode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_SetLedMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetLedMode_pargs args;
  args.uiDevType = &uiDevType;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCS_SetLedMode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_SetLedMode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCS_SetLedMode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetLedMode failed: unknown result");
}

int32_t HalApiClient::OCS_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  send_OCS_Reset(uiDevType, ucResetType);
  return recv_OCS_Reset();
}

void HalApiClient::send_OCS_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_Reset_pargs args;
  args.uiDevType = &uiDevType;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCS_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCS_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_Reset failed: unknown result");
}

int32_t HalApiClient::OCS_Upgrade(const int32_t uiDevType, const std::string& pcPath)
{
  send_OCS_Upgrade(uiDevType, pcPath);
  return recv_OCS_Upgrade();
}

void HalApiClient::send_OCS_Upgrade(const int32_t uiDevType, const std::string& pcPath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_Upgrade_pargs args;
  args.uiDevType = &uiDevType;
  args.pcPath = &pcPath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCS_Upgrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_Upgrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCS_Upgrade_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_Upgrade failed: unknown result");
}

int32_t HalApiClient::OCS_GetUpgradeStatus(const int32_t uiDevType)
{
  send_OCS_GetUpgradeStatus(uiDevType);
  return recv_OCS_GetUpgradeStatus();
}

void HalApiClient::send_OCS_GetUpgradeStatus(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OCS_GetUpgradeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_GetUpgradeStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OCS_GetUpgradeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OCS_GetUpgradeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OCS_GetUpgradeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_GetUpgradeStatus failed: unknown result");
}

void HalApiClient::OPS_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  send_OPS_GetMfg(uiDevIdx);
  recv_OPS_GetMfg(_return);
}

void HalApiClient::send_OPS_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetMfg failed: unknown result");
}

void HalApiClient::OPS_GetCommStatusData(COpsCommStatusData_rsp& _return, const int32_t uiDevIdx)
{
  send_OPS_GetCommStatusData(uiDevIdx);
  recv_OPS_GetCommStatusData(_return);
}

void HalApiClient::send_OPS_GetCommStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetCommStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetCommStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetCommStatusData(COpsCommStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetCommStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetCommStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetCommStatusData failed: unknown result");
}

void HalApiClient::OPS_GetCfgData(COpsCfgData_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  send_OPS_GetCfgData(uiDevIdx, uiPortId);
  recv_OPS_GetCfgData(_return);
}

void HalApiClient::send_OPS_GetCfgData(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetCfgData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetCfgData(COpsCfgData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetCfgData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetCfgData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetCfgData failed: unknown result");
}

void HalApiClient::OPS_GetStatusData(COpsStatusData_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  send_OPS_GetStatusData(uiDevIdx, uiPortId);
  recv_OPS_GetStatusData(_return);
}

void HalApiClient::send_OPS_GetStatusData(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetStatusData(COpsStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetStatusData failed: unknown result");
}

void HalApiClient::OPS_GetHistoryData(COpsHistoryData_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  send_OPS_GetHistoryData(uiDevIdx, uiPortId);
  recv_OPS_GetHistoryData(_return);
}

void HalApiClient::send_OPS_GetHistoryData(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetHistoryData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetHistoryData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetHistoryData(COpsHistoryData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetHistoryData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetHistoryData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetHistoryData failed: unknown result");
}

void HalApiClient::OPS_GetLedStatus(COpsLed_rsp& _return, const int32_t uiDevIdx)
{
  send_OPS_GetLedStatus(uiDevIdx);
  recv_OPS_GetLedStatus(_return);
}

void HalApiClient::send_OPS_GetLedStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetLedStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetLedStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetLedStatus(COpsLed_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetLedStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetLedStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetLedStatus failed: unknown result");
}

int32_t HalApiClient::OPS_ClearAlarmDuration(const int32_t uiDevIdx)
{
  send_OPS_ClearAlarmDuration(uiDevIdx);
  return recv_OPS_ClearAlarmDuration();
}

void HalApiClient::send_OPS_ClearAlarmDuration(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_ClearAlarmDuration", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_ClearAlarmDuration_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_ClearAlarmDuration()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_ClearAlarmDuration") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_ClearAlarmDuration_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_ClearAlarmDuration failed: unknown result");
}

int32_t HalApiClient::OPS_SetThrPwrDiff(const int32_t uiDevIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  send_OPS_SetThrPwrDiff(uiDevIdx, sThr, sHys, uiPortId);
  return recv_OPS_SetThrPwrDiff();
}

void HalApiClient::send_OPS_SetThrPwrDiff(const int32_t uiDevIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetThrPwrDiff", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetThrPwrDiff_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetThrPwrDiff()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetThrPwrDiff") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetThrPwrDiff_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetThrPwrDiff failed: unknown result");
}

int32_t HalApiClient::OPS_SetThrLine(const int32_t uiDevIdx, const int32_t uiPortIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  send_OPS_SetThrLine(uiDevIdx, uiPortIdx, sThr, sHys, uiPortId);
  return recv_OPS_SetThrLine();
}

void HalApiClient::send_OPS_SetThrLine(const int32_t uiDevIdx, const int32_t uiPortIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetThrLine", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetThrLine_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetThrLine()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetThrLine") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetThrLine_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetThrLine failed: unknown result");
}

int32_t HalApiClient::OPS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  send_OPS_SetPortPowerThr(uiDevIdx, uiPortIdx, uiType, sThr, uiPortId);
  return recv_OPS_SetPortPowerThr();
}

void HalApiClient::send_OPS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetPortPowerThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetPortPowerThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetPortPowerThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetPortPowerThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetPortPowerThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetPortPowerThr failed: unknown result");
}

int32_t HalApiClient::OPS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  send_OPS_SetPortPowerHys(uiDevIdx, uiPortIdx, uiType, sHys, uiPortId);
  return recv_OPS_SetPortPowerHys();
}

void HalApiClient::send_OPS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetPortPowerHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetPortPowerHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetPortPowerHys()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetPortPowerHys") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetPortPowerHys_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetPortPowerHys failed: unknown result");
}

int32_t HalApiClient::OPS_SetWtr(const int32_t uiDevIdx, const int32_t uiWtr, const int32_t uiPortId)
{
  send_OPS_SetWtr(uiDevIdx, uiWtr, uiPortId);
  return recv_OPS_SetWtr();
}

void HalApiClient::send_OPS_SetWtr(const int32_t uiDevIdx, const int32_t uiWtr, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetWtr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetWtr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiWtr = &uiWtr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetWtr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetWtr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetWtr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetWtr failed: unknown result");
}

int32_t HalApiClient::OPS_SetHoldOffTime(const int32_t uiDevIdx, const int32_t uiHoldOffTime, const int32_t uiPortId)
{
  send_OPS_SetHoldOffTime(uiDevIdx, uiHoldOffTime, uiPortId);
  return recv_OPS_SetHoldOffTime();
}

void HalApiClient::send_OPS_SetHoldOffTime(const int32_t uiDevIdx, const int32_t uiHoldOffTime, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetHoldOffTime", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetHoldOffTime_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiHoldOffTime = &uiHoldOffTime;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetHoldOffTime()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetHoldOffTime") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetHoldOffTime_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetHoldOffTime failed: unknown result");
}

int32_t HalApiClient::OPS_SetRevertive(const int32_t uiDevIdx, const bool bRevertive, const int32_t uiPortId)
{
  send_OPS_SetRevertive(uiDevIdx, bRevertive, uiPortId);
  return recv_OPS_SetRevertive();
}

void HalApiClient::send_OPS_SetRevertive(const int32_t uiDevIdx, const bool bRevertive, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetRevertive", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRevertive_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.bRevertive = &bRevertive;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetRevertive()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetRevertive") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetRevertive_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRevertive failed: unknown result");
}

int32_t HalApiClient::OPS_SetMode(const int32_t uiDevIdx, const int32_t uiMode, const int32_t uiPortId)
{
  send_OPS_SetMode(uiDevIdx, uiMode, uiPortId);
  return recv_OPS_SetMode();
}

void HalApiClient::send_OPS_SetMode(const int32_t uiDevIdx, const int32_t uiMode, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetMode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetMode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetMode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetMode failed: unknown result");
}

int32_t HalApiClient::OPS_SetRelativeThr(const int32_t uiDevIdx, const int16_t sThr, const int32_t uiPortId)
{
  send_OPS_SetRelativeThr(uiDevIdx, sThr, uiPortId);
  return recv_OPS_SetRelativeThr();
}

void HalApiClient::send_OPS_SetRelativeThr(const int32_t uiDevIdx, const int16_t sThr, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetRelativeThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRelativeThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.sThr = &sThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetRelativeThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetRelativeThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetRelativeThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRelativeThr failed: unknown result");
}

int32_t HalApiClient::OPS_SetRelativeOffset(const int32_t uiDevIdx, const int16_t sOffset, const int32_t uiPortId)
{
  send_OPS_SetRelativeOffset(uiDevIdx, sOffset, uiPortId);
  return recv_OPS_SetRelativeOffset();
}

void HalApiClient::send_OPS_SetRelativeOffset(const int32_t uiDevIdx, const int16_t sOffset, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetRelativeOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRelativeOffset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.sOffset = &sOffset;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetRelativeOffset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetRelativeOffset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetRelativeOffset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRelativeOffset failed: unknown result");
}

int32_t HalApiClient::OPS_SetSwitchThr(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iThr, const int32_t uiPortId)
{
  send_OPS_SetSwitchThr(uiDevIdx, uiPos, iThr, uiPortId);
  return recv_OPS_SetSwitchThr();
}

void HalApiClient::send_OPS_SetSwitchThr(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iThr, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetSwitchThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetSwitchThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPos = &uiPos;
  args.iThr = &iThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetSwitchThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetSwitchThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetSwitchThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetSwitchThr failed: unknown result");
}

int32_t HalApiClient::OPS_SetSwitchHys(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iHys, const int32_t uiPortId)
{
  send_OPS_SetSwitchHys(uiDevIdx, uiPos, iHys, uiPortId);
  return recv_OPS_SetSwitchHys();
}

void HalApiClient::send_OPS_SetSwitchHys(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iHys, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetSwitchHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetSwitchHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPos = &uiPos;
  args.iHys = &iHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetSwitchHys()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetSwitchHys") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetSwitchHys_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetSwitchHys failed: unknown result");
}

int32_t HalApiClient::OPS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  send_OPS_Reset(uiDevIdx, ucResetType);
  return recv_OPS_Reset();
}

void HalApiClient::send_OPS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_Reset failed: unknown result");
}

int32_t HalApiClient::OPS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  send_OPS_Upgrade(uiDevIdx, c_pcFilePath);
  return recv_OPS_Upgrade();
}

void HalApiClient::send_OPS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_Upgrade_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_Upgrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_Upgrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_Upgrade_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_Upgrade failed: unknown result");
}

int32_t HalApiClient::OPS_GetUpgadeStatus(const int32_t uiDevIdx)
{
  send_OPS_GetUpgadeStatus(uiDevIdx);
  return recv_OPS_GetUpgadeStatus();
}

void HalApiClient::send_OPS_GetUpgadeStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetUpgadeStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_GetUpgadeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetUpgadeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_GetUpgadeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetUpgadeStatus failed: unknown result");
}

int32_t HalApiClient::OPS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  send_OPS_SetLedDebugMode(uiDevIdx, uiMode);
  return recv_OPS_SetLedDebugMode();
}

void HalApiClient::send_OPS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetLedDebugMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetLedDebugMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetLedDebugMode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetLedDebugMode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetLedDebugMode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetLedDebugMode failed: unknown result");
}

int32_t HalApiClient::OPS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  send_OPS_SetLedStatus(uiDevIdx, uiLedIdx, uiStatus);
  return recv_OPS_SetLedStatus();
}

void HalApiClient::send_OPS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetLedStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetLedStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiLedIdx = &uiLedIdx;
  args.uiStatus = &uiStatus;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetLedStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetLedStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetLedStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetLedStatus failed: unknown result");
}

int32_t HalApiClient::OPS_SetConnectionPdThr(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  send_OPS_SetConnectionPdThr(uiDevIdx, uiPdIdx, uiType, sThr, uiPortId);
  return recv_OPS_SetConnectionPdThr();
}

void HalApiClient::send_OPS_SetConnectionPdThr(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetConnectionPdThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetConnectionPdThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPdIdx = &uiPdIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetConnectionPdThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetConnectionPdThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetConnectionPdThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetConnectionPdThr failed: unknown result");
}

int32_t HalApiClient::OPS_SetConnectionPdHys(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  send_OPS_SetConnectionPdHys(uiDevIdx, uiPdIdx, uiType, sHys, uiPortId);
  return recv_OPS_SetConnectionPdHys();
}

void HalApiClient::send_OPS_SetConnectionPdHys(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetConnectionPdHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetConnectionPdHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPdIdx = &uiPdIdx;
  args.uiType = &uiType;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetConnectionPdHys()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetConnectionPdHys") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetConnectionPdHys_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetConnectionPdHys failed: unknown result");
}

int32_t HalApiClient::OPS_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal, const int32_t uiPortId)
{
  send_OPS_SetAlmMask(uiDevType, iMaskIdx, iMaskVal, uiPortId);
  return recv_OPS_SetAlmMask();
}

void HalApiClient::send_OPS_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetAlmMask", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetAlmMask_pargs args;
  args.uiDevType = &uiDevType;
  args.iMaskIdx = &iMaskIdx;
  args.iMaskVal = &iMaskVal;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetAlmMask()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetAlmMask") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetAlmMask_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetAlmMask failed: unknown result");
}

void HalApiClient::OPS_GetEventLog(COpsEventLogAllData_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  send_OPS_GetEventLog(uiDevType, uiPortId);
  recv_OPS_GetEventLog(_return);
}

void HalApiClient::send_OPS_GetEventLog(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetEventLog", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetEventLog_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetEventLog(COpsEventLogAllData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetEventLog") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetEventLog_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetEventLog failed: unknown result");
}

int32_t HalApiClient::OPS_SetRemoteStatus(const int32_t uiDevIdx, const COpsReqStatus_t& pstStatus, const int32_t uiPortId)
{
  send_OPS_SetRemoteStatus(uiDevIdx, pstStatus, uiPortId);
  return recv_OPS_SetRemoteStatus();
}

void HalApiClient::send_OPS_SetRemoteStatus(const int32_t uiDevIdx, const COpsReqStatus_t& pstStatus, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetRemoteStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRemoteStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pstStatus = &pstStatus;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetRemoteStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetRemoteStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetRemoteStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRemoteStatus failed: unknown result");
}

void HalApiClient::OPS_GetRequestStatus(COpsBidirectionStatus_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  send_OPS_GetRequestStatus(uiDevIdx, uiPortId);
  recv_OPS_GetRequestStatus(_return);
}

void HalApiClient::send_OPS_GetRequestStatus(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetRequestStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetRequestStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetRequestStatus(COpsBidirectionStatus_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetRequestStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetRequestStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetRequestStatus failed: unknown result");
}

int32_t HalApiClient::OPS_SetSwitchingType(const int32_t uiDevIdx, const int8_t ucType, const int32_t uiPortId)
{
  send_OPS_SetSwitchingType(uiDevIdx, ucType, uiPortId);
  return recv_OPS_SetSwitchingType();
}

void HalApiClient::send_OPS_SetSwitchingType(const int32_t uiDevIdx, const int8_t ucType, const int32_t uiPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_SetSwitchingType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetSwitchingType_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucType = &ucType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OPS_SetSwitchingType()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_SetSwitchingType") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OPS_SetSwitchingType_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetSwitchingType failed: unknown result");
}

void HalApiClient::OPS_GetOpsDevIdByKey(i32_list_rsp& _return, const std::string& pcName)
{
  send_OPS_GetOpsDevIdByKey(pcName);
  recv_OPS_GetOpsDevIdByKey(_return);
}

void HalApiClient::send_OPS_GetOpsDevIdByKey(const std::string& pcName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OPS_GetOpsDevIdByKey", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetOpsDevIdByKey_pargs args;
  args.pcName = &pcName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OPS_GetOpsDevIdByKey(i32_list_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OPS_GetOpsDevIdByKey") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OPS_GetOpsDevIdByKey_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetOpsDevIdByKey failed: unknown result");
}

void HalApiClient::OSC_GetStatusData(COscStatusData_rsp& _return, const int32_t uiDevType)
{
  send_OSC_GetStatusData(uiDevType);
  recv_OSC_GetStatusData(_return);
}

void HalApiClient::send_OSC_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OSC_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OSC_GetStatusData(COscStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OSC_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OSC_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetStatusData failed: unknown result");
}

void HalApiClient::OSC_GetCfgData(COscCfgData_rsp& _return, const int32_t uiDevType)
{
  send_OSC_GetCfgData(uiDevType);
  recv_OSC_GetCfgData(_return);
}

void HalApiClient::send_OSC_GetCfgData(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OSC_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetCfgData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OSC_GetCfgData(COscCfgData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OSC_GetCfgData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OSC_GetCfgData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetCfgData failed: unknown result");
}

int32_t HalApiClient::OSC_SetEnable(const int32_t uiDevType, const bool bEnable)
{
  send_OSC_SetEnable(uiDevType, bEnable);
  return recv_OSC_SetEnable();
}

void HalApiClient::send_OSC_SetEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OSC_SetEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_SetEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OSC_SetEnable()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OSC_SetEnable") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OSC_SetEnable_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_SetEnable failed: unknown result");
}

int32_t HalApiClient::OSC_SetVoa(const int32_t uiDevType, const int32_t uiTxRx, const int16_t sAttn)
{
  send_OSC_SetVoa(uiDevType, uiTxRx, sAttn);
  return recv_OSC_SetVoa();
}

void HalApiClient::send_OSC_SetVoa(const int32_t uiDevType, const int32_t uiTxRx, const int16_t sAttn)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OSC_SetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_SetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.uiTxRx = &uiTxRx;
  args.sAttn = &sAttn;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OSC_SetVoa()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OSC_SetVoa") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OSC_SetVoa_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_SetVoa failed: unknown result");
}

void HalApiClient::OSC_GetVoa(i16_rsp& _return, const int32_t uiDevType, const int32_t uiTxRx)
{
  send_OSC_GetVoa(uiDevType, uiTxRx);
  recv_OSC_GetVoa(_return);
}

void HalApiClient::send_OSC_GetVoa(const int32_t uiDevType, const int32_t uiTxRx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OSC_GetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.uiTxRx = &uiTxRx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OSC_GetVoa(i16_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OSC_GetVoa") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OSC_GetVoa_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetVoa failed: unknown result");
}

int32_t HalApiClient::OSC_SetSwitchPos(const int32_t uiDevType, const COscSwitchPosSet_t& rstSwitchPos)
{
  send_OSC_SetSwitchPos(uiDevType, rstSwitchPos);
  return recv_OSC_SetSwitchPos();
}

void HalApiClient::send_OSC_SetSwitchPos(const int32_t uiDevType, const COscSwitchPosSet_t& rstSwitchPos)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OSC_SetSwitchPos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_SetSwitchPos_pargs args;
  args.uiDevType = &uiDevType;
  args.rstSwitchPos = &rstSwitchPos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OSC_SetSwitchPos()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OSC_SetSwitchPos") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OSC_SetSwitchPos_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_SetSwitchPos failed: unknown result");
}

void HalApiClient::OSC_GetSwitchPos(COscSwitchPos_rsp& _return, const int32_t uiDevType)
{
  send_OSC_GetSwitchPos(uiDevType);
  recv_OSC_GetSwitchPos(_return);
}

void HalApiClient::send_OSC_GetSwitchPos(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OSC_GetSwitchPos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetSwitchPos_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OSC_GetSwitchPos(COscSwitchPos_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OSC_GetSwitchPos") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OSC_GetSwitchPos_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetSwitchPos failed: unknown result");
}

void HalApiClient::OTDR_GetMfg(CMfg_rsp& _return, const int32_t ulDevIdx)
{
  send_OTDR_GetMfg(ulDevIdx);
  recv_OTDR_GetMfg(_return);
}

void HalApiClient::send_OTDR_GetMfg(const int32_t ulDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetMfg_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OTDR_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OTDR_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetMfg failed: unknown result");
}

void HalApiClient::OTDR_GetStatusData(COtdrStatusData_rsp& _return, const int32_t ulDevIdx)
{
  send_OTDR_GetStatusData(ulDevIdx);
  recv_OTDR_GetStatusData(_return);
}

void HalApiClient::send_OTDR_GetStatusData(const int32_t ulDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetStatusData_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OTDR_GetStatusData(COtdrStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OTDR_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetStatusData failed: unknown result");
}

void HalApiClient::OTDR_GetCfgData(COtdrCfgData_rsp& _return, const int32_t ulDevIdx)
{
  send_OTDR_GetCfgData(ulDevIdx);
  recv_OTDR_GetCfgData(_return);
}

void HalApiClient::send_OTDR_GetCfgData(const int32_t ulDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetCfgData_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OTDR_GetCfgData(COtdrCfgData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_GetCfgData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OTDR_GetCfgData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetCfgData failed: unknown result");
}

int32_t HalApiClient::OTDR_StartScan(const int32_t ulDevIdx)
{
  send_OTDR_StartScan(ulDevIdx);
  return recv_OTDR_StartScan();
}

void HalApiClient::send_OTDR_StartScan(const int32_t ulDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_StartScan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_StartScan_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_StartScan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_StartScan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_StartScan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_StartScan failed: unknown result");
}

int32_t HalApiClient::OTDR_SetPara(const int32_t ulDevIdx, const int32_t ulDistRang, const int32_t ulPulseWidth, const double dSamplingResolution)
{
  send_OTDR_SetPara(ulDevIdx, ulDistRang, ulPulseWidth, dSamplingResolution);
  return recv_OTDR_SetPara();
}

void HalApiClient::send_OTDR_SetPara(const int32_t ulDevIdx, const int32_t ulDistRang, const int32_t ulPulseWidth, const double dSamplingResolution)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_SetPara", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetPara_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ulDistRang = &ulDistRang;
  args.ulPulseWidth = &ulPulseWidth;
  args.dSamplingResolution = &dSamplingResolution;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_SetPara()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_SetPara") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_SetPara_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetPara failed: unknown result");
}

int32_t HalApiClient::OTDR_SetMeasuringTime(const int32_t ulDevIdx, const int32_t ulMeasuringTime)
{
  send_OTDR_SetMeasuringTime(ulDevIdx, ulMeasuringTime);
  return recv_OTDR_SetMeasuringTime();
}

void HalApiClient::send_OTDR_SetMeasuringTime(const int32_t ulDevIdx, const int32_t ulMeasuringTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_SetMeasuringTime", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetMeasuringTime_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ulMeasuringTime = &ulMeasuringTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_SetMeasuringTime()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_SetMeasuringTime") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_SetMeasuringTime_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetMeasuringTime failed: unknown result");
}

int32_t HalApiClient::OTDR_SetUserIOR(const int32_t ulDevIdx, const double dUserIOR)
{
  send_OTDR_SetUserIOR(ulDevIdx, dUserIOR);
  return recv_OTDR_SetUserIOR();
}

void HalApiClient::send_OTDR_SetUserIOR(const int32_t ulDevIdx, const double dUserIOR)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_SetUserIOR", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetUserIOR_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.dUserIOR = &dUserIOR;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_SetUserIOR()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_SetUserIOR") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_SetUserIOR_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetUserIOR failed: unknown result");
}

int32_t HalApiClient::OTDR_SetThr(const int32_t ulDevIdx, const double dRefThr, const double dSpliceLosThr, const double dFiberEndThr)
{
  send_OTDR_SetThr(ulDevIdx, dRefThr, dSpliceLosThr, dFiberEndThr);
  return recv_OTDR_SetThr();
}

void HalApiClient::send_OTDR_SetThr(const int32_t ulDevIdx, const double dRefThr, const double dSpliceLosThr, const double dFiberEndThr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_SetThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetThr_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.dRefThr = &dRefThr;
  args.dSpliceLosThr = &dSpliceLosThr;
  args.dFiberEndThr = &dFiberEndThr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_SetThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_SetThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_SetThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetThr failed: unknown result");
}

int32_t HalApiClient::OTDR_Reset(const int32_t ulDevIdx, const int8_t ucResetType)
{
  send_OTDR_Reset(ulDevIdx, ucResetType);
  return recv_OTDR_Reset();
}

void HalApiClient::send_OTDR_Reset(const int32_t ulDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_Reset_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_Reset failed: unknown result");
}

int32_t HalApiClient::OTDR_Upgrade(const int32_t ulDevIdx, const std::string& c_pcFilePath)
{
  send_OTDR_Upgrade(ulDevIdx, c_pcFilePath);
  return recv_OTDR_Upgrade();
}

void HalApiClient::send_OTDR_Upgrade(const int32_t ulDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_Upgrade_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_Upgrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_Upgrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_Upgrade_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_Upgrade failed: unknown result");
}

int32_t HalApiClient::OTDR_GetUpgadeStatus(const int32_t ulDevIdx)
{
  send_OTDR_GetUpgadeStatus(ulDevIdx);
  return recv_OTDR_GetUpgadeStatus();
}

void HalApiClient::send_OTDR_GetUpgadeStatus(const int32_t ulDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetUpgadeStatus_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_GetUpgadeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_GetUpgadeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_GetUpgadeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetUpgadeStatus failed: unknown result");
}

void HalApiClient::OTDR_DbgRead(binary_rsp& _return, const int32_t ulDevIdx, const int32_t uiLen)
{
  send_OTDR_DbgRead(ulDevIdx, uiLen);
  recv_OTDR_DbgRead(_return);
}

void HalApiClient::send_OTDR_DbgRead(const int32_t ulDevIdx, const int32_t uiLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_DbgRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_DbgRead_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OTDR_DbgRead(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_DbgRead") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OTDR_DbgRead_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_DbgRead failed: unknown result");
}

int32_t HalApiClient::OTDR_DbgWrite(const int32_t ulDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  send_OTDR_DbgWrite(ulDevIdx, pucBuf, uiLen);
  return recv_OTDR_DbgWrite();
}

void HalApiClient::send_OTDR_DbgWrite(const int32_t ulDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_DbgWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_DbgWrite_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.pucBuf = &pucBuf;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_DbgWrite()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_DbgWrite") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_DbgWrite_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_DbgWrite failed: unknown result");
}

int32_t HalApiClient::OTDR_SetScanMode(const int32_t uiDevType, const int32_t ulScanMode)
{
  send_OTDR_SetScanMode(uiDevType, ulScanMode);
  return recv_OTDR_SetScanMode();
}

void HalApiClient::send_OTDR_SetScanMode(const int32_t uiDevType, const int32_t ulScanMode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_SetScanMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetScanMode_pargs args;
  args.uiDevType = &uiDevType;
  args.ulScanMode = &ulScanMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_SetScanMode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_SetScanMode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_SetScanMode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetScanMode failed: unknown result");
}

int32_t HalApiClient::OTDR_SetStartOffset(const int32_t uiDevType, const COtdrStartOffset_t& pstStartOffset)
{
  send_OTDR_SetStartOffset(uiDevType, pstStartOffset);
  return recv_OTDR_SetStartOffset();
}

void HalApiClient::send_OTDR_SetStartOffset(const int32_t uiDevType, const COtdrStartOffset_t& pstStartOffset)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_SetStartOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetStartOffset_pargs args;
  args.uiDevType = &uiDevType;
  args.pstStartOffset = &pstStartOffset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_SetStartOffset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_SetStartOffset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_SetStartOffset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetStartOffset failed: unknown result");
}

void HalApiClient::OTDR_GetStartOffset(COtdrStartOffset_rsp& _return, const int32_t uiDevType)
{
  send_OTDR_GetStartOffset(uiDevType);
  recv_OTDR_GetStartOffset(_return);
}

void HalApiClient::send_OTDR_GetStartOffset(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_GetStartOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetStartOffset_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_OTDR_GetStartOffset(COtdrStartOffset_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_GetStartOffset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_OTDR_GetStartOffset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetStartOffset failed: unknown result");
}

int32_t HalApiClient::OTDR_StartScanPort(const int32_t ulDevIdx, const int32_t ulPortId)
{
  send_OTDR_StartScanPort(ulDevIdx, ulPortId);
  return recv_OTDR_StartScanPort();
}

void HalApiClient::send_OTDR_StartScanPort(const int32_t ulDevIdx, const int32_t ulPortId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("OTDR_StartScanPort", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_StartScanPort_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ulPortId = &ulPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_OTDR_StartScanPort()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("OTDR_StartScanPort") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_OTDR_StartScanPort_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_StartScanPort failed: unknown result");
}

void HalApiClient::SLOT_GetDevIdx(i32_list_rsp& _return, const int32_t uiDevType)
{
  send_SLOT_GetDevIdx(uiDevType);
  recv_SLOT_GetDevIdx(_return);
}

void HalApiClient::send_SLOT_GetDevIdx(const int32_t uiDevType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_GetDevIdx", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetDevIdx_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_SLOT_GetDevIdx(i32_list_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_GetDevIdx") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_SLOT_GetDevIdx_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetDevIdx failed: unknown result");
}

int32_t HalApiClient::SLOT_SetOnline(const int32_t uiSlotIdx, const bool bOnline)
{
  send_SLOT_SetOnline(uiSlotIdx, bOnline);
  return recv_SLOT_SetOnline();
}

void HalApiClient::send_SLOT_SetOnline(const int32_t uiSlotIdx, const bool bOnline)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_SetOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetOnline_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.bOnline = &bOnline;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SLOT_SetOnline()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_SetOnline") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SLOT_SetOnline_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetOnline failed: unknown result");
}

void HalApiClient::SLOT_GetSlotNum(i32_rsp& _return)
{
  send_SLOT_GetSlotNum();
  recv_SLOT_GetSlotNum(_return);
}

void HalApiClient::send_SLOT_GetSlotNum()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_GetSlotNum", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetSlotNum_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_SLOT_GetSlotNum(i32_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_GetSlotNum") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_SLOT_GetSlotNum_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetSlotNum failed: unknown result");
}

int32_t HalApiClient::SLOT_SetMfg(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  send_SLOT_SetMfg(uiSlotIdx, c_pcFilePath);
  return recv_SLOT_SetMfg();
}

void HalApiClient::send_SLOT_SetMfg(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_SetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetMfg_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SLOT_SetMfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_SetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SLOT_SetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetMfg failed: unknown result");
}

void HalApiClient::SLOT_GetMfg(CMfg_rsp& _return, const int32_t uiSlotIdx)
{
  send_SLOT_GetMfg(uiSlotIdx);
  recv_SLOT_GetMfg(_return);
}

void HalApiClient::send_SLOT_GetMfg(const int32_t uiSlotIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetMfg_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_SLOT_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_SLOT_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetMfg failed: unknown result");
}

void HalApiClient::SLOT_GetStatusData(CSlotStatusData_rsp& _return, const int32_t uiSlotIdx)
{
  send_SLOT_GetStatusData(uiSlotIdx);
  recv_SLOT_GetStatusData(_return);
}

void HalApiClient::send_SLOT_GetStatusData(const int32_t uiSlotIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetStatusData_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_SLOT_GetStatusData(CSlotStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_SLOT_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetStatusData failed: unknown result");
}

int32_t HalApiClient::SLOT_ClearPlugFlag(const int32_t uiSlotIdx)
{
  send_SLOT_ClearPlugFlag(uiSlotIdx);
  return recv_SLOT_ClearPlugFlag();
}

void HalApiClient::send_SLOT_ClearPlugFlag(const int32_t uiSlotIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_ClearPlugFlag", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_ClearPlugFlag_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SLOT_ClearPlugFlag()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_ClearPlugFlag") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SLOT_ClearPlugFlag_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_ClearPlugFlag failed: unknown result");
}

void HalApiClient::SLOT_GetInfo(CSlotInfo_rsp& _return, const int32_t uiSlotIdx)
{
  send_SLOT_GetInfo(uiSlotIdx);
  recv_SLOT_GetInfo(_return);
}

void HalApiClient::send_SLOT_GetInfo(const int32_t uiSlotIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_GetInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetInfo_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_SLOT_GetInfo(CSlotInfo_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_GetInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_SLOT_GetInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetInfo failed: unknown result");
}

void HalApiClient::SLOT_GetCali(CCali_rsp& _return, const int32_t uiSlotIdx)
{
  send_SLOT_GetCali(uiSlotIdx);
  recv_SLOT_GetCali(_return);
}

void HalApiClient::send_SLOT_GetCali(const int32_t uiSlotIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_GetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetCali_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_SLOT_GetCali(CCali_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_GetCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_SLOT_GetCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetCali failed: unknown result");
}

int32_t HalApiClient::SLOT_SetCali(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  send_SLOT_SetCali(uiSlotIdx, c_pcFilePath);
  return recv_SLOT_SetCali();
}

void HalApiClient::send_SLOT_SetCali(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_SetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetCali_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SLOT_SetCali()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_SetCali") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SLOT_SetCali_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetCali failed: unknown result");
}

int32_t HalApiClient::SLOT_Reset(const int32_t uiSlotIdx, const int8_t ucResetType)
{
  send_SLOT_Reset(uiSlotIdx, ucResetType);
  return recv_SLOT_Reset();
}

void HalApiClient::send_SLOT_Reset(const int32_t uiSlotIdx, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_Reset_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SLOT_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SLOT_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_Reset failed: unknown result");
}

int32_t HalApiClient::SLOT_SetLed(const int32_t uiSlotIdx, const int32_t uiLedIdx, const int32_t uiState)
{
  send_SLOT_SetLed(uiSlotIdx, uiLedIdx, uiState);
  return recv_SLOT_SetLed();
}

void HalApiClient::send_SLOT_SetLed(const int32_t uiSlotIdx, const int32_t uiLedIdx, const int32_t uiState)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_SetLed", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetLed_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.uiLedIdx = &uiLedIdx;
  args.uiState = &uiState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SLOT_SetLed()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_SetLed") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SLOT_SetLed_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetLed failed: unknown result");
}

void HalApiClient::SLOT_ReadEeprom(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  send_SLOT_ReadEeprom(uiIdx, ulAddr, ulLen);
  recv_SLOT_ReadEeprom(_return);
}

void HalApiClient::send_SLOT_ReadEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_ReadEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_ReadEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_SLOT_ReadEeprom(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_ReadEeprom") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_SLOT_ReadEeprom_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_ReadEeprom failed: unknown result");
}

int32_t HalApiClient::SLOT_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  send_SLOT_WriteEeprom(uiIdx, ulAddr, ulLen, pucVal);
  return recv_SLOT_WriteEeprom();
}

void HalApiClient::send_SLOT_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SLOT_WriteEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_WriteEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_SLOT_WriteEeprom()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SLOT_WriteEeprom") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_SLOT_WriteEeprom_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_WriteEeprom failed: unknown result");
}

void HalApiClient::TDCM_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  send_TDCM_GetMfg(uiDevIdx);
  recv_TDCM_GetMfg(_return);
}

void HalApiClient::send_TDCM_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TDCM_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_TDCM_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TDCM_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_TDCM_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_GetMfg failed: unknown result");
}

void HalApiClient::TDCM_GetStatusData(CTdcmStatusData_rsp& _return, const int32_t uiDevIdx)
{
  send_TDCM_GetStatusData(uiDevIdx);
  recv_TDCM_GetStatusData(_return);
}

void HalApiClient::send_TDCM_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TDCM_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_TDCM_GetStatusData(CTdcmStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TDCM_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_TDCM_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_GetStatusData failed: unknown result");
}

void HalApiClient::TDCM_GetCfgData(CTdcmCfgData_rsp& _return, const int32_t uiDevIdx)
{
  send_TDCM_GetCfgData(uiDevIdx);
  recv_TDCM_GetCfgData(_return);
}

void HalApiClient::send_TDCM_GetCfgData(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TDCM_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_GetCfgData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_TDCM_GetCfgData(CTdcmCfgData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TDCM_GetCfgData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_TDCM_GetCfgData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_GetCfgData failed: unknown result");
}

int32_t HalApiClient::TDCM_SetFrequency(const int32_t uiDevIdx, const double fFrequency)
{
  send_TDCM_SetFrequency(uiDevIdx, fFrequency);
  return recv_TDCM_SetFrequency();
}

void HalApiClient::send_TDCM_SetFrequency(const int32_t uiDevIdx, const double fFrequency)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TDCM_SetFrequency", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_SetFrequency_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.fFrequency = &fFrequency;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_TDCM_SetFrequency()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TDCM_SetFrequency") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_TDCM_SetFrequency_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_SetFrequency failed: unknown result");
}

int32_t HalApiClient::TDCM_SetDispersion(const int32_t uiDevIdx, const double fDispersion)
{
  send_TDCM_SetDispersion(uiDevIdx, fDispersion);
  return recv_TDCM_SetDispersion();
}

void HalApiClient::send_TDCM_SetDispersion(const int32_t uiDevIdx, const double fDispersion)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TDCM_SetDispersion", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_SetDispersion_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.fDispersion = &fDispersion;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_TDCM_SetDispersion()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TDCM_SetDispersion") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_TDCM_SetDispersion_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_SetDispersion failed: unknown result");
}

int32_t HalApiClient::TDCM_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  send_TDCM_Reset(uiDevIdx, ucResetType);
  return recv_TDCM_Reset();
}

void HalApiClient::send_TDCM_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TDCM_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_TDCM_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TDCM_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_TDCM_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_Reset failed: unknown result");
}

void HalApiClient::WSS_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  send_WSS_GetMfg(uiDevIdx);
  recv_WSS_GetMfg(_return);
}

void HalApiClient::send_WSS_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_WSS_GetMfg(CMfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetMfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_WSS_GetMfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetMfg failed: unknown result");
}

void HalApiClient::WSS_GetCfg(CWssAllCfg_rsp& _return, const int32_t uiDevIdx)
{
  send_WSS_GetCfg(uiDevIdx);
  recv_WSS_GetCfg(_return);
}

void HalApiClient::send_WSS_GetCfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_WSS_GetCfg(CWssAllCfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetCfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_WSS_GetCfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetCfg failed: unknown result");
}

void HalApiClient::WSS_GetOscCfg(CWssAllCfg_rsp& _return, const int32_t uiDevIdx)
{
  send_WSS_GetOscCfg(uiDevIdx);
  recv_WSS_GetOscCfg(_return);
}

void HalApiClient::send_WSS_GetOscCfg(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetOscCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetOscCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_WSS_GetOscCfg(CWssAllCfg_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetOscCfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_WSS_GetOscCfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetOscCfg failed: unknown result");
}

void HalApiClient::WSS_GetStatusData(CWssStatusData_rsp& _return, const int32_t uiDevIdx)
{
  send_WSS_GetStatusData(uiDevIdx);
  recv_WSS_GetStatusData(_return);
}

void HalApiClient::send_WSS_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_WSS_GetStatusData(CWssStatusData_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetStatusData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_WSS_GetStatusData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetStatusData failed: unknown result");
}

int32_t HalApiClient::WSS_SetAllChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  send_WSS_SetAllChCfg(uiDevIdx, uiSubIdx, uiChCnt, pstWssCfg);
  return recv_WSS_SetAllChCfg();
}

void HalApiClient::send_WSS_SetAllChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetAllChCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetAllChCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiSubIdx = &uiSubIdx;
  args.uiChCnt = &uiChCnt;
  args.pstWssCfg = &pstWssCfg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetAllChCfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetAllChCfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetAllChCfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetAllChCfg failed: unknown result");
}

int32_t HalApiClient::WSS_SetOscChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  send_WSS_SetOscChCfg(uiDevIdx, uiSubIdx, uiChCnt, pstWssCfg);
  return recv_WSS_SetOscChCfg();
}

void HalApiClient::send_WSS_SetOscChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetOscChCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetOscChCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiSubIdx = &uiSubIdx;
  args.uiChCnt = &uiChCnt;
  args.pstWssCfg = &pstWssCfg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetOscChCfg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetOscChCfg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetOscChCfg_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetOscChCfg failed: unknown result");
}

int32_t HalApiClient::WSS_SetWaveplan(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWavePlan_t> & pstWavePlan)
{
  send_WSS_SetWaveplan(uiDevIdx, uiSubIdx, uiChCnt, pstWavePlan);
  return recv_WSS_SetWaveplan();
}

void HalApiClient::send_WSS_SetWaveplan(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWavePlan_t> & pstWavePlan)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetWaveplan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetWaveplan_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiSubIdx = &uiSubIdx;
  args.uiChCnt = &uiChCnt;
  args.pstWavePlan = &pstWavePlan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetWaveplan()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetWaveplan") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetWaveplan_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetWaveplan failed: unknown result");
}

int32_t HalApiClient::WSS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr)
{
  send_WSS_SetPortPowerThr(uiDevIdx, uiPortIdx, uiType, sThr);
  return recv_WSS_SetPortPowerThr();
}

void HalApiClient::send_WSS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetPortPowerThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetPortPowerThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetPortPowerThr()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetPortPowerThr") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetPortPowerThr_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetPortPowerThr failed: unknown result");
}

int32_t HalApiClient::WSS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys)
{
  send_WSS_SetPortPowerHys(uiDevIdx, uiPortIdx, uiType, sHys);
  return recv_WSS_SetPortPowerHys();
}

void HalApiClient::send_WSS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetPortPowerHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetPortPowerHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetPortPowerHys()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetPortPowerHys") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetPortPowerHys_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetPortPowerHys failed: unknown result");
}

int32_t HalApiClient::WSS_GetPortPowerHistory(const int32_t uiDevIdx)
{
  send_WSS_GetPortPowerHistory(uiDevIdx);
  return recv_WSS_GetPortPowerHistory();
}

void HalApiClient::send_WSS_GetPortPowerHistory(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetPortPowerHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetPortPowerHistory_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_GetPortPowerHistory()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetPortPowerHistory") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_GetPortPowerHistory_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetPortPowerHistory failed: unknown result");
}

int32_t HalApiClient::WSS_SetLedMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  send_WSS_SetLedMode(uiDevIdx, uiMode);
  return recv_WSS_SetLedMode();
}

void HalApiClient::send_WSS_SetLedMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetLedMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetLedMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetLedMode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetLedMode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetLedMode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetLedMode failed: unknown result");
}

int32_t HalApiClient::WSS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  send_WSS_SetLedDebugMode(uiDevIdx, uiMode);
  return recv_WSS_SetLedDebugMode();
}

void HalApiClient::send_WSS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetLedDebugMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetLedDebugMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetLedDebugMode()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetLedDebugMode") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetLedDebugMode_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetLedDebugMode failed: unknown result");
}

int32_t HalApiClient::WSS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  send_WSS_SetLedStatus(uiDevIdx, uiLedIdx, uiStatus);
  return recv_WSS_SetLedStatus();
}

void HalApiClient::send_WSS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetLedStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetLedStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiLedIdx = &uiLedIdx;
  args.uiStatus = &uiStatus;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetLedStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetLedStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetLedStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetLedStatus failed: unknown result");
}

int32_t HalApiClient::WSS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  send_WSS_Reset(uiDevIdx, ucResetType);
  return recv_WSS_Reset();
}

void HalApiClient::send_WSS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_Reset()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_Reset") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_Reset_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_Reset failed: unknown result");
}

int32_t HalApiClient::WSS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  send_WSS_Upgrade(uiDevIdx, c_pcFilePath);
  return recv_WSS_Upgrade();
}

void HalApiClient::send_WSS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_Upgrade_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_Upgrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_Upgrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_Upgrade_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_Upgrade failed: unknown result");
}

int32_t HalApiClient::WSS_GetUpgradeStatus(const int32_t uiDevIdx)
{
  send_WSS_GetUpgradeStatus(uiDevIdx);
  return recv_WSS_GetUpgradeStatus();
}

void HalApiClient::send_WSS_GetUpgradeStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetUpgradeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetUpgradeStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_GetUpgradeStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetUpgradeStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_GetUpgradeStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetUpgradeStatus failed: unknown result");
}

int32_t HalApiClient::WSS_SetUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  send_WSS_SetUserData(uiDevIdx, pucData, nLen);
  return recv_WSS_SetUserData();
}

void HalApiClient::send_WSS_SetUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pucData = &pucData;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetUserData()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetUserData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetUserData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetUserData failed: unknown result");
}

void HalApiClient::WSS_GetUserData(binary_rsp& _return, const int32_t uiDevIdx, const int32_t nLen)
{
  send_WSS_GetUserData(uiDevIdx, nLen);
  recv_WSS_GetUserData(_return);
}

void HalApiClient::send_WSS_GetUserData(const int32_t uiDevIdx, const int32_t nLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_WSS_GetUserData(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetUserData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_WSS_GetUserData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetUserData failed: unknown result");
}

int32_t HalApiClient::WSS_SetPmUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  send_WSS_SetPmUserData(uiDevIdx, pucData, nLen);
  return recv_WSS_SetPmUserData();
}

void HalApiClient::send_WSS_SetPmUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_SetPmUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetPmUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pucData = &pucData;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HalApiClient::recv_WSS_SetPmUserData()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_SetPmUserData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HalApi_WSS_SetPmUserData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetPmUserData failed: unknown result");
}

void HalApiClient::WSS_GetPmUserData(binary_rsp& _return, const int32_t uiDevIdx, const int32_t nLen)
{
  send_WSS_GetPmUserData(uiDevIdx, nLen);
  recv_WSS_GetPmUserData(_return);
}

void HalApiClient::send_WSS_GetPmUserData(const int32_t uiDevIdx, const int32_t nLen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("WSS_GetPmUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetPmUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HalApiClient::recv_WSS_GetPmUserData(binary_rsp& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("WSS_GetPmUserData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HalApi_WSS_GetPmUserData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetPmUserData failed: unknown result");
}

bool HalApiProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void HalApiProcessor::process_BOARD_GetChassisMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetChassisMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetChassisMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetChassisMfg");
  }

  HalApi_BOARD_GetChassisMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetChassisMfg", bytes);
  }

  HalApi_BOARD_GetChassisMfg_result result;
  try {
    iface_->BOARD_GetChassisMfg(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetChassisMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetChassisMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetChassisMfg");
  }

  oprot->writeMessageBegin("BOARD_GetChassisMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetChassisMfg", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetChassisMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetChassisMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetChassisMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetChassisMfg");
  }

  HalApi_BOARD_SetChassisMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetChassisMfg", bytes);
  }

  HalApi_BOARD_SetChassisMfg_result result;
  try {
    result.success = iface_->BOARD_SetChassisMfg(args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetChassisMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetChassisMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetChassisMfg");
  }

  oprot->writeMessageBegin("BOARD_SetChassisMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetChassisMfg", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetChassisConfigType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetChassisConfigType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetChassisConfigType");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetChassisConfigType");
  }

  HalApi_BOARD_SetChassisConfigType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetChassisConfigType", bytes);
  }

  HalApi_BOARD_SetChassisConfigType_result result;
  try {
    result.success = iface_->BOARD_SetChassisConfigType(args.pcConfigType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetChassisConfigType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetChassisConfigType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetChassisConfigType");
  }

  oprot->writeMessageBegin("BOARD_SetChassisConfigType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetChassisConfigType", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetChassisCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetChassisCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetChassisCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetChassisCali");
  }

  HalApi_BOARD_GetChassisCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetChassisCali", bytes);
  }

  HalApi_BOARD_GetChassisCali_result result;
  try {
    iface_->BOARD_GetChassisCali(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetChassisCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetChassisCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetChassisCali");
  }

  oprot->writeMessageBegin("BOARD_GetChassisCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetChassisCali", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetChassisCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetChassisCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetChassisCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetChassisCali");
  }

  HalApi_BOARD_SetChassisCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetChassisCali", bytes);
  }

  HalApi_BOARD_SetChassisCali_result result;
  try {
    result.success = iface_->BOARD_SetChassisCali(args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetChassisCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetChassisCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetChassisCali");
  }

  oprot->writeMessageBegin("BOARD_SetChassisCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetChassisCali", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetChassisCfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetChassisCfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetChassisCfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetChassisCfg");
  }

  HalApi_BOARD_GetChassisCfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetChassisCfg", bytes);
  }

  HalApi_BOARD_GetChassisCfg_result result;
  try {
    result.success = iface_->BOARD_GetChassisCfg(args.uiAddrSlice, args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetChassisCfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetChassisCfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetChassisCfg");
  }

  oprot->writeMessageBegin("BOARD_GetChassisCfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetChassisCfg", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetChassisCfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetChassisCfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetChassisCfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetChassisCfg");
  }

  HalApi_BOARD_SetChassisCfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetChassisCfg", bytes);
  }

  HalApi_BOARD_SetChassisCfg_result result;
  try {
    result.success = iface_->BOARD_SetChassisCfg(args.uiAddrSlice, args.uiSize, args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetChassisCfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetChassisCfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetChassisCfg");
  }

  oprot->writeMessageBegin("BOARD_SetChassisCfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetChassisCfg", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetUpgInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetUpgInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetUpgInfo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetUpgInfo");
  }

  HalApi_BOARD_GetUpgInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetUpgInfo", bytes);
  }

  HalApi_BOARD_GetUpgInfo_result result;
  try {
    iface_->BOARD_GetUpgInfo(result.success, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetUpgInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetUpgInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetUpgInfo");
  }

  oprot->writeMessageBegin("BOARD_GetUpgInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetUpgInfo", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetUpgInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetUpgInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetUpgInfo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetUpgInfo");
  }

  HalApi_BOARD_SetUpgInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetUpgInfo", bytes);
  }

  HalApi_BOARD_SetUpgInfo_result result;
  try {
    result.success = iface_->BOARD_SetUpgInfo(args.pucBuf, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetUpgInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetUpgInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetUpgInfo");
  }

  oprot->writeMessageBegin("BOARD_SetUpgInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetUpgInfo", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetBdlHead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetBdlHead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetBdlHead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetBdlHead");
  }

  HalApi_BOARD_GetBdlHead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetBdlHead", bytes);
  }

  HalApi_BOARD_GetBdlHead_result result;
  try {
    iface_->BOARD_GetBdlHead(result.success, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetBdlHead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetBdlHead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetBdlHead");
  }

  oprot->writeMessageBegin("BOARD_GetBdlHead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetBdlHead", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetBdlHead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetBdlHead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetBdlHead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetBdlHead");
  }

  HalApi_BOARD_SetBdlHead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetBdlHead", bytes);
  }

  HalApi_BOARD_SetBdlHead_result result;
  try {
    result.success = iface_->BOARD_SetBdlHead(args.pucBuf, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetBdlHead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetBdlHead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetBdlHead");
  }

  oprot->writeMessageBegin("BOARD_SetBdlHead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetBdlHead", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetStatusData");
  }

  HalApi_BOARD_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetStatusData", bytes);
  }

  HalApi_BOARD_GetStatusData_result result;
  try {
    iface_->BOARD_GetStatusData(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetStatusData");
  }

  oprot->writeMessageBegin("BOARD_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetSccMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetSccMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetSccMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetSccMfg");
  }

  HalApi_BOARD_GetSccMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetSccMfg", bytes);
  }

  HalApi_BOARD_GetSccMfg_result result;
  try {
    iface_->BOARD_GetSccMfg(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetSccMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetSccMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetSccMfg");
  }

  oprot->writeMessageBegin("BOARD_GetSccMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetSccMfg", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetSccMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetSccMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetSccMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetSccMfg");
  }

  HalApi_BOARD_SetSccMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetSccMfg", bytes);
  }

  HalApi_BOARD_SetSccMfg_result result;
  try {
    result.success = iface_->BOARD_SetSccMfg(args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetSccMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetSccMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetSccMfg");
  }

  oprot->writeMessageBegin("BOARD_SetSccMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetSccMfg", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetResetType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetResetType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetResetType");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetResetType");
  }

  HalApi_BOARD_SetResetType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetResetType", bytes);
  }

  HalApi_BOARD_SetResetType_result result;
  try {
    result.success = iface_->BOARD_SetResetType(args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetResetType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetResetType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetResetType");
  }

  oprot->writeMessageBegin("BOARD_SetResetType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetResetType", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetResetType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetResetType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetResetType");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetResetType");
  }

  HalApi_BOARD_GetResetType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetResetType", bytes);
  }

  HalApi_BOARD_GetResetType_result result;
  try {
    iface_->BOARD_GetResetType(result.success, args.iIndex);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetResetType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetResetType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetResetType");
  }

  oprot->writeMessageBegin("BOARD_GetResetType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetResetType", bytes);
  }
}

void HalApiProcessor::process_BOARD_CfgWatchDogTime(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_CfgWatchDogTime", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_CfgWatchDogTime");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_CfgWatchDogTime");
  }

  HalApi_BOARD_CfgWatchDogTime_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_CfgWatchDogTime", bytes);
  }

  HalApi_BOARD_CfgWatchDogTime_result result;
  try {
    result.success = iface_->BOARD_CfgWatchDogTime(args.bEnable, args.ucTimeout);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_CfgWatchDogTime");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_CfgWatchDogTime", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_CfgWatchDogTime");
  }

  oprot->writeMessageBegin("BOARD_CfgWatchDogTime", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_CfgWatchDogTime", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetApsdStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetApsdStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetApsdStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetApsdStatus");
  }

  HalApi_BOARD_GetApsdStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetApsdStatus", bytes);
  }

  HalApi_BOARD_GetApsdStatus_result result;
  try {
    iface_->BOARD_GetApsdStatus(result.success, args.iIndex);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetApsdStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetApsdStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetApsdStatus");
  }

  oprot->writeMessageBegin("BOARD_GetApsdStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetApsdStatus", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetLedState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetLedState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetLedState");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetLedState");
  }

  HalApi_BOARD_SetLedState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetLedState", bytes);
  }

  HalApi_BOARD_SetLedState_result result;
  try {
    result.success = iface_->BOARD_SetLedState(args.uiDevIdx, args.uiState);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetLedState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetLedState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetLedState");
  }

  oprot->writeMessageBegin("BOARD_SetLedState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetLedState", bytes);
  }
}

void HalApiProcessor::process_BOARD_ResetLogic(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_ResetLogic", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_ResetLogic");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_ResetLogic");
  }

  HalApi_BOARD_ResetLogic_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_ResetLogic", bytes);
  }

  HalApi_BOARD_ResetLogic_result result;
  try {
    result.success = iface_->BOARD_ResetLogic(args.uiDevIdx, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_ResetLogic");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_ResetLogic", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_ResetLogic");
  }

  oprot->writeMessageBegin("BOARD_ResetLogic", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_ResetLogic", bytes);
  }
}

void HalApiProcessor::process_BOARD_UpgradeLogic(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_UpgradeLogic", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_UpgradeLogic");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_UpgradeLogic");
  }

  HalApi_BOARD_UpgradeLogic_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_UpgradeLogic", bytes);
  }

  HalApi_BOARD_UpgradeLogic_result result;
  try {
    result.success = iface_->BOARD_UpgradeLogic(args.uiDevIdx, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_UpgradeLogic");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_UpgradeLogic", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_UpgradeLogic");
  }

  oprot->writeMessageBegin("BOARD_UpgradeLogic", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_UpgradeLogic", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetUpgadeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetUpgadeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetUpgadeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetUpgadeStatus");
  }

  HalApi_BOARD_GetUpgadeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetUpgadeStatus", bytes);
  }

  HalApi_BOARD_GetUpgadeStatus_result result;
  try {
    result.success = iface_->BOARD_GetUpgadeStatus();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetUpgadeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetUpgadeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetUpgadeStatus");
  }

  oprot->writeMessageBegin("BOARD_GetUpgadeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetUpgadeStatus", bytes);
  }
}

void HalApiProcessor::process_FAN_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.FAN_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.FAN_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.FAN_GetMfg");
  }

  HalApi_FAN_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.FAN_GetMfg", bytes);
  }

  HalApi_FAN_GetMfg_result result;
  try {
    iface_->FAN_GetMfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.FAN_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("FAN_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.FAN_GetMfg");
  }

  oprot->writeMessageBegin("FAN_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.FAN_GetMfg", bytes);
  }
}

void HalApiProcessor::process_FAN_SetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.FAN_SetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.FAN_SetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.FAN_SetMfg");
  }

  HalApi_FAN_SetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.FAN_SetMfg", bytes);
  }

  HalApi_FAN_SetMfg_result result;
  try {
    result.success = iface_->FAN_SetMfg(args.uiDevIdx, args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.FAN_SetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("FAN_SetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.FAN_SetMfg");
  }

  oprot->writeMessageBegin("FAN_SetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.FAN_SetMfg", bytes);
  }
}

void HalApiProcessor::process_FAN_SetSpeed(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.FAN_SetSpeed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.FAN_SetSpeed");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.FAN_SetSpeed");
  }

  HalApi_FAN_SetSpeed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.FAN_SetSpeed", bytes);
  }

  HalApi_FAN_SetSpeed_result result;
  try {
    result.success = iface_->FAN_SetSpeed(args.uiDevIdx, args.uiDuty);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.FAN_SetSpeed");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("FAN_SetSpeed", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.FAN_SetSpeed");
  }

  oprot->writeMessageBegin("FAN_SetSpeed", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.FAN_SetSpeed", bytes);
  }
}

void HalApiProcessor::process_FAN_SetControllerEEP(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.FAN_SetControllerEEP", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.FAN_SetControllerEEP");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.FAN_SetControllerEEP");
  }

  HalApi_FAN_SetControllerEEP_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.FAN_SetControllerEEP", bytes);
  }

  HalApi_FAN_SetControllerEEP_result result;
  try {
    result.success = iface_->FAN_SetControllerEEP(args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.FAN_SetControllerEEP");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("FAN_SetControllerEEP", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.FAN_SetControllerEEP");
  }

  oprot->writeMessageBegin("FAN_SetControllerEEP", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.FAN_SetControllerEEP", bytes);
  }
}

void HalApiProcessor::process_FAN_SetLed(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.FAN_SetLed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.FAN_SetLed");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.FAN_SetLed");
  }

  HalApi_FAN_SetLed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.FAN_SetLed", bytes);
  }

  HalApi_FAN_SetLed_result result;
  try {
    result.success = iface_->FAN_SetLed(args.uiDevIdx, args.uiValue);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.FAN_SetLed");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("FAN_SetLed", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.FAN_SetLed");
  }

  oprot->writeMessageBegin("FAN_SetLed", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.FAN_SetLed", bytes);
  }
}

void HalApiProcessor::process_POWER_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.POWER_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.POWER_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.POWER_GetMfg");
  }

  HalApi_POWER_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.POWER_GetMfg", bytes);
  }

  HalApi_POWER_GetMfg_result result;
  try {
    iface_->POWER_GetMfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.POWER_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("POWER_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.POWER_GetMfg");
  }

  oprot->writeMessageBegin("POWER_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.POWER_GetMfg", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetProductName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetProductName", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetProductName");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetProductName");
  }

  HalApi_BOARD_GetProductName_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetProductName", bytes);
  }

  HalApi_BOARD_GetProductName_result result;
  try {
    iface_->BOARD_GetProductName(result.success, args.nSize);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetProductName");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetProductName", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetProductName");
  }

  oprot->writeMessageBegin("BOARD_GetProductName", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetProductName", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetConfigType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetConfigType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetConfigType");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetConfigType");
  }

  HalApi_BOARD_GetConfigType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetConfigType", bytes);
  }

  HalApi_BOARD_GetConfigType_result result;
  try {
    iface_->BOARD_GetConfigType(result.success, args.nSize);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetConfigType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetConfigType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetConfigType");
  }

  oprot->writeMessageBegin("BOARD_GetConfigType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetConfigType", bytes);
  }
}

void HalApiProcessor::process_BOARD_GetProductType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_GetProductType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_GetProductType");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_GetProductType");
  }

  HalApi_BOARD_GetProductType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_GetProductType", bytes);
  }

  HalApi_BOARD_GetProductType_result result;
  try {
    result.success = iface_->BOARD_GetProductType();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_GetProductType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_GetProductType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_GetProductType");
  }

  oprot->writeMessageBegin("BOARD_GetProductType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_GetProductType", bytes);
  }
}

void HalApiProcessor::process_BOARD_SetLogLevel(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_SetLogLevel", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_SetLogLevel");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_SetLogLevel");
  }

  HalApi_BOARD_SetLogLevel_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_SetLogLevel", bytes);
  }

  HalApi_BOARD_SetLogLevel_result result;
  try {
    result.success = iface_->BOARD_SetLogLevel(args.uiLogLevel);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_SetLogLevel");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_SetLogLevel", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_SetLogLevel");
  }

  oprot->writeMessageBegin("BOARD_SetLogLevel", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_SetLogLevel", bytes);
  }
}

void HalApiProcessor::process_BOARD_ConvertDevType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.BOARD_ConvertDevType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.BOARD_ConvertDevType");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.BOARD_ConvertDevType");
  }

  HalApi_BOARD_ConvertDevType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.BOARD_ConvertDevType", bytes);
  }

  HalApi_BOARD_ConvertDevType_result result;
  try {
    iface_->BOARD_ConvertDevType(result.success, args.pcName);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.BOARD_ConvertDevType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("BOARD_ConvertDevType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.BOARD_ConvertDevType");
  }

  oprot->writeMessageBegin("BOARD_ConvertDevType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.BOARD_ConvertDevType", bytes);
  }
}

void HalApiProcessor::process_Cv_GetMuxStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.Cv_GetMuxStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.Cv_GetMuxStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.Cv_GetMuxStatusData");
  }

  HalApi_Cv_GetMuxStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.Cv_GetMuxStatusData", bytes);
  }

  HalApi_Cv_GetMuxStatusData_result result;
  try {
    iface_->Cv_GetMuxStatusData(result.success, args.enCvLine);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.Cv_GetMuxStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Cv_GetMuxStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.Cv_GetMuxStatusData");
  }

  oprot->writeMessageBegin("Cv_GetMuxStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.Cv_GetMuxStatusData", bytes);
  }
}

void HalApiProcessor::process_Cv_GetClientStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.Cv_GetClientStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.Cv_GetClientStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.Cv_GetClientStatusData");
  }

  HalApi_Cv_GetClientStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.Cv_GetClientStatusData", bytes);
  }

  HalApi_Cv_GetClientStatusData_result result;
  try {
    iface_->Cv_GetClientStatusData(result.success, args.enCvLine);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.Cv_GetClientStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Cv_GetClientStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.Cv_GetClientStatusData");
  }

  oprot->writeMessageBegin("Cv_GetClientStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.Cv_GetClientStatusData", bytes);
  }
}

void HalApiProcessor::process_Cv_GetRef(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.Cv_GetRef", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.Cv_GetRef");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.Cv_GetRef");
  }

  HalApi_Cv_GetRef_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.Cv_GetRef", bytes);
  }

  HalApi_Cv_GetRef_result result;
  try {
    iface_->Cv_GetRef(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.Cv_GetRef");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("Cv_GetRef", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.Cv_GetRef");
  }

  oprot->writeMessageBegin("Cv_GetRef", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.Cv_GetRef", bytes);
  }
}

void HalApiProcessor::process_DBG_ReadLogicReg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_ReadLogicReg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_ReadLogicReg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_ReadLogicReg");
  }

  HalApi_DBG_ReadLogicReg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_ReadLogicReg", bytes);
  }

  HalApi_DBG_ReadLogicReg_result result;
  try {
    iface_->DBG_ReadLogicReg(result.success, args.uiIdx, args.ulAddr, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_ReadLogicReg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_ReadLogicReg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_ReadLogicReg");
  }

  oprot->writeMessageBegin("DBG_ReadLogicReg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_ReadLogicReg", bytes);
  }
}

void HalApiProcessor::process_DBG_WriteLogicReg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_WriteLogicReg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_WriteLogicReg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_WriteLogicReg");
  }

  HalApi_DBG_WriteLogicReg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_WriteLogicReg", bytes);
  }

  HalApi_DBG_WriteLogicReg_result result;
  try {
    result.success = iface_->DBG_WriteLogicReg(args.uiIdx, args.ulAddr, args.ulLen, args.pucVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_WriteLogicReg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_WriteLogicReg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_WriteLogicReg");
  }

  oprot->writeMessageBegin("DBG_WriteLogicReg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_WriteLogicReg", bytes);
  }
}

void HalApiProcessor::process_DBG_ReadLogicRegSlc(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_ReadLogicRegSlc", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_ReadLogicRegSlc");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_ReadLogicRegSlc");
  }

  HalApi_DBG_ReadLogicRegSlc_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_ReadLogicRegSlc", bytes);
  }

  HalApi_DBG_ReadLogicRegSlc_result result;
  try {
    iface_->DBG_ReadLogicRegSlc(result.success, args.uiIdx, args.ulAddr, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_ReadLogicRegSlc");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_ReadLogicRegSlc", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_ReadLogicRegSlc");
  }

  oprot->writeMessageBegin("DBG_ReadLogicRegSlc", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_ReadLogicRegSlc", bytes);
  }
}

void HalApiProcessor::process_DBG_WriteLogicRegSlc(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_WriteLogicRegSlc", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_WriteLogicRegSlc");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_WriteLogicRegSlc");
  }

  HalApi_DBG_WriteLogicRegSlc_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_WriteLogicRegSlc", bytes);
  }

  HalApi_DBG_WriteLogicRegSlc_result result;
  try {
    result.success = iface_->DBG_WriteLogicRegSlc(args.uiIdx, args.ulAddr, args.ulLen, args.pucVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_WriteLogicRegSlc");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_WriteLogicRegSlc", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_WriteLogicRegSlc");
  }

  oprot->writeMessageBegin("DBG_WriteLogicRegSlc", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_WriteLogicRegSlc", bytes);
  }
}

void HalApiProcessor::process_DBG_LoopEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_LoopEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_LoopEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_LoopEnable");
  }

  HalApi_DBG_LoopEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_LoopEnable", bytes);
  }

  HalApi_DBG_LoopEnable_result result;
  try {
    result.success = iface_->DBG_LoopEnable(args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_LoopEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_LoopEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_LoopEnable");
  }

  oprot->writeMessageBegin("DBG_LoopEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_LoopEnable", bytes);
  }
}

void HalApiProcessor::process_DBG_LoopInterval(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_LoopInterval", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_LoopInterval");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_LoopInterval");
  }

  HalApi_DBG_LoopInterval_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_LoopInterval", bytes);
  }

  HalApi_DBG_LoopInterval_result result;
  try {
    result.success = iface_->DBG_LoopInterval(args.uiInterval);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_LoopInterval");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_LoopInterval", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_LoopInterval");
  }

  oprot->writeMessageBegin("DBG_LoopInterval", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_LoopInterval", bytes);
  }
}

void HalApiProcessor::process_DBG_IdleEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_IdleEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_IdleEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_IdleEnable");
  }

  HalApi_DBG_IdleEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_IdleEnable", bytes);
  }

  HalApi_DBG_IdleEnable_result result;
  try {
    result.success = iface_->DBG_IdleEnable(args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_IdleEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_IdleEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_IdleEnable");
  }

  oprot->writeMessageBegin("DBG_IdleEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_IdleEnable", bytes);
  }
}

void HalApiProcessor::process_DBG_ApsdEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_ApsdEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_ApsdEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_ApsdEnable");
  }

  HalApi_DBG_ApsdEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_ApsdEnable", bytes);
  }

  HalApi_DBG_ApsdEnable_result result;
  try {
    result.success = iface_->DBG_ApsdEnable(args.iIndex, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_ApsdEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_ApsdEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_ApsdEnable");
  }

  oprot->writeMessageBegin("DBG_ApsdEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_ApsdEnable", bytes);
  }
}

void HalApiProcessor::process_DBG_GetAprStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_GetAprStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_GetAprStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_GetAprStatus");
  }

  HalApi_DBG_GetAprStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_GetAprStatus", bytes);
  }

  HalApi_DBG_GetAprStatus_result result;
  try {
    iface_->DBG_GetAprStatus(result.success, args.uiIndex);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_GetAprStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_GetAprStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_GetAprStatus");
  }

  oprot->writeMessageBegin("DBG_GetAprStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_GetAprStatus", bytes);
  }
}

void HalApiProcessor::process_DBG_SpiSendCommand(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_SpiSendCommand", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_SpiSendCommand");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_SpiSendCommand");
  }

  HalApi_DBG_SpiSendCommand_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_SpiSendCommand", bytes);
  }

  HalApi_DBG_SpiSendCommand_result result;
  try {
    iface_->DBG_SpiSendCommand(result.success, args.ulChip, args.pucBufW, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_SpiSendCommand");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_SpiSendCommand", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_SpiSendCommand");
  }

  oprot->writeMessageBegin("DBG_SpiSendCommand", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_SpiSendCommand", bytes);
  }
}

void HalApiProcessor::process_DBG_SpiFlashRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_SpiFlashRead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_SpiFlashRead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_SpiFlashRead");
  }

  HalApi_DBG_SpiFlashRead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_SpiFlashRead", bytes);
  }

  HalApi_DBG_SpiFlashRead_result result;
  try {
    iface_->DBG_SpiFlashRead(result.success, args.ulChip, args.ulAddr, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_SpiFlashRead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_SpiFlashRead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_SpiFlashRead");
  }

  oprot->writeMessageBegin("DBG_SpiFlashRead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_SpiFlashRead", bytes);
  }
}

void HalApiProcessor::process_DBG_SpiFlashWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_SpiFlashWrite", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_SpiFlashWrite");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_SpiFlashWrite");
  }

  HalApi_DBG_SpiFlashWrite_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_SpiFlashWrite", bytes);
  }

  HalApi_DBG_SpiFlashWrite_result result;
  try {
    result.success = iface_->DBG_SpiFlashWrite(args.ulChip, args.ulAddr, args.ulLen, args.pucVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_SpiFlashWrite");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_SpiFlashWrite", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_SpiFlashWrite");
  }

  oprot->writeMessageBegin("DBG_SpiFlashWrite", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_SpiFlashWrite", bytes);
  }
}

void HalApiProcessor::process_DBG_MdioRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_MdioRead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_MdioRead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_MdioRead");
  }

  HalApi_DBG_MdioRead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_MdioRead", bytes);
  }

  HalApi_DBG_MdioRead_result result;
  try {
    iface_->DBG_MdioRead(result.success, args.uiIdx, args.ulPhyAddr, args.ulRegAddr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_MdioRead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_MdioRead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_MdioRead");
  }

  oprot->writeMessageBegin("DBG_MdioRead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_MdioRead", bytes);
  }
}

void HalApiProcessor::process_DBG_MdioWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_MdioWrite", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_MdioWrite");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_MdioWrite");
  }

  HalApi_DBG_MdioWrite_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_MdioWrite", bytes);
  }

  HalApi_DBG_MdioWrite_result result;
  try {
    result.success = iface_->DBG_MdioWrite(args.uiIdx, args.ulPhyAddr, args.ulRegAddr, args.usData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_MdioWrite");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_MdioWrite", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_MdioWrite");
  }

  oprot->writeMessageBegin("DBG_MdioWrite", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_MdioWrite", bytes);
  }
}

void HalApiProcessor::process_DBG_NetSwitchRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_NetSwitchRead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_NetSwitchRead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_NetSwitchRead");
  }

  HalApi_DBG_NetSwitchRead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_NetSwitchRead", bytes);
  }

  HalApi_DBG_NetSwitchRead_result result;
  try {
    iface_->DBG_NetSwitchRead(result.success, args.ulPhyAddr, args.ulRegAddr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_NetSwitchRead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_NetSwitchRead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_NetSwitchRead");
  }

  oprot->writeMessageBegin("DBG_NetSwitchRead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_NetSwitchRead", bytes);
  }
}

void HalApiProcessor::process_DBG_NetSwitchWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_NetSwitchWrite", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_NetSwitchWrite");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_NetSwitchWrite");
  }

  HalApi_DBG_NetSwitchWrite_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_NetSwitchWrite", bytes);
  }

  HalApi_DBG_NetSwitchWrite_result result;
  try {
    result.success = iface_->DBG_NetSwitchWrite(args.ulPhyAddr, args.ulRegAddr, args.usData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_NetSwitchWrite");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_NetSwitchWrite", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_NetSwitchWrite");
  }

  oprot->writeMessageBegin("DBG_NetSwitchWrite", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_NetSwitchWrite", bytes);
  }
}

void HalApiProcessor::process_DBG_SwitchPhyRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_SwitchPhyRead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_SwitchPhyRead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_SwitchPhyRead");
  }

  HalApi_DBG_SwitchPhyRead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_SwitchPhyRead", bytes);
  }

  HalApi_DBG_SwitchPhyRead_result result;
  try {
    iface_->DBG_SwitchPhyRead(result.success, args.ulPhyAddr, args.ulRegAddr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_SwitchPhyRead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_SwitchPhyRead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_SwitchPhyRead");
  }

  oprot->writeMessageBegin("DBG_SwitchPhyRead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_SwitchPhyRead", bytes);
  }
}

void HalApiProcessor::process_DBG_SwitchPhyWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_SwitchPhyWrite", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_SwitchPhyWrite");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_SwitchPhyWrite");
  }

  HalApi_DBG_SwitchPhyWrite_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_SwitchPhyWrite", bytes);
  }

  HalApi_DBG_SwitchPhyWrite_result result;
  try {
    result.success = iface_->DBG_SwitchPhyWrite(args.ulPhyAddr, args.ulRegAddr, args.usData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_SwitchPhyWrite");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_SwitchPhyWrite", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_SwitchPhyWrite");
  }

  oprot->writeMessageBegin("DBG_SwitchPhyWrite", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_SwitchPhyWrite", bytes);
  }
}

void HalApiProcessor::process_DBG_ReadEeprom(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_ReadEeprom", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_ReadEeprom");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_ReadEeprom");
  }

  HalApi_DBG_ReadEeprom_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_ReadEeprom", bytes);
  }

  HalApi_DBG_ReadEeprom_result result;
  try {
    iface_->DBG_ReadEeprom(result.success, args.uiIdx, args.ulAddr, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_ReadEeprom");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_ReadEeprom", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_ReadEeprom");
  }

  oprot->writeMessageBegin("DBG_ReadEeprom", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_ReadEeprom", bytes);
  }
}

void HalApiProcessor::process_DBG_WriteEeprom(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.DBG_WriteEeprom", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.DBG_WriteEeprom");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.DBG_WriteEeprom");
  }

  HalApi_DBG_WriteEeprom_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.DBG_WriteEeprom", bytes);
  }

  HalApi_DBG_WriteEeprom_result result;
  try {
    result.success = iface_->DBG_WriteEeprom(args.uiIdx, args.ulAddr, args.ulLen, args.pucVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.DBG_WriteEeprom");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DBG_WriteEeprom", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.DBG_WriteEeprom");
  }

  oprot->writeMessageBegin("DBG_WriteEeprom", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.DBG_WriteEeprom", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetMfg");
  }

  HalApi_EDFA_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetMfg", bytes);
  }

  HalApi_EDFA_GetMfg_result result;
  try {
    iface_->EDFA_GetMfg(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetMfg");
  }

  oprot->writeMessageBegin("EDFA_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetMfg", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetStatusData");
  }

  HalApi_EDFA_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetStatusData", bytes);
  }

  HalApi_EDFA_GetStatusData_result result;
  try {
    iface_->EDFA_GetStatusData(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetStatusData");
  }

  oprot->writeMessageBegin("EDFA_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetCfgData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetCfgData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetCfgData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetCfgData");
  }

  HalApi_EDFA_GetCfgData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetCfgData", bytes);
  }

  HalApi_EDFA_GetCfgData_result result;
  try {
    iface_->EDFA_GetCfgData(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetCfgData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetCfgData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetCfgData");
  }

  oprot->writeMessageBegin("EDFA_GetCfgData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetCfgData", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetDebugInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetDebugInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetDebugInfo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetDebugInfo");
  }

  HalApi_EDFA_GetDebugInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetDebugInfo", bytes);
  }

  HalApi_EDFA_GetDebugInfo_result result;
  try {
    result.success = iface_->EDFA_GetDebugInfo(args.uiDevType, args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetDebugInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetDebugInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetDebugInfo");
  }

  oprot->writeMessageBegin("EDFA_GetDebugInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetDebugInfo", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetMcuDebugInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetMcuDebugInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetMcuDebugInfo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetMcuDebugInfo");
  }

  HalApi_EDFA_GetMcuDebugInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetMcuDebugInfo", bytes);
  }

  HalApi_EDFA_GetMcuDebugInfo_result result;
  try {
    result.success = iface_->EDFA_GetMcuDebugInfo(args.uiDevType, args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetMcuDebugInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetMcuDebugInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetMcuDebugInfo");
  }

  oprot->writeMessageBegin("EDFA_GetMcuDebugInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetMcuDebugInfo", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetGainRange(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetGainRange", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetGainRange");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetGainRange");
  }

  HalApi_EDFA_SetGainRange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetGainRange", bytes);
  }

  HalApi_EDFA_SetGainRange_result result;
  try {
    result.success = iface_->EDFA_SetGainRange(args.uiDevType, args.sGainRange);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetGainRange");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetGainRange", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetGainRange");
  }

  oprot->writeMessageBegin("EDFA_SetGainRange", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetGainRange", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetGain(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetGain", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetGain");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetGain");
  }

  HalApi_EDFA_SetGain_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetGain", bytes);
  }

  HalApi_EDFA_SetGain_result result;
  try {
    result.success = iface_->EDFA_SetGain(args.uiDevType, args.sGain);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetGain");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetGain", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetGain");
  }

  oprot->writeMessageBegin("EDFA_SetGain", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetGain", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetTilt(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetTilt", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetTilt");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetTilt");
  }

  HalApi_EDFA_SetTilt_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetTilt", bytes);
  }

  HalApi_EDFA_SetTilt_result result;
  try {
    result.success = iface_->EDFA_SetTilt(args.uiDevType, args.sTilt);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetTilt");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetTilt", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetTilt");
  }

  oprot->writeMessageBegin("EDFA_SetTilt", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetTilt", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetMode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetMode");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetMode");
  }

  HalApi_EDFA_SetMode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetMode", bytes);
  }

  HalApi_EDFA_SetMode_result result;
  try {
    result.success = iface_->EDFA_SetMode(args.uiDevType, args.ucMode, args.sVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetMode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetMode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetMode");
  }

  oprot->writeMessageBegin("EDFA_SetMode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetMode", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetPumpEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetPumpEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetPumpEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetPumpEnable");
  }

  HalApi_EDFA_SetPumpEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetPumpEnable", bytes);
  }

  HalApi_EDFA_SetPumpEnable_result result;
  try {
    result.success = iface_->EDFA_SetPumpEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetPumpEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetPumpEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetPumpEnable");
  }

  oprot->writeMessageBegin("EDFA_SetPumpEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetPumpEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetAprEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetAprEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetAprEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetAprEnable");
  }

  HalApi_EDFA_SetAprEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetAprEnable", bytes);
  }

  HalApi_EDFA_SetAprEnable_result result;
  try {
    result.success = iface_->EDFA_SetAprEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetAprEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetAprEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetAprEnable");
  }

  oprot->writeMessageBegin("EDFA_SetAprEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetAprEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetAutolosEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetAutolosEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetAutolosEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetAutolosEnable");
  }

  HalApi_EDFA_SetAutolosEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetAutolosEnable", bytes);
  }

  HalApi_EDFA_SetAutolosEnable_result result;
  try {
    result.success = iface_->EDFA_SetAutolosEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetAutolosEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetAutolosEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetAutolosEnable");
  }

  oprot->writeMessageBegin("EDFA_SetAutolosEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetAutolosEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetRxLosThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetRxLosThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetRxLosThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetRxLosThr");
  }

  HalApi_EDFA_SetRxLosThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetRxLosThr", bytes);
  }

  HalApi_EDFA_SetRxLosThr_result result;
  try {
    result.success = iface_->EDFA_SetRxLosThr(args.uiDevType, args.sThr, args.sHys);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetRxLosThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetRxLosThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetRxLosThr");
  }

  oprot->writeMessageBegin("EDFA_SetRxLosThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetRxLosThr", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetAttn(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetAttn", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetAttn");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetAttn");
  }

  HalApi_EDFA_SetAttn_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetAttn", bytes);
  }

  HalApi_EDFA_SetAttn_result result;
  try {
    result.success = iface_->EDFA_SetAttn(args.uiDevType, args.sAttn);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetAttn");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetAttn", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetAttn");
  }

  oprot->writeMessageBegin("EDFA_SetAttn", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetAttn", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetAttn(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetAttn", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetAttn");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetAttn");
  }

  HalApi_EDFA_GetAttn_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetAttn", bytes);
  }

  HalApi_EDFA_GetAttn_result result;
  try {
    iface_->EDFA_GetAttn(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetAttn");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetAttn", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetAttn");
  }

  oprot->writeMessageBegin("EDFA_GetAttn", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetAttn", bytes);
  }
}

void HalApiProcessor::process_EDFA_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_Reset");
  }

  HalApi_EDFA_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_Reset", bytes);
  }

  HalApi_EDFA_Reset_result result;
  try {
    result.success = iface_->EDFA_Reset(args.uiDevType, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_Reset");
  }

  oprot->writeMessageBegin("EDFA_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_Reset", bytes);
  }
}

void HalApiProcessor::process_EDFA_Upgrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_Upgrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_Upgrade");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_Upgrade");
  }

  HalApi_EDFA_Upgrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_Upgrade", bytes);
  }

  HalApi_EDFA_Upgrade_result result;
  try {
    result.success = iface_->EDFA_Upgrade(args.uiDevType, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_Upgrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_Upgrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_Upgrade");
  }

  oprot->writeMessageBegin("EDFA_Upgrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_Upgrade", bytes);
  }
}

void HalApiProcessor::process_EDFA_Swap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_Swap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_Swap");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_Swap");
  }

  HalApi_EDFA_Swap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_Swap", bytes);
  }

  HalApi_EDFA_Swap_result result;
  try {
    result.success = iface_->EDFA_Swap(args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_Swap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_Swap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_Swap");
  }

  oprot->writeMessageBegin("EDFA_Swap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_Swap", bytes);
  }
}

void HalApiProcessor::process_EDFA_Commit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_Commit", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_Commit");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_Commit");
  }

  HalApi_EDFA_Commit_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_Commit", bytes);
  }

  HalApi_EDFA_Commit_result result;
  try {
    result.success = iface_->EDFA_Commit(args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_Commit");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_Commit", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_Commit");
  }

  oprot->writeMessageBegin("EDFA_Commit", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_Commit", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetUpgadeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetUpgadeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetUpgadeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetUpgadeStatus");
  }

  HalApi_EDFA_GetUpgadeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetUpgadeStatus", bytes);
  }

  HalApi_EDFA_GetUpgadeStatus_result result;
  try {
    result.success = iface_->EDFA_GetUpgadeStatus(args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetUpgadeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetUpgadeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetUpgadeStatus");
  }

  oprot->writeMessageBegin("EDFA_GetUpgadeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetUpgadeStatus", bytes);
  }
}

void HalApiProcessor::process_EDFA_DbgRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_DbgRead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_DbgRead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_DbgRead");
  }

  HalApi_EDFA_DbgRead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_DbgRead", bytes);
  }

  HalApi_EDFA_DbgRead_result result;
  try {
    iface_->EDFA_DbgRead(result.success, args.uiDevType, args.uiLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_DbgRead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_DbgRead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_DbgRead");
  }

  oprot->writeMessageBegin("EDFA_DbgRead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_DbgRead", bytes);
  }
}

void HalApiProcessor::process_EDFA_DbgWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_DbgWrite", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_DbgWrite");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_DbgWrite");
  }

  HalApi_EDFA_DbgWrite_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_DbgWrite", bytes);
  }

  HalApi_EDFA_DbgWrite_result result;
  try {
    result.success = iface_->EDFA_DbgWrite(args.uiDevType, args.pucBuf, args.uiLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_DbgWrite");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_DbgWrite", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_DbgWrite");
  }

  oprot->writeMessageBegin("EDFA_DbgWrite", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_DbgWrite", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetDfbEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetDfbEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetDfbEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetDfbEnable");
  }

  HalApi_EDFA_SetDfbEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetDfbEnable", bytes);
  }

  HalApi_EDFA_SetDfbEnable_result result;
  try {
    result.success = iface_->EDFA_SetDfbEnable(args.uiDevType, args.bEnable, args.iPower);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetDfbEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetDfbEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetDfbEnable");
  }

  oprot->writeMessageBegin("EDFA_SetDfbEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetDfbEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetOscEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetOscEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetOscEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetOscEnable");
  }

  HalApi_EDFA_SetOscEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetOscEnable", bytes);
  }

  HalApi_EDFA_SetOscEnable_result result;
  try {
    result.success = iface_->EDFA_SetOscEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetOscEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetOscEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetOscEnable");
  }

  oprot->writeMessageBegin("EDFA_SetOscEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetOscEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetOtdrSwitchPos(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetOtdrSwitchPos", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetOtdrSwitchPos");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetOtdrSwitchPos");
  }

  HalApi_EDFA_SetOtdrSwitchPos_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetOtdrSwitchPos", bytes);
  }

  HalApi_EDFA_SetOtdrSwitchPos_result result;
  try {
    result.success = iface_->EDFA_SetOtdrSwitchPos(args.uiDevType, args.uiPos);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetOtdrSwitchPos");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetOtdrSwitchPos", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetOtdrSwitchPos");
  }

  oprot->writeMessageBegin("EDFA_SetOtdrSwitchPos", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetOtdrSwitchPos", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetOscAddThrHys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetOscAddThrHys", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetOscAddThrHys");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetOscAddThrHys");
  }

  HalApi_EDFA_SetOscAddThrHys_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetOscAddThrHys", bytes);
  }

  HalApi_EDFA_SetOscAddThrHys_result result;
  try {
    result.success = iface_->EDFA_SetOscAddThrHys(args.uiDevType, args.sThr, args.sHys);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetOscAddThrHys");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetOscAddThrHys", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetOscAddThrHys");
  }

  oprot->writeMessageBegin("EDFA_SetOscAddThrHys", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetOscAddThrHys", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetOscDropThrHys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetOscDropThrHys", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetOscDropThrHys");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetOscDropThrHys");
  }

  HalApi_EDFA_SetOscDropThrHys_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetOscDropThrHys", bytes);
  }

  HalApi_EDFA_SetOscDropThrHys_result result;
  try {
    result.success = iface_->EDFA_SetOscDropThrHys(args.uiDevType, args.sThr, args.sHys);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetOscDropThrHys");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetOscDropThrHys", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetOscDropThrHys");
  }

  oprot->writeMessageBegin("EDFA_SetOscDropThrHys", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetOscDropThrHys", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetOscRxThrHys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetOscRxThrHys", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetOscRxThrHys");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetOscRxThrHys");
  }

  HalApi_EDFA_SetOscRxThrHys_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetOscRxThrHys", bytes);
  }

  HalApi_EDFA_SetOscRxThrHys_result result;
  try {
    result.success = iface_->EDFA_SetOscRxThrHys(args.uiDevType, args.sThr, args.sHys);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetOscRxThrHys");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetOscRxThrHys", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetOscRxThrHys");
  }

  oprot->writeMessageBegin("EDFA_SetOscRxThrHys", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetOscRxThrHys", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetApsdEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetApsdEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetApsdEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetApsdEnable");
  }

  HalApi_EDFA_SetApsdEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetApsdEnable", bytes);
  }

  HalApi_EDFA_SetApsdEnable_result result;
  try {
    result.success = iface_->EDFA_SetApsdEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetApsdEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetApsdEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetApsdEnable");
  }

  oprot->writeMessageBegin("EDFA_SetApsdEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetApsdEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetApsdStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetApsdStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetApsdStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetApsdStatus");
  }

  HalApi_EDFA_GetApsdStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetApsdStatus", bytes);
  }

  HalApi_EDFA_GetApsdStatus_result result;
  try {
    iface_->EDFA_GetApsdStatus(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetApsdStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetApsdStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetApsdStatus");
  }

  oprot->writeMessageBegin("EDFA_GetApsdStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetApsdStatus", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetOcmAttn(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetOcmAttn", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetOcmAttn");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetOcmAttn");
  }

  HalApi_EDFA_GetOcmAttn_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetOcmAttn", bytes);
  }

  HalApi_EDFA_GetOcmAttn_result result;
  try {
    iface_->EDFA_GetOcmAttn(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetOcmAttn");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetOcmAttn", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetOcmAttn");
  }

  oprot->writeMessageBegin("EDFA_GetOcmAttn", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetOcmAttn", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetUpgState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetUpgState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetUpgState");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetUpgState");
  }

  HalApi_EDFA_SetUpgState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetUpgState", bytes);
  }

  HalApi_EDFA_SetUpgState_result result;
  try {
    result.success = iface_->EDFA_SetUpgState(args.uiDevType, args.sState);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetUpgState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetUpgState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetUpgState");
  }

  oprot->writeMessageBegin("EDFA_SetUpgState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetUpgState", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetLedState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetLedState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetLedState");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetLedState");
  }

  HalApi_EDFA_SetLedState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetLedState", bytes);
  }

  HalApi_EDFA_SetLedState_result result;
  try {
    result.success = iface_->EDFA_SetLedState(args.uiDevType, args.sState);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetLedState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetLedState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetLedState");
  }

  oprot->writeMessageBegin("EDFA_SetLedState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetLedState", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetLedAlm(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetLedAlm", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetLedAlm");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetLedAlm");
  }

  HalApi_EDFA_SetLedAlm_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetLedAlm", bytes);
  }

  HalApi_EDFA_SetLedAlm_result result;
  try {
    result.success = iface_->EDFA_SetLedAlm(args.uiDevType, args.sState);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetLedAlm");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetLedAlm", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetLedAlm");
  }

  oprot->writeMessageBegin("EDFA_SetLedAlm", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetLedAlm", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetCali");
  }

  HalApi_EDFA_GetCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetCali", bytes);
  }

  HalApi_EDFA_GetCali_result result;
  try {
    iface_->EDFA_GetCali(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetCali");
  }

  oprot->writeMessageBegin("EDFA_GetCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetCali", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetOtdrCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetOtdrCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetOtdrCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetOtdrCali");
  }

  HalApi_EDFA_SetOtdrCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetOtdrCali", bytes);
  }

  HalApi_EDFA_SetOtdrCali_result result;
  try {
    result.success = iface_->EDFA_SetOtdrCali(args.uiDevType, args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetOtdrCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetOtdrCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetOtdrCali");
  }

  oprot->writeMessageBegin("EDFA_SetOtdrCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetOtdrCali", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetOcmCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetOcmCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetOcmCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetOcmCali");
  }

  HalApi_EDFA_SetOcmCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetOcmCali", bytes);
  }

  HalApi_EDFA_SetOcmCali_result result;
  try {
    result.success = iface_->EDFA_SetOcmCali(args.uiDevType, args.pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetOcmCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetOcmCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetOcmCali");
  }

  oprot->writeMessageBegin("EDFA_SetOcmCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetOcmCali", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetManualVoaEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetManualVoaEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetManualVoaEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetManualVoaEnable");
  }

  HalApi_EDFA_SetManualVoaEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetManualVoaEnable", bytes);
  }

  HalApi_EDFA_SetManualVoaEnable_result result;
  try {
    result.success = iface_->EDFA_SetManualVoaEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetManualVoaEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetManualVoaEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetManualVoaEnable");
  }

  oprot->writeMessageBegin("EDFA_SetManualVoaEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetManualVoaEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetPaddingVoaConfigPower(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetPaddingVoaConfigPower", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetPaddingVoaConfigPower");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetPaddingVoaConfigPower");
  }

  HalApi_EDFA_SetPaddingVoaConfigPower_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetPaddingVoaConfigPower", bytes);
  }

  HalApi_EDFA_SetPaddingVoaConfigPower_result result;
  try {
    result.success = iface_->EDFA_SetPaddingVoaConfigPower(args.uiDevType, args.sOutPower);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetPaddingVoaConfigPower");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetPaddingVoaConfigPower", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetPaddingVoaConfigPower");
  }

  oprot->writeMessageBegin("EDFA_SetPaddingVoaConfigPower", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetPaddingVoaConfigPower", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetManualGainEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetManualGainEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetManualGainEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetManualGainEnable");
  }

  HalApi_EDFA_SetManualGainEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetManualGainEnable", bytes);
  }

  HalApi_EDFA_SetManualGainEnable_result result;
  try {
    result.success = iface_->EDFA_SetManualGainEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetManualGainEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetManualGainEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetManualGainEnable");
  }

  oprot->writeMessageBegin("EDFA_SetManualGainEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetManualGainEnable", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetThr");
  }

  HalApi_EDFA_SetThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetThr", bytes);
  }

  HalApi_EDFA_SetThr_result result;
  try {
    result.success = iface_->EDFA_SetThr(args.uiDevType, args.uiPortIdx, args.uiType, args.sThr, args.sHys);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetThr");
  }

  oprot->writeMessageBegin("EDFA_SetThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetThr", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetPumpCurrent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetPumpCurrent", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetPumpCurrent");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetPumpCurrent");
  }

  HalApi_EDFA_SetPumpCurrent_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetPumpCurrent", bytes);
  }

  HalApi_EDFA_SetPumpCurrent_result result;
  try {
    result.success = iface_->EDFA_SetPumpCurrent(args.uiDevType, args.uiPumpIdx, args.sCurrent);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetPumpCurrent");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetPumpCurrent", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetPumpCurrent");
  }

  oprot->writeMessageBegin("EDFA_SetPumpCurrent", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetPumpCurrent", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetAlmMask(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetAlmMask", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetAlmMask");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetAlmMask");
  }

  HalApi_EDFA_SetAlmMask_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetAlmMask", bytes);
  }

  HalApi_EDFA_SetAlmMask_result result;
  try {
    result.success = iface_->EDFA_SetAlmMask(args.uiDevType, args.iMaskIdx, args.iMaskVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetAlmMask");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetAlmMask", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetAlmMask");
  }

  oprot->writeMessageBegin("EDFA_SetAlmMask", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetAlmMask", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetEventLog(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetEventLog", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetEventLog");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetEventLog");
  }

  HalApi_EDFA_GetEventLog_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetEventLog", bytes);
  }

  HalApi_EDFA_GetEventLog_result result;
  try {
    iface_->EDFA_GetEventLog(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetEventLog");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetEventLog", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetEventLog");
  }

  oprot->writeMessageBegin("EDFA_GetEventLog", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetEventLog", bytes);
  }
}

void HalApiProcessor::process_EDFA_SetShutterState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_SetShutterState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_SetShutterState");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_SetShutterState");
  }

  HalApi_EDFA_SetShutterState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_SetShutterState", bytes);
  }

  HalApi_EDFA_SetShutterState_result result;
  try {
    result.success = iface_->EDFA_SetShutterState(args.uiDevType, args.block);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_SetShutterState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_SetShutterState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_SetShutterState");
  }

  oprot->writeMessageBegin("EDFA_SetShutterState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_SetShutterState", bytes);
  }
}

void HalApiProcessor::process_EDFA_GetShutterState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EDFA_GetShutterState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EDFA_GetShutterState");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EDFA_GetShutterState");
  }

  HalApi_EDFA_GetShutterState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EDFA_GetShutterState", bytes);
  }

  HalApi_EDFA_GetShutterState_result result;
  try {
    iface_->EDFA_GetShutterState(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EDFA_GetShutterState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EDFA_GetShutterState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EDFA_GetShutterState");
  }

  oprot->writeMessageBegin("EDFA_GetShutterState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EDFA_GetShutterState", bytes);
  }
}

void HalApiProcessor::process_EXTEND_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_GetMfg");
  }

  HalApi_EXTEND_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_GetMfg", bytes);
  }

  HalApi_EXTEND_GetMfg_result result;
  try {
    iface_->EXTEND_GetMfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_GetMfg");
  }

  oprot->writeMessageBegin("EXTEND_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_GetMfg", bytes);
  }
}

void HalApiProcessor::process_EXTEND_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_GetStatusData");
  }

  HalApi_EXTEND_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_GetStatusData", bytes);
  }

  HalApi_EXTEND_GetStatusData_result result;
  try {
    iface_->EXTEND_GetStatusData(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_GetStatusData");
  }

  oprot->writeMessageBegin("EXTEND_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_EXTEND_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_Reset");
  }

  HalApi_EXTEND_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_Reset", bytes);
  }

  HalApi_EXTEND_Reset_result result;
  try {
    result.success = iface_->EXTEND_Reset(args.uiDevIdx, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_Reset");
  }

  oprot->writeMessageBegin("EXTEND_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_Reset", bytes);
  }
}

void HalApiProcessor::process_EXTEND_Upgrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_Upgrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_Upgrade");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_Upgrade");
  }

  HalApi_EXTEND_Upgrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_Upgrade", bytes);
  }

  HalApi_EXTEND_Upgrade_result result;
  try {
    result.success = iface_->EXTEND_Upgrade(args.uiDevIdx, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_Upgrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_Upgrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_Upgrade");
  }

  oprot->writeMessageBegin("EXTEND_Upgrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_Upgrade", bytes);
  }
}

void HalApiProcessor::process_EXTEND_GetUpgadeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_GetUpgadeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_GetUpgadeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_GetUpgadeStatus");
  }

  HalApi_EXTEND_GetUpgadeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_GetUpgadeStatus", bytes);
  }

  HalApi_EXTEND_GetUpgadeStatus_result result;
  try {
    result.success = iface_->EXTEND_GetUpgadeStatus(args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_GetUpgadeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_GetUpgadeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_GetUpgadeStatus");
  }

  oprot->writeMessageBegin("EXTEND_GetUpgadeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_GetUpgadeStatus", bytes);
  }
}

void HalApiProcessor::process_EXTEND_DbgRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_DbgRead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_DbgRead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_DbgRead");
  }

  HalApi_EXTEND_DbgRead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_DbgRead", bytes);
  }

  HalApi_EXTEND_DbgRead_result result;
  try {
    iface_->EXTEND_DbgRead(result.success, args.uiDevIdx, args.uiLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_DbgRead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_DbgRead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_DbgRead");
  }

  oprot->writeMessageBegin("EXTEND_DbgRead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_DbgRead", bytes);
  }
}

void HalApiProcessor::process_EXTEND_DbgWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_DbgWrite", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_DbgWrite");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_DbgWrite");
  }

  HalApi_EXTEND_DbgWrite_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_DbgWrite", bytes);
  }

  HalApi_EXTEND_DbgWrite_result result;
  try {
    result.success = iface_->EXTEND_DbgWrite(args.uiDevIdx, args.pucBuf, args.uiLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_DbgWrite");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_DbgWrite", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_DbgWrite");
  }

  oprot->writeMessageBegin("EXTEND_DbgWrite", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_DbgWrite", bytes);
  }
}

void HalApiProcessor::process_EXTEND_SetSfp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.EXTEND_SetSfp", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.EXTEND_SetSfp");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.EXTEND_SetSfp");
  }

  HalApi_EXTEND_SetSfp_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.EXTEND_SetSfp", bytes);
  }

  HalApi_EXTEND_SetSfp_result result;
  try {
    result.success = iface_->EXTEND_SetSfp(args.uiDevIdx, args.ulVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.EXTEND_SetSfp");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("EXTEND_SetSfp", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.EXTEND_SetSfp");
  }

  oprot->writeMessageBegin("EXTEND_SetSfp", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.EXTEND_SetSfp", bytes);
  }
}

void HalApiProcessor::process_MIRROR_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.MIRROR_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.MIRROR_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.MIRROR_GetStatusData");
  }

  HalApi_MIRROR_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.MIRROR_GetStatusData", bytes);
  }

  HalApi_MIRROR_GetStatusData_result result;
  try {
    iface_->MIRROR_GetStatusData(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.MIRROR_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MIRROR_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.MIRROR_GetStatusData");
  }

  oprot->writeMessageBegin("MIRROR_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.MIRROR_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_SWITCH_Pos(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SWITCH_Pos", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SWITCH_Pos");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SWITCH_Pos");
  }

  HalApi_SWITCH_Pos_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SWITCH_Pos", bytes);
  }

  HalApi_SWITCH_Pos_result result;
  try {
    result.success = iface_->SWITCH_Pos(args.uiDevIdx, args.uiPort);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SWITCH_Pos");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SWITCH_Pos", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SWITCH_Pos");
  }

  oprot->writeMessageBegin("SWITCH_Pos", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SWITCH_Pos", bytes);
  }
}

void HalApiProcessor::process_MUX_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.MUX_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.MUX_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.MUX_GetMfg");
  }

  HalApi_MUX_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.MUX_GetMfg", bytes);
  }

  HalApi_MUX_GetMfg_result result;
  try {
    iface_->MUX_GetMfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.MUX_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MUX_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.MUX_GetMfg");
  }

  oprot->writeMessageBegin("MUX_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.MUX_GetMfg", bytes);
  }
}

void HalApiProcessor::process_MUX_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.MUX_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.MUX_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.MUX_GetStatusData");
  }

  HalApi_MUX_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.MUX_GetStatusData", bytes);
  }

  HalApi_MUX_GetStatusData_result result;
  try {
    iface_->MUX_GetStatusData(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.MUX_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MUX_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.MUX_GetStatusData");
  }

  oprot->writeMessageBegin("MUX_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.MUX_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_MUX_GetCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.MUX_GetCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.MUX_GetCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.MUX_GetCali");
  }

  HalApi_MUX_GetCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.MUX_GetCali", bytes);
  }

  HalApi_MUX_GetCali_result result;
  try {
    iface_->MUX_GetCali(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.MUX_GetCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MUX_GetCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.MUX_GetCali");
  }

  oprot->writeMessageBegin("MUX_GetCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.MUX_GetCali", bytes);
  }
}

void HalApiProcessor::process_OCM_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetMfg");
  }

  HalApi_OCM_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetMfg", bytes);
  }

  HalApi_OCM_GetMfg_result result;
  try {
    iface_->OCM_GetMfg(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetMfg");
  }

  oprot->writeMessageBegin("OCM_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetMfg", bytes);
  }
}

void HalApiProcessor::process_OCM_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetStatusData");
  }

  HalApi_OCM_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetStatusData", bytes);
  }

  HalApi_OCM_GetStatusData_result result;
  try {
    iface_->OCM_GetStatusData(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetStatusData");
  }

  oprot->writeMessageBegin("OCM_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_OCM_GetChPower(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetChPower", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetChPower");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetChPower");
  }

  HalApi_OCM_GetChPower_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetChPower", bytes);
  }

  HalApi_OCM_GetChPower_result result;
  try {
    iface_->OCM_GetChPower(result.success, args.uiDevType, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetChPower");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetChPower", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetChPower");
  }

  oprot->writeMessageBegin("OCM_GetChPower", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetChPower", bytes);
  }
}

void HalApiProcessor::process_OCM_GetOsaData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetOsaData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetOsaData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetOsaData");
  }

  HalApi_OCM_GetOsaData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetOsaData", bytes);
  }

  HalApi_OCM_GetOsaData_result result;
  try {
    iface_->OCM_GetOsaData(result.success, args.uiDevType, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetOsaData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetOsaData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetOsaData");
  }

  oprot->writeMessageBegin("OCM_GetOsaData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetOsaData", bytes);
  }
}

void HalApiProcessor::process_OCM_GetRealTimeOsaData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetRealTimeOsaData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetRealTimeOsaData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetRealTimeOsaData");
  }

  HalApi_OCM_GetRealTimeOsaData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetRealTimeOsaData", bytes);
  }

  HalApi_OCM_GetRealTimeOsaData_result result;
  try {
    iface_->OCM_GetRealTimeOsaData(result.success, args.uiDevType, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetRealTimeOsaData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetRealTimeOsaData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetRealTimeOsaData");
  }

  oprot->writeMessageBegin("OCM_GetRealTimeOsaData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetRealTimeOsaData", bytes);
  }
}

void HalApiProcessor::process_OCM_SetWaveplan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_SetWaveplan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_SetWaveplan");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_SetWaveplan");
  }

  HalApi_OCM_SetWaveplan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_SetWaveplan", bytes);
  }

  HalApi_OCM_SetWaveplan_result result;
  try {
    result.success = iface_->OCM_SetWaveplan(args.uiDevType, args.uiPortId, args.uiChCnt, args.pstWavePlan);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_SetWaveplan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_SetWaveplan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_SetWaveplan");
  }

  oprot->writeMessageBegin("OCM_SetWaveplan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_SetWaveplan", bytes);
  }
}

void HalApiProcessor::process_OCM_SetOcmWaveplan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_SetOcmWaveplan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_SetOcmWaveplan");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_SetOcmWaveplan");
  }

  HalApi_OCM_SetOcmWaveplan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_SetOcmWaveplan", bytes);
  }

  HalApi_OCM_SetOcmWaveplan_result result;
  try {
    result.success = iface_->OCM_SetOcmWaveplan(args.uiDevType, args.uiPortId, args.uiChCnt, args.pstWavePlan);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_SetOcmWaveplan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_SetOcmWaveplan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_SetOcmWaveplan");
  }

  oprot->writeMessageBegin("OCM_SetOcmWaveplan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_SetOcmWaveplan", bytes);
  }
}

void HalApiProcessor::process_OCM_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_Reset");
  }

  HalApi_OCM_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_Reset", bytes);
  }

  HalApi_OCM_Reset_result result;
  try {
    result.success = iface_->OCM_Reset(args.uiDevType, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_Reset");
  }

  oprot->writeMessageBegin("OCM_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_Reset", bytes);
  }
}

void HalApiProcessor::process_OCM_Upgrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_Upgrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_Upgrade");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_Upgrade");
  }

  HalApi_OCM_Upgrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_Upgrade", bytes);
  }

  HalApi_OCM_Upgrade_result result;
  try {
    result.success = iface_->OCM_Upgrade(args.uiDevType, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_Upgrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_Upgrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_Upgrade");
  }

  oprot->writeMessageBegin("OCM_Upgrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_Upgrade", bytes);
  }
}

void HalApiProcessor::process_OCM_Commit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_Commit", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_Commit");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_Commit");
  }

  HalApi_OCM_Commit_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_Commit", bytes);
  }

  HalApi_OCM_Commit_result result;
  try {
    result.success = iface_->OCM_Commit(args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_Commit");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_Commit", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_Commit");
  }

  oprot->writeMessageBegin("OCM_Commit", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_Commit", bytes);
  }
}

void HalApiProcessor::process_OCM_GetUpgradeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetUpgradeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetUpgradeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetUpgradeStatus");
  }

  HalApi_OCM_GetUpgradeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetUpgradeStatus", bytes);
  }

  HalApi_OCM_GetUpgradeStatus_result result;
  try {
    result.success = iface_->OCM_GetUpgradeStatus(args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetUpgradeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetUpgradeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetUpgradeStatus");
  }

  oprot->writeMessageBegin("OCM_GetUpgradeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetUpgradeStatus", bytes);
  }
}

void HalApiProcessor::process_OCM_SetVoa(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_SetVoa", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_SetVoa");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_SetVoa");
  }

  HalApi_OCM_SetVoa_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_SetVoa", bytes);
  }

  HalApi_OCM_SetVoa_result result;
  try {
    result.success = iface_->OCM_SetVoa(args.uiDevType, args.sAttn);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_SetVoa");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_SetVoa", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_SetVoa");
  }

  oprot->writeMessageBegin("OCM_SetVoa", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_SetVoa", bytes);
  }
}

void HalApiProcessor::process_OCM_GetVoa(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetVoa", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetVoa");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetVoa");
  }

  HalApi_OCM_GetVoa_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetVoa", bytes);
  }

  HalApi_OCM_GetVoa_result result;
  try {
    iface_->OCM_GetVoa(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetVoa");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetVoa", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetVoa");
  }

  oprot->writeMessageBegin("OCM_GetVoa", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetVoa", bytes);
  }
}

void HalApiProcessor::process_OCM_GetVoaPd(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCM_GetVoaPd", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCM_GetVoaPd");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCM_GetVoaPd");
  }

  HalApi_OCM_GetVoaPd_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCM_GetVoaPd", bytes);
  }

  HalApi_OCM_GetVoaPd_result result;
  try {
    iface_->OCM_GetVoaPd(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCM_GetVoaPd");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCM_GetVoaPd", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCM_GetVoaPd");
  }

  oprot->writeMessageBegin("OCM_GetVoaPd", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCM_GetVoaPd", bytes);
  }
}

void HalApiProcessor::process_OCS_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_GetMfg");
  }

  HalApi_OCS_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_GetMfg", bytes);
  }

  HalApi_OCS_GetMfg_result result;
  try {
    iface_->OCS_GetMfg(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_GetMfg");
  }

  oprot->writeMessageBegin("OCS_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_GetMfg", bytes);
  }
}

void HalApiProcessor::process_OCS_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_GetStatusData");
  }

  HalApi_OCS_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_GetStatusData", bytes);
  }

  HalApi_OCS_GetStatusData_result result;
  try {
    iface_->OCS_GetStatusData(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_GetStatusData");
  }

  oprot->writeMessageBegin("OCS_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_OCS_SetConnection(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_SetConnection", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_SetConnection");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_SetConnection");
  }

  HalApi_OCS_SetConnection_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_SetConnection", bytes);
  }

  HalApi_OCS_SetConnection_result result;
  try {
    result.success = iface_->OCS_SetConnection(args.uiDevType, args.pstConnection);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_SetConnection");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_SetConnection", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_SetConnection");
  }

  oprot->writeMessageBegin("OCS_SetConnection", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_SetConnection", bytes);
  }
}

void HalApiProcessor::process_OCS_SetConnections(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_SetConnections", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_SetConnections");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_SetConnections");
  }

  HalApi_OCS_SetConnections_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_SetConnections", bytes);
  }

  HalApi_OCS_SetConnections_result result;
  try {
    result.success = iface_->OCS_SetConnections(args.uiDevType, args.pstConnections);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_SetConnections");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_SetConnections", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_SetConnections");
  }

  oprot->writeMessageBegin("OCS_SetConnections", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_SetConnections", bytes);
  }
}

void HalApiProcessor::process_OCS_SetLedState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_SetLedState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_SetLedState");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_SetLedState");
  }

  HalApi_OCS_SetLedState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_SetLedState", bytes);
  }

  HalApi_OCS_SetLedState_result result;
  try {
    result.success = iface_->OCS_SetLedState(args.uiDevType, args.index, args.uiState);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_SetLedState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_SetLedState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_SetLedState");
  }

  oprot->writeMessageBegin("OCS_SetLedState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_SetLedState", bytes);
  }
}

void HalApiProcessor::process_OCS_SetLedMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_SetLedMode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_SetLedMode");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_SetLedMode");
  }

  HalApi_OCS_SetLedMode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_SetLedMode", bytes);
  }

  HalApi_OCS_SetLedMode_result result;
  try {
    result.success = iface_->OCS_SetLedMode(args.uiDevType, args.uiMode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_SetLedMode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_SetLedMode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_SetLedMode");
  }

  oprot->writeMessageBegin("OCS_SetLedMode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_SetLedMode", bytes);
  }
}

void HalApiProcessor::process_OCS_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_Reset");
  }

  HalApi_OCS_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_Reset", bytes);
  }

  HalApi_OCS_Reset_result result;
  try {
    result.success = iface_->OCS_Reset(args.uiDevType, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_Reset");
  }

  oprot->writeMessageBegin("OCS_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_Reset", bytes);
  }
}

void HalApiProcessor::process_OCS_Upgrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_Upgrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_Upgrade");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_Upgrade");
  }

  HalApi_OCS_Upgrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_Upgrade", bytes);
  }

  HalApi_OCS_Upgrade_result result;
  try {
    result.success = iface_->OCS_Upgrade(args.uiDevType, args.pcPath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_Upgrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_Upgrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_Upgrade");
  }

  oprot->writeMessageBegin("OCS_Upgrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_Upgrade", bytes);
  }
}

void HalApiProcessor::process_OCS_GetUpgradeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OCS_GetUpgradeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OCS_GetUpgradeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OCS_GetUpgradeStatus");
  }

  HalApi_OCS_GetUpgradeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OCS_GetUpgradeStatus", bytes);
  }

  HalApi_OCS_GetUpgradeStatus_result result;
  try {
    result.success = iface_->OCS_GetUpgradeStatus(args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OCS_GetUpgradeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OCS_GetUpgradeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OCS_GetUpgradeStatus");
  }

  oprot->writeMessageBegin("OCS_GetUpgradeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OCS_GetUpgradeStatus", bytes);
  }
}

void HalApiProcessor::process_OPS_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetMfg");
  }

  HalApi_OPS_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetMfg", bytes);
  }

  HalApi_OPS_GetMfg_result result;
  try {
    iface_->OPS_GetMfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetMfg");
  }

  oprot->writeMessageBegin("OPS_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetMfg", bytes);
  }
}

void HalApiProcessor::process_OPS_GetCommStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetCommStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetCommStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetCommStatusData");
  }

  HalApi_OPS_GetCommStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetCommStatusData", bytes);
  }

  HalApi_OPS_GetCommStatusData_result result;
  try {
    iface_->OPS_GetCommStatusData(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetCommStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetCommStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetCommStatusData");
  }

  oprot->writeMessageBegin("OPS_GetCommStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetCommStatusData", bytes);
  }
}

void HalApiProcessor::process_OPS_GetCfgData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetCfgData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetCfgData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetCfgData");
  }

  HalApi_OPS_GetCfgData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetCfgData", bytes);
  }

  HalApi_OPS_GetCfgData_result result;
  try {
    iface_->OPS_GetCfgData(result.success, args.uiDevIdx, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetCfgData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetCfgData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetCfgData");
  }

  oprot->writeMessageBegin("OPS_GetCfgData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetCfgData", bytes);
  }
}

void HalApiProcessor::process_OPS_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetStatusData");
  }

  HalApi_OPS_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetStatusData", bytes);
  }

  HalApi_OPS_GetStatusData_result result;
  try {
    iface_->OPS_GetStatusData(result.success, args.uiDevIdx, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetStatusData");
  }

  oprot->writeMessageBegin("OPS_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_OPS_GetHistoryData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetHistoryData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetHistoryData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetHistoryData");
  }

  HalApi_OPS_GetHistoryData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetHistoryData", bytes);
  }

  HalApi_OPS_GetHistoryData_result result;
  try {
    iface_->OPS_GetHistoryData(result.success, args.uiDevIdx, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetHistoryData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetHistoryData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetHistoryData");
  }

  oprot->writeMessageBegin("OPS_GetHistoryData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetHistoryData", bytes);
  }
}

void HalApiProcessor::process_OPS_GetLedStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetLedStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetLedStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetLedStatus");
  }

  HalApi_OPS_GetLedStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetLedStatus", bytes);
  }

  HalApi_OPS_GetLedStatus_result result;
  try {
    iface_->OPS_GetLedStatus(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetLedStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetLedStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetLedStatus");
  }

  oprot->writeMessageBegin("OPS_GetLedStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetLedStatus", bytes);
  }
}

void HalApiProcessor::process_OPS_ClearAlarmDuration(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_ClearAlarmDuration", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_ClearAlarmDuration");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_ClearAlarmDuration");
  }

  HalApi_OPS_ClearAlarmDuration_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_ClearAlarmDuration", bytes);
  }

  HalApi_OPS_ClearAlarmDuration_result result;
  try {
    result.success = iface_->OPS_ClearAlarmDuration(args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_ClearAlarmDuration");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_ClearAlarmDuration", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_ClearAlarmDuration");
  }

  oprot->writeMessageBegin("OPS_ClearAlarmDuration", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_ClearAlarmDuration", bytes);
  }
}

void HalApiProcessor::process_OPS_SetThrPwrDiff(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetThrPwrDiff", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetThrPwrDiff");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetThrPwrDiff");
  }

  HalApi_OPS_SetThrPwrDiff_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetThrPwrDiff", bytes);
  }

  HalApi_OPS_SetThrPwrDiff_result result;
  try {
    result.success = iface_->OPS_SetThrPwrDiff(args.uiDevIdx, args.sThr, args.sHys, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetThrPwrDiff");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetThrPwrDiff", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetThrPwrDiff");
  }

  oprot->writeMessageBegin("OPS_SetThrPwrDiff", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetThrPwrDiff", bytes);
  }
}

void HalApiProcessor::process_OPS_SetThrLine(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetThrLine", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetThrLine");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetThrLine");
  }

  HalApi_OPS_SetThrLine_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetThrLine", bytes);
  }

  HalApi_OPS_SetThrLine_result result;
  try {
    result.success = iface_->OPS_SetThrLine(args.uiDevIdx, args.uiPortIdx, args.sThr, args.sHys, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetThrLine");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetThrLine", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetThrLine");
  }

  oprot->writeMessageBegin("OPS_SetThrLine", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetThrLine", bytes);
  }
}

void HalApiProcessor::process_OPS_SetPortPowerThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetPortPowerThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetPortPowerThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetPortPowerThr");
  }

  HalApi_OPS_SetPortPowerThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetPortPowerThr", bytes);
  }

  HalApi_OPS_SetPortPowerThr_result result;
  try {
    result.success = iface_->OPS_SetPortPowerThr(args.uiDevIdx, args.uiPortIdx, args.uiType, args.sThr, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetPortPowerThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetPortPowerThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetPortPowerThr");
  }

  oprot->writeMessageBegin("OPS_SetPortPowerThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetPortPowerThr", bytes);
  }
}

void HalApiProcessor::process_OPS_SetPortPowerHys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetPortPowerHys", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetPortPowerHys");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetPortPowerHys");
  }

  HalApi_OPS_SetPortPowerHys_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetPortPowerHys", bytes);
  }

  HalApi_OPS_SetPortPowerHys_result result;
  try {
    result.success = iface_->OPS_SetPortPowerHys(args.uiDevIdx, args.uiPortIdx, args.uiType, args.sHys, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetPortPowerHys");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetPortPowerHys", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetPortPowerHys");
  }

  oprot->writeMessageBegin("OPS_SetPortPowerHys", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetPortPowerHys", bytes);
  }
}

void HalApiProcessor::process_OPS_SetWtr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetWtr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetWtr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetWtr");
  }

  HalApi_OPS_SetWtr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetWtr", bytes);
  }

  HalApi_OPS_SetWtr_result result;
  try {
    result.success = iface_->OPS_SetWtr(args.uiDevIdx, args.uiWtr, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetWtr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetWtr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetWtr");
  }

  oprot->writeMessageBegin("OPS_SetWtr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetWtr", bytes);
  }
}

void HalApiProcessor::process_OPS_SetHoldOffTime(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetHoldOffTime", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetHoldOffTime");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetHoldOffTime");
  }

  HalApi_OPS_SetHoldOffTime_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetHoldOffTime", bytes);
  }

  HalApi_OPS_SetHoldOffTime_result result;
  try {
    result.success = iface_->OPS_SetHoldOffTime(args.uiDevIdx, args.uiHoldOffTime, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetHoldOffTime");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetHoldOffTime", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetHoldOffTime");
  }

  oprot->writeMessageBegin("OPS_SetHoldOffTime", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetHoldOffTime", bytes);
  }
}

void HalApiProcessor::process_OPS_SetRevertive(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetRevertive", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetRevertive");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetRevertive");
  }

  HalApi_OPS_SetRevertive_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetRevertive", bytes);
  }

  HalApi_OPS_SetRevertive_result result;
  try {
    result.success = iface_->OPS_SetRevertive(args.uiDevIdx, args.bRevertive, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetRevertive");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetRevertive", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetRevertive");
  }

  oprot->writeMessageBegin("OPS_SetRevertive", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetRevertive", bytes);
  }
}

void HalApiProcessor::process_OPS_SetMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetMode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetMode");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetMode");
  }

  HalApi_OPS_SetMode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetMode", bytes);
  }

  HalApi_OPS_SetMode_result result;
  try {
    result.success = iface_->OPS_SetMode(args.uiDevIdx, args.uiMode, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetMode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetMode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetMode");
  }

  oprot->writeMessageBegin("OPS_SetMode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetMode", bytes);
  }
}

void HalApiProcessor::process_OPS_SetRelativeThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetRelativeThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetRelativeThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetRelativeThr");
  }

  HalApi_OPS_SetRelativeThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetRelativeThr", bytes);
  }

  HalApi_OPS_SetRelativeThr_result result;
  try {
    result.success = iface_->OPS_SetRelativeThr(args.uiDevIdx, args.sThr, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetRelativeThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetRelativeThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetRelativeThr");
  }

  oprot->writeMessageBegin("OPS_SetRelativeThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetRelativeThr", bytes);
  }
}

void HalApiProcessor::process_OPS_SetRelativeOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetRelativeOffset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetRelativeOffset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetRelativeOffset");
  }

  HalApi_OPS_SetRelativeOffset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetRelativeOffset", bytes);
  }

  HalApi_OPS_SetRelativeOffset_result result;
  try {
    result.success = iface_->OPS_SetRelativeOffset(args.uiDevIdx, args.sOffset, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetRelativeOffset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetRelativeOffset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetRelativeOffset");
  }

  oprot->writeMessageBegin("OPS_SetRelativeOffset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetRelativeOffset", bytes);
  }
}

void HalApiProcessor::process_OPS_SetSwitchThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetSwitchThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetSwitchThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetSwitchThr");
  }

  HalApi_OPS_SetSwitchThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetSwitchThr", bytes);
  }

  HalApi_OPS_SetSwitchThr_result result;
  try {
    result.success = iface_->OPS_SetSwitchThr(args.uiDevIdx, args.uiPos, args.iThr, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetSwitchThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetSwitchThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetSwitchThr");
  }

  oprot->writeMessageBegin("OPS_SetSwitchThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetSwitchThr", bytes);
  }
}

void HalApiProcessor::process_OPS_SetSwitchHys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetSwitchHys", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetSwitchHys");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetSwitchHys");
  }

  HalApi_OPS_SetSwitchHys_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetSwitchHys", bytes);
  }

  HalApi_OPS_SetSwitchHys_result result;
  try {
    result.success = iface_->OPS_SetSwitchHys(args.uiDevIdx, args.uiPos, args.iHys, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetSwitchHys");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetSwitchHys", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetSwitchHys");
  }

  oprot->writeMessageBegin("OPS_SetSwitchHys", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetSwitchHys", bytes);
  }
}

void HalApiProcessor::process_OPS_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_Reset");
  }

  HalApi_OPS_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_Reset", bytes);
  }

  HalApi_OPS_Reset_result result;
  try {
    result.success = iface_->OPS_Reset(args.uiDevIdx, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_Reset");
  }

  oprot->writeMessageBegin("OPS_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_Reset", bytes);
  }
}

void HalApiProcessor::process_OPS_Upgrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_Upgrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_Upgrade");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_Upgrade");
  }

  HalApi_OPS_Upgrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_Upgrade", bytes);
  }

  HalApi_OPS_Upgrade_result result;
  try {
    result.success = iface_->OPS_Upgrade(args.uiDevIdx, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_Upgrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_Upgrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_Upgrade");
  }

  oprot->writeMessageBegin("OPS_Upgrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_Upgrade", bytes);
  }
}

void HalApiProcessor::process_OPS_GetUpgadeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetUpgadeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetUpgadeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetUpgadeStatus");
  }

  HalApi_OPS_GetUpgadeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetUpgadeStatus", bytes);
  }

  HalApi_OPS_GetUpgadeStatus_result result;
  try {
    result.success = iface_->OPS_GetUpgadeStatus(args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetUpgadeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetUpgadeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetUpgadeStatus");
  }

  oprot->writeMessageBegin("OPS_GetUpgadeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetUpgadeStatus", bytes);
  }
}

void HalApiProcessor::process_OPS_SetLedDebugMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetLedDebugMode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetLedDebugMode");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetLedDebugMode");
  }

  HalApi_OPS_SetLedDebugMode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetLedDebugMode", bytes);
  }

  HalApi_OPS_SetLedDebugMode_result result;
  try {
    result.success = iface_->OPS_SetLedDebugMode(args.uiDevIdx, args.uiMode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetLedDebugMode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetLedDebugMode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetLedDebugMode");
  }

  oprot->writeMessageBegin("OPS_SetLedDebugMode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetLedDebugMode", bytes);
  }
}

void HalApiProcessor::process_OPS_SetLedStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetLedStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetLedStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetLedStatus");
  }

  HalApi_OPS_SetLedStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetLedStatus", bytes);
  }

  HalApi_OPS_SetLedStatus_result result;
  try {
    result.success = iface_->OPS_SetLedStatus(args.uiDevIdx, args.uiLedIdx, args.uiStatus);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetLedStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetLedStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetLedStatus");
  }

  oprot->writeMessageBegin("OPS_SetLedStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetLedStatus", bytes);
  }
}

void HalApiProcessor::process_OPS_SetConnectionPdThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetConnectionPdThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetConnectionPdThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetConnectionPdThr");
  }

  HalApi_OPS_SetConnectionPdThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetConnectionPdThr", bytes);
  }

  HalApi_OPS_SetConnectionPdThr_result result;
  try {
    result.success = iface_->OPS_SetConnectionPdThr(args.uiDevIdx, args.uiPdIdx, args.uiType, args.sThr, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetConnectionPdThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetConnectionPdThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetConnectionPdThr");
  }

  oprot->writeMessageBegin("OPS_SetConnectionPdThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetConnectionPdThr", bytes);
  }
}

void HalApiProcessor::process_OPS_SetConnectionPdHys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetConnectionPdHys", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetConnectionPdHys");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetConnectionPdHys");
  }

  HalApi_OPS_SetConnectionPdHys_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetConnectionPdHys", bytes);
  }

  HalApi_OPS_SetConnectionPdHys_result result;
  try {
    result.success = iface_->OPS_SetConnectionPdHys(args.uiDevIdx, args.uiPdIdx, args.uiType, args.sHys, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetConnectionPdHys");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetConnectionPdHys", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetConnectionPdHys");
  }

  oprot->writeMessageBegin("OPS_SetConnectionPdHys", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetConnectionPdHys", bytes);
  }
}

void HalApiProcessor::process_OPS_SetAlmMask(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetAlmMask", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetAlmMask");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetAlmMask");
  }

  HalApi_OPS_SetAlmMask_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetAlmMask", bytes);
  }

  HalApi_OPS_SetAlmMask_result result;
  try {
    result.success = iface_->OPS_SetAlmMask(args.uiDevType, args.iMaskIdx, args.iMaskVal, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetAlmMask");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetAlmMask", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetAlmMask");
  }

  oprot->writeMessageBegin("OPS_SetAlmMask", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetAlmMask", bytes);
  }
}

void HalApiProcessor::process_OPS_GetEventLog(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetEventLog", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetEventLog");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetEventLog");
  }

  HalApi_OPS_GetEventLog_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetEventLog", bytes);
  }

  HalApi_OPS_GetEventLog_result result;
  try {
    iface_->OPS_GetEventLog(result.success, args.uiDevType, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetEventLog");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetEventLog", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetEventLog");
  }

  oprot->writeMessageBegin("OPS_GetEventLog", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetEventLog", bytes);
  }
}

void HalApiProcessor::process_OPS_SetRemoteStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetRemoteStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetRemoteStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetRemoteStatus");
  }

  HalApi_OPS_SetRemoteStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetRemoteStatus", bytes);
  }

  HalApi_OPS_SetRemoteStatus_result result;
  try {
    result.success = iface_->OPS_SetRemoteStatus(args.uiDevIdx, args.pstStatus, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetRemoteStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetRemoteStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetRemoteStatus");
  }

  oprot->writeMessageBegin("OPS_SetRemoteStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetRemoteStatus", bytes);
  }
}

void HalApiProcessor::process_OPS_GetRequestStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetRequestStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetRequestStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetRequestStatus");
  }

  HalApi_OPS_GetRequestStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetRequestStatus", bytes);
  }

  HalApi_OPS_GetRequestStatus_result result;
  try {
    iface_->OPS_GetRequestStatus(result.success, args.uiDevIdx, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetRequestStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetRequestStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetRequestStatus");
  }

  oprot->writeMessageBegin("OPS_GetRequestStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetRequestStatus", bytes);
  }
}

void HalApiProcessor::process_OPS_SetSwitchingType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_SetSwitchingType", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_SetSwitchingType");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_SetSwitchingType");
  }

  HalApi_OPS_SetSwitchingType_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_SetSwitchingType", bytes);
  }

  HalApi_OPS_SetSwitchingType_result result;
  try {
    result.success = iface_->OPS_SetSwitchingType(args.uiDevIdx, args.ucType, args.uiPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_SetSwitchingType");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_SetSwitchingType", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_SetSwitchingType");
  }

  oprot->writeMessageBegin("OPS_SetSwitchingType", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_SetSwitchingType", bytes);
  }
}

void HalApiProcessor::process_OPS_GetOpsDevIdByKey(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OPS_GetOpsDevIdByKey", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OPS_GetOpsDevIdByKey");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OPS_GetOpsDevIdByKey");
  }

  HalApi_OPS_GetOpsDevIdByKey_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OPS_GetOpsDevIdByKey", bytes);
  }

  HalApi_OPS_GetOpsDevIdByKey_result result;
  try {
    iface_->OPS_GetOpsDevIdByKey(result.success, args.pcName);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OPS_GetOpsDevIdByKey");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OPS_GetOpsDevIdByKey", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OPS_GetOpsDevIdByKey");
  }

  oprot->writeMessageBegin("OPS_GetOpsDevIdByKey", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OPS_GetOpsDevIdByKey", bytes);
  }
}

void HalApiProcessor::process_OSC_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OSC_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OSC_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OSC_GetStatusData");
  }

  HalApi_OSC_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OSC_GetStatusData", bytes);
  }

  HalApi_OSC_GetStatusData_result result;
  try {
    iface_->OSC_GetStatusData(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OSC_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OSC_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OSC_GetStatusData");
  }

  oprot->writeMessageBegin("OSC_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OSC_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_OSC_GetCfgData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OSC_GetCfgData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OSC_GetCfgData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OSC_GetCfgData");
  }

  HalApi_OSC_GetCfgData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OSC_GetCfgData", bytes);
  }

  HalApi_OSC_GetCfgData_result result;
  try {
    iface_->OSC_GetCfgData(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OSC_GetCfgData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OSC_GetCfgData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OSC_GetCfgData");
  }

  oprot->writeMessageBegin("OSC_GetCfgData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OSC_GetCfgData", bytes);
  }
}

void HalApiProcessor::process_OSC_SetEnable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OSC_SetEnable", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OSC_SetEnable");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OSC_SetEnable");
  }

  HalApi_OSC_SetEnable_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OSC_SetEnable", bytes);
  }

  HalApi_OSC_SetEnable_result result;
  try {
    result.success = iface_->OSC_SetEnable(args.uiDevType, args.bEnable);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OSC_SetEnable");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OSC_SetEnable", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OSC_SetEnable");
  }

  oprot->writeMessageBegin("OSC_SetEnable", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OSC_SetEnable", bytes);
  }
}

void HalApiProcessor::process_OSC_SetVoa(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OSC_SetVoa", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OSC_SetVoa");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OSC_SetVoa");
  }

  HalApi_OSC_SetVoa_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OSC_SetVoa", bytes);
  }

  HalApi_OSC_SetVoa_result result;
  try {
    result.success = iface_->OSC_SetVoa(args.uiDevType, args.uiTxRx, args.sAttn);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OSC_SetVoa");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OSC_SetVoa", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OSC_SetVoa");
  }

  oprot->writeMessageBegin("OSC_SetVoa", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OSC_SetVoa", bytes);
  }
}

void HalApiProcessor::process_OSC_GetVoa(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OSC_GetVoa", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OSC_GetVoa");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OSC_GetVoa");
  }

  HalApi_OSC_GetVoa_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OSC_GetVoa", bytes);
  }

  HalApi_OSC_GetVoa_result result;
  try {
    iface_->OSC_GetVoa(result.success, args.uiDevType, args.uiTxRx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OSC_GetVoa");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OSC_GetVoa", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OSC_GetVoa");
  }

  oprot->writeMessageBegin("OSC_GetVoa", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OSC_GetVoa", bytes);
  }
}

void HalApiProcessor::process_OSC_SetSwitchPos(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OSC_SetSwitchPos", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OSC_SetSwitchPos");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OSC_SetSwitchPos");
  }

  HalApi_OSC_SetSwitchPos_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OSC_SetSwitchPos", bytes);
  }

  HalApi_OSC_SetSwitchPos_result result;
  try {
    result.success = iface_->OSC_SetSwitchPos(args.uiDevType, args.rstSwitchPos);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OSC_SetSwitchPos");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OSC_SetSwitchPos", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OSC_SetSwitchPos");
  }

  oprot->writeMessageBegin("OSC_SetSwitchPos", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OSC_SetSwitchPos", bytes);
  }
}

void HalApiProcessor::process_OSC_GetSwitchPos(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OSC_GetSwitchPos", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OSC_GetSwitchPos");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OSC_GetSwitchPos");
  }

  HalApi_OSC_GetSwitchPos_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OSC_GetSwitchPos", bytes);
  }

  HalApi_OSC_GetSwitchPos_result result;
  try {
    iface_->OSC_GetSwitchPos(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OSC_GetSwitchPos");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OSC_GetSwitchPos", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OSC_GetSwitchPos");
  }

  oprot->writeMessageBegin("OSC_GetSwitchPos", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OSC_GetSwitchPos", bytes);
  }
}

void HalApiProcessor::process_OTDR_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_GetMfg");
  }

  HalApi_OTDR_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_GetMfg", bytes);
  }

  HalApi_OTDR_GetMfg_result result;
  try {
    iface_->OTDR_GetMfg(result.success, args.ulDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_GetMfg");
  }

  oprot->writeMessageBegin("OTDR_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_GetMfg", bytes);
  }
}

void HalApiProcessor::process_OTDR_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_GetStatusData");
  }

  HalApi_OTDR_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_GetStatusData", bytes);
  }

  HalApi_OTDR_GetStatusData_result result;
  try {
    iface_->OTDR_GetStatusData(result.success, args.ulDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_GetStatusData");
  }

  oprot->writeMessageBegin("OTDR_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_OTDR_GetCfgData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_GetCfgData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_GetCfgData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_GetCfgData");
  }

  HalApi_OTDR_GetCfgData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_GetCfgData", bytes);
  }

  HalApi_OTDR_GetCfgData_result result;
  try {
    iface_->OTDR_GetCfgData(result.success, args.ulDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_GetCfgData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_GetCfgData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_GetCfgData");
  }

  oprot->writeMessageBegin("OTDR_GetCfgData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_GetCfgData", bytes);
  }
}

void HalApiProcessor::process_OTDR_StartScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_StartScan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_StartScan");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_StartScan");
  }

  HalApi_OTDR_StartScan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_StartScan", bytes);
  }

  HalApi_OTDR_StartScan_result result;
  try {
    result.success = iface_->OTDR_StartScan(args.ulDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_StartScan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_StartScan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_StartScan");
  }

  oprot->writeMessageBegin("OTDR_StartScan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_StartScan", bytes);
  }
}

void HalApiProcessor::process_OTDR_SetPara(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_SetPara", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_SetPara");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_SetPara");
  }

  HalApi_OTDR_SetPara_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_SetPara", bytes);
  }

  HalApi_OTDR_SetPara_result result;
  try {
    result.success = iface_->OTDR_SetPara(args.ulDevIdx, args.ulDistRang, args.ulPulseWidth, args.dSamplingResolution);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_SetPara");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_SetPara", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_SetPara");
  }

  oprot->writeMessageBegin("OTDR_SetPara", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_SetPara", bytes);
  }
}

void HalApiProcessor::process_OTDR_SetMeasuringTime(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_SetMeasuringTime", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_SetMeasuringTime");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_SetMeasuringTime");
  }

  HalApi_OTDR_SetMeasuringTime_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_SetMeasuringTime", bytes);
  }

  HalApi_OTDR_SetMeasuringTime_result result;
  try {
    result.success = iface_->OTDR_SetMeasuringTime(args.ulDevIdx, args.ulMeasuringTime);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_SetMeasuringTime");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_SetMeasuringTime", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_SetMeasuringTime");
  }

  oprot->writeMessageBegin("OTDR_SetMeasuringTime", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_SetMeasuringTime", bytes);
  }
}

void HalApiProcessor::process_OTDR_SetUserIOR(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_SetUserIOR", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_SetUserIOR");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_SetUserIOR");
  }

  HalApi_OTDR_SetUserIOR_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_SetUserIOR", bytes);
  }

  HalApi_OTDR_SetUserIOR_result result;
  try {
    result.success = iface_->OTDR_SetUserIOR(args.ulDevIdx, args.dUserIOR);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_SetUserIOR");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_SetUserIOR", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_SetUserIOR");
  }

  oprot->writeMessageBegin("OTDR_SetUserIOR", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_SetUserIOR", bytes);
  }
}

void HalApiProcessor::process_OTDR_SetThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_SetThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_SetThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_SetThr");
  }

  HalApi_OTDR_SetThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_SetThr", bytes);
  }

  HalApi_OTDR_SetThr_result result;
  try {
    result.success = iface_->OTDR_SetThr(args.ulDevIdx, args.dRefThr, args.dSpliceLosThr, args.dFiberEndThr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_SetThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_SetThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_SetThr");
  }

  oprot->writeMessageBegin("OTDR_SetThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_SetThr", bytes);
  }
}

void HalApiProcessor::process_OTDR_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_Reset");
  }

  HalApi_OTDR_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_Reset", bytes);
  }

  HalApi_OTDR_Reset_result result;
  try {
    result.success = iface_->OTDR_Reset(args.ulDevIdx, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_Reset");
  }

  oprot->writeMessageBegin("OTDR_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_Reset", bytes);
  }
}

void HalApiProcessor::process_OTDR_Upgrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_Upgrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_Upgrade");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_Upgrade");
  }

  HalApi_OTDR_Upgrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_Upgrade", bytes);
  }

  HalApi_OTDR_Upgrade_result result;
  try {
    result.success = iface_->OTDR_Upgrade(args.ulDevIdx, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_Upgrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_Upgrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_Upgrade");
  }

  oprot->writeMessageBegin("OTDR_Upgrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_Upgrade", bytes);
  }
}

void HalApiProcessor::process_OTDR_GetUpgadeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_GetUpgadeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_GetUpgadeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_GetUpgadeStatus");
  }

  HalApi_OTDR_GetUpgadeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_GetUpgadeStatus", bytes);
  }

  HalApi_OTDR_GetUpgadeStatus_result result;
  try {
    result.success = iface_->OTDR_GetUpgadeStatus(args.ulDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_GetUpgadeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_GetUpgadeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_GetUpgadeStatus");
  }

  oprot->writeMessageBegin("OTDR_GetUpgadeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_GetUpgadeStatus", bytes);
  }
}

void HalApiProcessor::process_OTDR_DbgRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_DbgRead", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_DbgRead");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_DbgRead");
  }

  HalApi_OTDR_DbgRead_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_DbgRead", bytes);
  }

  HalApi_OTDR_DbgRead_result result;
  try {
    iface_->OTDR_DbgRead(result.success, args.ulDevIdx, args.uiLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_DbgRead");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_DbgRead", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_DbgRead");
  }

  oprot->writeMessageBegin("OTDR_DbgRead", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_DbgRead", bytes);
  }
}

void HalApiProcessor::process_OTDR_DbgWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_DbgWrite", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_DbgWrite");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_DbgWrite");
  }

  HalApi_OTDR_DbgWrite_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_DbgWrite", bytes);
  }

  HalApi_OTDR_DbgWrite_result result;
  try {
    result.success = iface_->OTDR_DbgWrite(args.ulDevIdx, args.pucBuf, args.uiLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_DbgWrite");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_DbgWrite", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_DbgWrite");
  }

  oprot->writeMessageBegin("OTDR_DbgWrite", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_DbgWrite", bytes);
  }
}

void HalApiProcessor::process_OTDR_SetScanMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_SetScanMode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_SetScanMode");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_SetScanMode");
  }

  HalApi_OTDR_SetScanMode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_SetScanMode", bytes);
  }

  HalApi_OTDR_SetScanMode_result result;
  try {
    result.success = iface_->OTDR_SetScanMode(args.uiDevType, args.ulScanMode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_SetScanMode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_SetScanMode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_SetScanMode");
  }

  oprot->writeMessageBegin("OTDR_SetScanMode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_SetScanMode", bytes);
  }
}

void HalApiProcessor::process_OTDR_SetStartOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_SetStartOffset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_SetStartOffset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_SetStartOffset");
  }

  HalApi_OTDR_SetStartOffset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_SetStartOffset", bytes);
  }

  HalApi_OTDR_SetStartOffset_result result;
  try {
    result.success = iface_->OTDR_SetStartOffset(args.uiDevType, args.pstStartOffset);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_SetStartOffset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_SetStartOffset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_SetStartOffset");
  }

  oprot->writeMessageBegin("OTDR_SetStartOffset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_SetStartOffset", bytes);
  }
}

void HalApiProcessor::process_OTDR_GetStartOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_GetStartOffset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_GetStartOffset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_GetStartOffset");
  }

  HalApi_OTDR_GetStartOffset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_GetStartOffset", bytes);
  }

  HalApi_OTDR_GetStartOffset_result result;
  try {
    iface_->OTDR_GetStartOffset(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_GetStartOffset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_GetStartOffset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_GetStartOffset");
  }

  oprot->writeMessageBegin("OTDR_GetStartOffset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_GetStartOffset", bytes);
  }
}

void HalApiProcessor::process_OTDR_StartScanPort(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.OTDR_StartScanPort", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.OTDR_StartScanPort");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.OTDR_StartScanPort");
  }

  HalApi_OTDR_StartScanPort_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.OTDR_StartScanPort", bytes);
  }

  HalApi_OTDR_StartScanPort_result result;
  try {
    result.success = iface_->OTDR_StartScanPort(args.ulDevIdx, args.ulPortId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.OTDR_StartScanPort");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("OTDR_StartScanPort", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.OTDR_StartScanPort");
  }

  oprot->writeMessageBegin("OTDR_StartScanPort", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.OTDR_StartScanPort", bytes);
  }
}

void HalApiProcessor::process_SLOT_GetDevIdx(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_GetDevIdx", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_GetDevIdx");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_GetDevIdx");
  }

  HalApi_SLOT_GetDevIdx_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_GetDevIdx", bytes);
  }

  HalApi_SLOT_GetDevIdx_result result;
  try {
    iface_->SLOT_GetDevIdx(result.success, args.uiDevType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_GetDevIdx");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_GetDevIdx", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_GetDevIdx");
  }

  oprot->writeMessageBegin("SLOT_GetDevIdx", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_GetDevIdx", bytes);
  }
}

void HalApiProcessor::process_SLOT_SetOnline(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_SetOnline", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_SetOnline");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_SetOnline");
  }

  HalApi_SLOT_SetOnline_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_SetOnline", bytes);
  }

  HalApi_SLOT_SetOnline_result result;
  try {
    result.success = iface_->SLOT_SetOnline(args.uiSlotIdx, args.bOnline);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_SetOnline");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_SetOnline", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_SetOnline");
  }

  oprot->writeMessageBegin("SLOT_SetOnline", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_SetOnline", bytes);
  }
}

void HalApiProcessor::process_SLOT_GetSlotNum(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_GetSlotNum", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_GetSlotNum");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_GetSlotNum");
  }

  HalApi_SLOT_GetSlotNum_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_GetSlotNum", bytes);
  }

  HalApi_SLOT_GetSlotNum_result result;
  try {
    iface_->SLOT_GetSlotNum(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_GetSlotNum");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_GetSlotNum", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_GetSlotNum");
  }

  oprot->writeMessageBegin("SLOT_GetSlotNum", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_GetSlotNum", bytes);
  }
}

void HalApiProcessor::process_SLOT_SetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_SetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_SetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_SetMfg");
  }

  HalApi_SLOT_SetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_SetMfg", bytes);
  }

  HalApi_SLOT_SetMfg_result result;
  try {
    result.success = iface_->SLOT_SetMfg(args.uiSlotIdx, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_SetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_SetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_SetMfg");
  }

  oprot->writeMessageBegin("SLOT_SetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_SetMfg", bytes);
  }
}

void HalApiProcessor::process_SLOT_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_GetMfg");
  }

  HalApi_SLOT_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_GetMfg", bytes);
  }

  HalApi_SLOT_GetMfg_result result;
  try {
    iface_->SLOT_GetMfg(result.success, args.uiSlotIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_GetMfg");
  }

  oprot->writeMessageBegin("SLOT_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_GetMfg", bytes);
  }
}

void HalApiProcessor::process_SLOT_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_GetStatusData");
  }

  HalApi_SLOT_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_GetStatusData", bytes);
  }

  HalApi_SLOT_GetStatusData_result result;
  try {
    iface_->SLOT_GetStatusData(result.success, args.uiSlotIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_GetStatusData");
  }

  oprot->writeMessageBegin("SLOT_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_SLOT_ClearPlugFlag(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_ClearPlugFlag", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_ClearPlugFlag");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_ClearPlugFlag");
  }

  HalApi_SLOT_ClearPlugFlag_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_ClearPlugFlag", bytes);
  }

  HalApi_SLOT_ClearPlugFlag_result result;
  try {
    result.success = iface_->SLOT_ClearPlugFlag(args.uiSlotIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_ClearPlugFlag");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_ClearPlugFlag", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_ClearPlugFlag");
  }

  oprot->writeMessageBegin("SLOT_ClearPlugFlag", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_ClearPlugFlag", bytes);
  }
}

void HalApiProcessor::process_SLOT_GetInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_GetInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_GetInfo");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_GetInfo");
  }

  HalApi_SLOT_GetInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_GetInfo", bytes);
  }

  HalApi_SLOT_GetInfo_result result;
  try {
    iface_->SLOT_GetInfo(result.success, args.uiSlotIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_GetInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_GetInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_GetInfo");
  }

  oprot->writeMessageBegin("SLOT_GetInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_GetInfo", bytes);
  }
}

void HalApiProcessor::process_SLOT_GetCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_GetCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_GetCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_GetCali");
  }

  HalApi_SLOT_GetCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_GetCali", bytes);
  }

  HalApi_SLOT_GetCali_result result;
  try {
    iface_->SLOT_GetCali(result.success, args.uiSlotIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_GetCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_GetCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_GetCali");
  }

  oprot->writeMessageBegin("SLOT_GetCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_GetCali", bytes);
  }
}

void HalApiProcessor::process_SLOT_SetCali(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_SetCali", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_SetCali");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_SetCali");
  }

  HalApi_SLOT_SetCali_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_SetCali", bytes);
  }

  HalApi_SLOT_SetCali_result result;
  try {
    result.success = iface_->SLOT_SetCali(args.uiSlotIdx, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_SetCali");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_SetCali", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_SetCali");
  }

  oprot->writeMessageBegin("SLOT_SetCali", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_SetCali", bytes);
  }
}

void HalApiProcessor::process_SLOT_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_Reset");
  }

  HalApi_SLOT_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_Reset", bytes);
  }

  HalApi_SLOT_Reset_result result;
  try {
    result.success = iface_->SLOT_Reset(args.uiSlotIdx, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_Reset");
  }

  oprot->writeMessageBegin("SLOT_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_Reset", bytes);
  }
}

void HalApiProcessor::process_SLOT_SetLed(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_SetLed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_SetLed");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_SetLed");
  }

  HalApi_SLOT_SetLed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_SetLed", bytes);
  }

  HalApi_SLOT_SetLed_result result;
  try {
    result.success = iface_->SLOT_SetLed(args.uiSlotIdx, args.uiLedIdx, args.uiState);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_SetLed");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_SetLed", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_SetLed");
  }

  oprot->writeMessageBegin("SLOT_SetLed", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_SetLed", bytes);
  }
}

void HalApiProcessor::process_SLOT_ReadEeprom(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_ReadEeprom", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_ReadEeprom");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_ReadEeprom");
  }

  HalApi_SLOT_ReadEeprom_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_ReadEeprom", bytes);
  }

  HalApi_SLOT_ReadEeprom_result result;
  try {
    iface_->SLOT_ReadEeprom(result.success, args.uiIdx, args.ulAddr, args.ulLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_ReadEeprom");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_ReadEeprom", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_ReadEeprom");
  }

  oprot->writeMessageBegin("SLOT_ReadEeprom", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_ReadEeprom", bytes);
  }
}

void HalApiProcessor::process_SLOT_WriteEeprom(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.SLOT_WriteEeprom", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.SLOT_WriteEeprom");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.SLOT_WriteEeprom");
  }

  HalApi_SLOT_WriteEeprom_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.SLOT_WriteEeprom", bytes);
  }

  HalApi_SLOT_WriteEeprom_result result;
  try {
    result.success = iface_->SLOT_WriteEeprom(args.uiIdx, args.ulAddr, args.ulLen, args.pucVal);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.SLOT_WriteEeprom");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SLOT_WriteEeprom", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.SLOT_WriteEeprom");
  }

  oprot->writeMessageBegin("SLOT_WriteEeprom", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.SLOT_WriteEeprom", bytes);
  }
}

void HalApiProcessor::process_TDCM_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.TDCM_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.TDCM_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.TDCM_GetMfg");
  }

  HalApi_TDCM_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.TDCM_GetMfg", bytes);
  }

  HalApi_TDCM_GetMfg_result result;
  try {
    iface_->TDCM_GetMfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.TDCM_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TDCM_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.TDCM_GetMfg");
  }

  oprot->writeMessageBegin("TDCM_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.TDCM_GetMfg", bytes);
  }
}

void HalApiProcessor::process_TDCM_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.TDCM_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.TDCM_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.TDCM_GetStatusData");
  }

  HalApi_TDCM_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.TDCM_GetStatusData", bytes);
  }

  HalApi_TDCM_GetStatusData_result result;
  try {
    iface_->TDCM_GetStatusData(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.TDCM_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TDCM_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.TDCM_GetStatusData");
  }

  oprot->writeMessageBegin("TDCM_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.TDCM_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_TDCM_GetCfgData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.TDCM_GetCfgData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.TDCM_GetCfgData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.TDCM_GetCfgData");
  }

  HalApi_TDCM_GetCfgData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.TDCM_GetCfgData", bytes);
  }

  HalApi_TDCM_GetCfgData_result result;
  try {
    iface_->TDCM_GetCfgData(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.TDCM_GetCfgData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TDCM_GetCfgData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.TDCM_GetCfgData");
  }

  oprot->writeMessageBegin("TDCM_GetCfgData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.TDCM_GetCfgData", bytes);
  }
}

void HalApiProcessor::process_TDCM_SetFrequency(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.TDCM_SetFrequency", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.TDCM_SetFrequency");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.TDCM_SetFrequency");
  }

  HalApi_TDCM_SetFrequency_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.TDCM_SetFrequency", bytes);
  }

  HalApi_TDCM_SetFrequency_result result;
  try {
    result.success = iface_->TDCM_SetFrequency(args.uiDevIdx, args.fFrequency);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.TDCM_SetFrequency");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TDCM_SetFrequency", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.TDCM_SetFrequency");
  }

  oprot->writeMessageBegin("TDCM_SetFrequency", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.TDCM_SetFrequency", bytes);
  }
}

void HalApiProcessor::process_TDCM_SetDispersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.TDCM_SetDispersion", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.TDCM_SetDispersion");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.TDCM_SetDispersion");
  }

  HalApi_TDCM_SetDispersion_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.TDCM_SetDispersion", bytes);
  }

  HalApi_TDCM_SetDispersion_result result;
  try {
    result.success = iface_->TDCM_SetDispersion(args.uiDevIdx, args.fDispersion);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.TDCM_SetDispersion");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TDCM_SetDispersion", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.TDCM_SetDispersion");
  }

  oprot->writeMessageBegin("TDCM_SetDispersion", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.TDCM_SetDispersion", bytes);
  }
}

void HalApiProcessor::process_TDCM_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.TDCM_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.TDCM_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.TDCM_Reset");
  }

  HalApi_TDCM_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.TDCM_Reset", bytes);
  }

  HalApi_TDCM_Reset_result result;
  try {
    result.success = iface_->TDCM_Reset(args.uiDevIdx, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.TDCM_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TDCM_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.TDCM_Reset");
  }

  oprot->writeMessageBegin("TDCM_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.TDCM_Reset", bytes);
  }
}

void HalApiProcessor::process_WSS_GetMfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetMfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetMfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetMfg");
  }

  HalApi_WSS_GetMfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetMfg", bytes);
  }

  HalApi_WSS_GetMfg_result result;
  try {
    iface_->WSS_GetMfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetMfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetMfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetMfg");
  }

  oprot->writeMessageBegin("WSS_GetMfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetMfg", bytes);
  }
}

void HalApiProcessor::process_WSS_GetCfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetCfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetCfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetCfg");
  }

  HalApi_WSS_GetCfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetCfg", bytes);
  }

  HalApi_WSS_GetCfg_result result;
  try {
    iface_->WSS_GetCfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetCfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetCfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetCfg");
  }

  oprot->writeMessageBegin("WSS_GetCfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetCfg", bytes);
  }
}

void HalApiProcessor::process_WSS_GetOscCfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetOscCfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetOscCfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetOscCfg");
  }

  HalApi_WSS_GetOscCfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetOscCfg", bytes);
  }

  HalApi_WSS_GetOscCfg_result result;
  try {
    iface_->WSS_GetOscCfg(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetOscCfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetOscCfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetOscCfg");
  }

  oprot->writeMessageBegin("WSS_GetOscCfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetOscCfg", bytes);
  }
}

void HalApiProcessor::process_WSS_GetStatusData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetStatusData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetStatusData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetStatusData");
  }

  HalApi_WSS_GetStatusData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetStatusData", bytes);
  }

  HalApi_WSS_GetStatusData_result result;
  try {
    iface_->WSS_GetStatusData(result.success, args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetStatusData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetStatusData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetStatusData");
  }

  oprot->writeMessageBegin("WSS_GetStatusData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetStatusData", bytes);
  }
}

void HalApiProcessor::process_WSS_SetAllChCfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetAllChCfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetAllChCfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetAllChCfg");
  }

  HalApi_WSS_SetAllChCfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetAllChCfg", bytes);
  }

  HalApi_WSS_SetAllChCfg_result result;
  try {
    result.success = iface_->WSS_SetAllChCfg(args.uiDevIdx, args.uiSubIdx, args.uiChCnt, args.pstWssCfg);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetAllChCfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetAllChCfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetAllChCfg");
  }

  oprot->writeMessageBegin("WSS_SetAllChCfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetAllChCfg", bytes);
  }
}

void HalApiProcessor::process_WSS_SetOscChCfg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetOscChCfg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetOscChCfg");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetOscChCfg");
  }

  HalApi_WSS_SetOscChCfg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetOscChCfg", bytes);
  }

  HalApi_WSS_SetOscChCfg_result result;
  try {
    result.success = iface_->WSS_SetOscChCfg(args.uiDevIdx, args.uiSubIdx, args.uiChCnt, args.pstWssCfg);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetOscChCfg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetOscChCfg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetOscChCfg");
  }

  oprot->writeMessageBegin("WSS_SetOscChCfg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetOscChCfg", bytes);
  }
}

void HalApiProcessor::process_WSS_SetWaveplan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetWaveplan", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetWaveplan");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetWaveplan");
  }

  HalApi_WSS_SetWaveplan_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetWaveplan", bytes);
  }

  HalApi_WSS_SetWaveplan_result result;
  try {
    result.success = iface_->WSS_SetWaveplan(args.uiDevIdx, args.uiSubIdx, args.uiChCnt, args.pstWavePlan);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetWaveplan");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetWaveplan", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetWaveplan");
  }

  oprot->writeMessageBegin("WSS_SetWaveplan", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetWaveplan", bytes);
  }
}

void HalApiProcessor::process_WSS_SetPortPowerThr(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetPortPowerThr", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetPortPowerThr");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetPortPowerThr");
  }

  HalApi_WSS_SetPortPowerThr_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetPortPowerThr", bytes);
  }

  HalApi_WSS_SetPortPowerThr_result result;
  try {
    result.success = iface_->WSS_SetPortPowerThr(args.uiDevIdx, args.uiPortIdx, args.uiType, args.sThr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetPortPowerThr");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetPortPowerThr", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetPortPowerThr");
  }

  oprot->writeMessageBegin("WSS_SetPortPowerThr", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetPortPowerThr", bytes);
  }
}

void HalApiProcessor::process_WSS_SetPortPowerHys(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetPortPowerHys", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetPortPowerHys");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetPortPowerHys");
  }

  HalApi_WSS_SetPortPowerHys_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetPortPowerHys", bytes);
  }

  HalApi_WSS_SetPortPowerHys_result result;
  try {
    result.success = iface_->WSS_SetPortPowerHys(args.uiDevIdx, args.uiPortIdx, args.uiType, args.sHys);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetPortPowerHys");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetPortPowerHys", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetPortPowerHys");
  }

  oprot->writeMessageBegin("WSS_SetPortPowerHys", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetPortPowerHys", bytes);
  }
}

void HalApiProcessor::process_WSS_GetPortPowerHistory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetPortPowerHistory", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetPortPowerHistory");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetPortPowerHistory");
  }

  HalApi_WSS_GetPortPowerHistory_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetPortPowerHistory", bytes);
  }

  HalApi_WSS_GetPortPowerHistory_result result;
  try {
    result.success = iface_->WSS_GetPortPowerHistory(args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetPortPowerHistory");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetPortPowerHistory", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetPortPowerHistory");
  }

  oprot->writeMessageBegin("WSS_GetPortPowerHistory", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetPortPowerHistory", bytes);
  }
}

void HalApiProcessor::process_WSS_SetLedMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetLedMode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetLedMode");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetLedMode");
  }

  HalApi_WSS_SetLedMode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetLedMode", bytes);
  }

  HalApi_WSS_SetLedMode_result result;
  try {
    result.success = iface_->WSS_SetLedMode(args.uiDevIdx, args.uiMode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetLedMode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetLedMode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetLedMode");
  }

  oprot->writeMessageBegin("WSS_SetLedMode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetLedMode", bytes);
  }
}

void HalApiProcessor::process_WSS_SetLedDebugMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetLedDebugMode", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetLedDebugMode");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetLedDebugMode");
  }

  HalApi_WSS_SetLedDebugMode_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetLedDebugMode", bytes);
  }

  HalApi_WSS_SetLedDebugMode_result result;
  try {
    result.success = iface_->WSS_SetLedDebugMode(args.uiDevIdx, args.uiMode);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetLedDebugMode");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetLedDebugMode", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetLedDebugMode");
  }

  oprot->writeMessageBegin("WSS_SetLedDebugMode", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetLedDebugMode", bytes);
  }
}

void HalApiProcessor::process_WSS_SetLedStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetLedStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetLedStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetLedStatus");
  }

  HalApi_WSS_SetLedStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetLedStatus", bytes);
  }

  HalApi_WSS_SetLedStatus_result result;
  try {
    result.success = iface_->WSS_SetLedStatus(args.uiDevIdx, args.uiLedIdx, args.uiStatus);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetLedStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetLedStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetLedStatus");
  }

  oprot->writeMessageBegin("WSS_SetLedStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetLedStatus", bytes);
  }
}

void HalApiProcessor::process_WSS_Reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_Reset", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_Reset");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_Reset");
  }

  HalApi_WSS_Reset_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_Reset", bytes);
  }

  HalApi_WSS_Reset_result result;
  try {
    result.success = iface_->WSS_Reset(args.uiDevIdx, args.ucResetType);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_Reset");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_Reset", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_Reset");
  }

  oprot->writeMessageBegin("WSS_Reset", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_Reset", bytes);
  }
}

void HalApiProcessor::process_WSS_Upgrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_Upgrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_Upgrade");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_Upgrade");
  }

  HalApi_WSS_Upgrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_Upgrade", bytes);
  }

  HalApi_WSS_Upgrade_result result;
  try {
    result.success = iface_->WSS_Upgrade(args.uiDevIdx, args.c_pcFilePath);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_Upgrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_Upgrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_Upgrade");
  }

  oprot->writeMessageBegin("WSS_Upgrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_Upgrade", bytes);
  }
}

void HalApiProcessor::process_WSS_GetUpgradeStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetUpgradeStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetUpgradeStatus");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetUpgradeStatus");
  }

  HalApi_WSS_GetUpgradeStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetUpgradeStatus", bytes);
  }

  HalApi_WSS_GetUpgradeStatus_result result;
  try {
    result.success = iface_->WSS_GetUpgradeStatus(args.uiDevIdx);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetUpgradeStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetUpgradeStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetUpgradeStatus");
  }

  oprot->writeMessageBegin("WSS_GetUpgradeStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetUpgradeStatus", bytes);
  }
}

void HalApiProcessor::process_WSS_SetUserData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetUserData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetUserData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetUserData");
  }

  HalApi_WSS_SetUserData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetUserData", bytes);
  }

  HalApi_WSS_SetUserData_result result;
  try {
    result.success = iface_->WSS_SetUserData(args.uiDevIdx, args.pucData, args.nLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetUserData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetUserData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetUserData");
  }

  oprot->writeMessageBegin("WSS_SetUserData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetUserData", bytes);
  }
}

void HalApiProcessor::process_WSS_GetUserData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetUserData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetUserData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetUserData");
  }

  HalApi_WSS_GetUserData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetUserData", bytes);
  }

  HalApi_WSS_GetUserData_result result;
  try {
    iface_->WSS_GetUserData(result.success, args.uiDevIdx, args.nLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetUserData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetUserData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetUserData");
  }

  oprot->writeMessageBegin("WSS_GetUserData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetUserData", bytes);
  }
}

void HalApiProcessor::process_WSS_SetPmUserData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_SetPmUserData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_SetPmUserData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_SetPmUserData");
  }

  HalApi_WSS_SetPmUserData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_SetPmUserData", bytes);
  }

  HalApi_WSS_SetPmUserData_result result;
  try {
    result.success = iface_->WSS_SetPmUserData(args.uiDevIdx, args.pucData, args.nLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_SetPmUserData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_SetPmUserData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_SetPmUserData");
  }

  oprot->writeMessageBegin("WSS_SetPmUserData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_SetPmUserData", bytes);
  }
}

void HalApiProcessor::process_WSS_GetPmUserData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("HalApi.WSS_GetPmUserData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HalApi.WSS_GetPmUserData");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "HalApi.WSS_GetPmUserData");
  }

  HalApi_WSS_GetPmUserData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "HalApi.WSS_GetPmUserData", bytes);
  }

  HalApi_WSS_GetPmUserData_result result;
  try {
    iface_->WSS_GetPmUserData(result.success, args.uiDevIdx, args.nLen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "HalApi.WSS_GetPmUserData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("WSS_GetPmUserData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "HalApi.WSS_GetPmUserData");
  }

  oprot->writeMessageBegin("WSS_GetPmUserData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "HalApi.WSS_GetPmUserData", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > HalApiProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< HalApiIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< HalApiIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new HalApiProcessor(handler));
  return processor;
}

void HalApiConcurrentClient::BOARD_GetChassisMfg(CMfg_rsp& _return)
{
  int32_t seqid = send_BOARD_GetChassisMfg();
  recv_BOARD_GetChassisMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetChassisMfg()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetChassisMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetChassisMfg_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetChassisMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetChassisMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetChassisMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetChassisMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetChassisMfg(const std::string& pcFilePath)
{
  int32_t seqid = send_BOARD_SetChassisMfg(pcFilePath);
  return recv_BOARD_SetChassisMfg(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetChassisMfg(const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetChassisMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisMfg_pargs args;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetChassisMfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetChassisMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetChassisMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetChassisConfigType(const std::string& pcConfigType)
{
  int32_t seqid = send_BOARD_SetChassisConfigType(pcConfigType);
  return recv_BOARD_SetChassisConfigType(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetChassisConfigType(const std::string& pcConfigType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetChassisConfigType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisConfigType_pargs args;
  args.pcConfigType = &pcConfigType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetChassisConfigType(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetChassisConfigType") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetChassisConfigType_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisConfigType failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetChassisCali(CCali_rsp& _return)
{
  int32_t seqid = send_BOARD_GetChassisCali();
  recv_BOARD_GetChassisCali(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetChassisCali()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetChassisCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetChassisCali_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetChassisCali(CCali_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetChassisCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetChassisCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetChassisCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetChassisCali(const std::string& pcFilePath)
{
  int32_t seqid = send_BOARD_SetChassisCali(pcFilePath);
  return recv_BOARD_SetChassisCali(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetChassisCali(const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetChassisCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisCali_pargs args;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetChassisCali(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetChassisCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetChassisCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_GetChassisCfg(const int32_t uiAddrSlice, const std::string& pcFilePath)
{
  int32_t seqid = send_BOARD_GetChassisCfg(uiAddrSlice, pcFilePath);
  return recv_BOARD_GetChassisCfg(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetChassisCfg(const int32_t uiAddrSlice, const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetChassisCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetChassisCfg_pargs args;
  args.uiAddrSlice = &uiAddrSlice;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_GetChassisCfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetChassisCfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_GetChassisCfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetChassisCfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetChassisCfg(const int32_t uiAddrSlice, const int32_t uiSize, const std::string& pcFilePath)
{
  int32_t seqid = send_BOARD_SetChassisCfg(uiAddrSlice, uiSize, pcFilePath);
  return recv_BOARD_SetChassisCfg(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetChassisCfg(const int32_t uiAddrSlice, const int32_t uiSize, const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetChassisCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetChassisCfg_pargs args;
  args.uiAddrSlice = &uiAddrSlice;
  args.uiSize = &uiSize;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetChassisCfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetChassisCfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetChassisCfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetChassisCfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetUpgInfo(binary_rsp& _return, const int32_t ulLen)
{
  int32_t seqid = send_BOARD_GetUpgInfo(ulLen);
  recv_BOARD_GetUpgInfo(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetUpgInfo(const int32_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetUpgInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetUpgInfo_pargs args;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetUpgInfo(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetUpgInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetUpgInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetUpgInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetUpgInfo(const std::string& pucBuf, const int32_t ulLen)
{
  int32_t seqid = send_BOARD_SetUpgInfo(pucBuf, ulLen);
  return recv_BOARD_SetUpgInfo(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetUpgInfo(const std::string& pucBuf, const int32_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetUpgInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetUpgInfo_pargs args;
  args.pucBuf = &pucBuf;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetUpgInfo(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetUpgInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetUpgInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetUpgInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetBdlHead(binary_rsp& _return, const int32_t ulLen)
{
  int32_t seqid = send_BOARD_GetBdlHead(ulLen);
  recv_BOARD_GetBdlHead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetBdlHead(const int32_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetBdlHead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetBdlHead_pargs args;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetBdlHead(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetBdlHead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetBdlHead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetBdlHead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetBdlHead(const std::string& pucBuf, const int32_t ulLen)
{
  int32_t seqid = send_BOARD_SetBdlHead(pucBuf, ulLen);
  return recv_BOARD_SetBdlHead(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetBdlHead(const std::string& pucBuf, const int32_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetBdlHead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetBdlHead_pargs args;
  args.pucBuf = &pucBuf;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetBdlHead(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetBdlHead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetBdlHead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetBdlHead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetStatusData(CBoardStatusData_rsp& _return)
{
  int32_t seqid = send_BOARD_GetStatusData();
  recv_BOARD_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetStatusData()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetStatusData_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetStatusData(CBoardStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetSccMfg(CMfg_rsp& _return)
{
  int32_t seqid = send_BOARD_GetSccMfg();
  recv_BOARD_GetSccMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetSccMfg()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetSccMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetSccMfg_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetSccMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetSccMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetSccMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetSccMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetSccMfg(const std::string& pcFilePath)
{
  int32_t seqid = send_BOARD_SetSccMfg(pcFilePath);
  return recv_BOARD_SetSccMfg(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetSccMfg(const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetSccMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetSccMfg_pargs args;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetSccMfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetSccMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetSccMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetSccMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetResetType(const int8_t ucResetType)
{
  int32_t seqid = send_BOARD_SetResetType(ucResetType);
  return recv_BOARD_SetResetType(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetResetType(const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetResetType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetResetType_pargs args;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetResetType(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetResetType") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetResetType_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetResetType failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetResetType(i8_rsp& _return, const int32_t iIndex)
{
  int32_t seqid = send_BOARD_GetResetType(iIndex);
  recv_BOARD_GetResetType(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetResetType(const int32_t iIndex)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetResetType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetResetType_pargs args;
  args.iIndex = &iIndex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetResetType(i8_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetResetType") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetResetType_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetResetType failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_CfgWatchDogTime(const bool bEnable, const int8_t ucTimeout)
{
  int32_t seqid = send_BOARD_CfgWatchDogTime(bEnable, ucTimeout);
  return recv_BOARD_CfgWatchDogTime(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_CfgWatchDogTime(const bool bEnable, const int8_t ucTimeout)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_CfgWatchDogTime", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_CfgWatchDogTime_pargs args;
  args.bEnable = &bEnable;
  args.ucTimeout = &ucTimeout;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_CfgWatchDogTime(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_CfgWatchDogTime") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_CfgWatchDogTime_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_CfgWatchDogTime failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetApsdStatus(bool_list_rsp& _return, const int32_t iIndex)
{
  int32_t seqid = send_BOARD_GetApsdStatus(iIndex);
  recv_BOARD_GetApsdStatus(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetApsdStatus(const int32_t iIndex)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetApsdStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetApsdStatus_pargs args;
  args.iIndex = &iIndex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetApsdStatus(bool_list_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetApsdStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetApsdStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetApsdStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetLedState(const int32_t uiDevIdx, const int32_t uiState)
{
  int32_t seqid = send_BOARD_SetLedState(uiDevIdx, uiState);
  return recv_BOARD_SetLedState(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetLedState(const int32_t uiDevIdx, const int32_t uiState)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetLedState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetLedState_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiState = &uiState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetLedState(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetLedState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetLedState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetLedState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_ResetLogic(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t seqid = send_BOARD_ResetLogic(uiDevIdx, ucResetType);
  return recv_BOARD_ResetLogic(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_ResetLogic(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_ResetLogic", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_ResetLogic_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_ResetLogic(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_ResetLogic") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_ResetLogic_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_ResetLogic failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_UpgradeLogic(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t seqid = send_BOARD_UpgradeLogic(uiDevIdx, c_pcFilePath);
  return recv_BOARD_UpgradeLogic(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_UpgradeLogic(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_UpgradeLogic", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_UpgradeLogic_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_UpgradeLogic(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_UpgradeLogic") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_UpgradeLogic_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_UpgradeLogic failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_GetUpgadeStatus()
{
  int32_t seqid = send_BOARD_GetUpgadeStatus();
  return recv_BOARD_GetUpgadeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetUpgadeStatus()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetUpgadeStatus_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_GetUpgadeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetUpgadeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_GetUpgadeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetUpgadeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::FAN_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_FAN_GetMfg(uiDevIdx);
  recv_FAN_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_FAN_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("FAN_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_FAN_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("FAN_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_FAN_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::FAN_SetMfg(const int32_t uiDevIdx, const std::string& pcFilePath)
{
  int32_t seqid = send_FAN_SetMfg(uiDevIdx, pcFilePath);
  return recv_FAN_SetMfg(seqid);
}

int32_t HalApiConcurrentClient::send_FAN_SetMfg(const int32_t uiDevIdx, const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("FAN_SetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_FAN_SetMfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("FAN_SetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_FAN_SetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::FAN_SetSpeed(const int32_t uiDevIdx, const int32_t uiDuty)
{
  int32_t seqid = send_FAN_SetSpeed(uiDevIdx, uiDuty);
  return recv_FAN_SetSpeed(seqid);
}

int32_t HalApiConcurrentClient::send_FAN_SetSpeed(const int32_t uiDevIdx, const int32_t uiDuty)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("FAN_SetSpeed", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetSpeed_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiDuty = &uiDuty;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_FAN_SetSpeed(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("FAN_SetSpeed") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_FAN_SetSpeed_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetSpeed failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::FAN_SetControllerEEP(const int32_t uiDevIdx)
{
  int32_t seqid = send_FAN_SetControllerEEP(uiDevIdx);
  return recv_FAN_SetControllerEEP(seqid);
}

int32_t HalApiConcurrentClient::send_FAN_SetControllerEEP(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("FAN_SetControllerEEP", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetControllerEEP_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_FAN_SetControllerEEP(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("FAN_SetControllerEEP") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_FAN_SetControllerEEP_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetControllerEEP failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::FAN_SetLed(const int32_t uiDevIdx, const int32_t uiValue)
{
  int32_t seqid = send_FAN_SetLed(uiDevIdx, uiValue);
  return recv_FAN_SetLed(seqid);
}

int32_t HalApiConcurrentClient::send_FAN_SetLed(const int32_t uiDevIdx, const int32_t uiValue)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("FAN_SetLed", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_FAN_SetLed_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiValue = &uiValue;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_FAN_SetLed(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("FAN_SetLed") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_FAN_SetLed_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FAN_SetLed failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::POWER_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_POWER_GetMfg(uiDevIdx);
  recv_POWER_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_POWER_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("POWER_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_POWER_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_POWER_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("POWER_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_POWER_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "POWER_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetProductName(string_rsp& _return, const int32_t nSize)
{
  int32_t seqid = send_BOARD_GetProductName(nSize);
  recv_BOARD_GetProductName(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetProductName(const int32_t nSize)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetProductName", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetProductName_pargs args;
  args.nSize = &nSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetProductName(string_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetProductName") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetProductName_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetProductName failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_GetConfigType(string_rsp& _return, const int32_t nSize)
{
  int32_t seqid = send_BOARD_GetConfigType(nSize);
  recv_BOARD_GetConfigType(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetConfigType(const int32_t nSize)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetConfigType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetConfigType_pargs args;
  args.nSize = &nSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_GetConfigType(string_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetConfigType") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_GetConfigType_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetConfigType failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_GetProductType()
{
  int32_t seqid = send_BOARD_GetProductType();
  return recv_BOARD_GetProductType(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_GetProductType()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_GetProductType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_GetProductType_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_GetProductType(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_GetProductType") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_GetProductType_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_GetProductType failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::BOARD_SetLogLevel(const int32_t uiLogLevel)
{
  int32_t seqid = send_BOARD_SetLogLevel(uiLogLevel);
  return recv_BOARD_SetLogLevel(seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_SetLogLevel(const int32_t uiLogLevel)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_SetLogLevel", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_SetLogLevel_pargs args;
  args.uiLogLevel = &uiLogLevel;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_BOARD_SetLogLevel(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_SetLogLevel") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_BOARD_SetLogLevel_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_SetLogLevel failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::BOARD_ConvertDevType(i32_rsp& _return, const std::string& pcName)
{
  int32_t seqid = send_BOARD_ConvertDevType(pcName);
  recv_BOARD_ConvertDevType(_return, seqid);
}

int32_t HalApiConcurrentClient::send_BOARD_ConvertDevType(const std::string& pcName)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("BOARD_ConvertDevType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_BOARD_ConvertDevType_pargs args;
  args.pcName = &pcName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_BOARD_ConvertDevType(i32_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("BOARD_ConvertDevType") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_BOARD_ConvertDevType_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "BOARD_ConvertDevType failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::Cv_GetMuxStatusData(CCvMuxStatusData_rsp& _return, const int32_t enCvLine)
{
  int32_t seqid = send_Cv_GetMuxStatusData(enCvLine);
  recv_Cv_GetMuxStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_Cv_GetMuxStatusData(const int32_t enCvLine)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Cv_GetMuxStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_Cv_GetMuxStatusData_pargs args;
  args.enCvLine = &enCvLine;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_Cv_GetMuxStatusData(CCvMuxStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Cv_GetMuxStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_Cv_GetMuxStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Cv_GetMuxStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::Cv_GetClientStatusData(CCvClientStatusData_rsp& _return, const int32_t enCvLine)
{
  int32_t seqid = send_Cv_GetClientStatusData(enCvLine);
  recv_Cv_GetClientStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_Cv_GetClientStatusData(const int32_t enCvLine)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Cv_GetClientStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_Cv_GetClientStatusData_pargs args;
  args.enCvLine = &enCvLine;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_Cv_GetClientStatusData(CCvClientStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Cv_GetClientStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_Cv_GetClientStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Cv_GetClientStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::Cv_GetRef(CCvRef_rsp& _return)
{
  int32_t seqid = send_Cv_GetRef();
  recv_Cv_GetRef(_return, seqid);
}

int32_t HalApiConcurrentClient::send_Cv_GetRef()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("Cv_GetRef", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_Cv_GetRef_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_Cv_GetRef(CCvRef_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("Cv_GetRef") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_Cv_GetRef_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "Cv_GetRef failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_ReadLogicReg(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t seqid = send_DBG_ReadLogicReg(uiIdx, ulAddr, ulLen);
  recv_DBG_ReadLogicReg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_ReadLogicReg(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_ReadLogicReg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ReadLogicReg_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_ReadLogicReg(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_ReadLogicReg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_ReadLogicReg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ReadLogicReg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_WriteLogicReg(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t seqid = send_DBG_WriteLogicReg(uiIdx, ulAddr, ulLen, pucVal);
  return recv_DBG_WriteLogicReg(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_WriteLogicReg(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_WriteLogicReg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_WriteLogicReg_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_WriteLogicReg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_WriteLogicReg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_WriteLogicReg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_WriteLogicReg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_ReadLogicRegSlc(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t seqid = send_DBG_ReadLogicRegSlc(uiIdx, ulAddr, ulLen);
  recv_DBG_ReadLogicRegSlc(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_ReadLogicRegSlc(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_ReadLogicRegSlc", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ReadLogicRegSlc_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_ReadLogicRegSlc(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_ReadLogicRegSlc") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_ReadLogicRegSlc_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ReadLogicRegSlc failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_WriteLogicRegSlc(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t seqid = send_DBG_WriteLogicRegSlc(uiIdx, ulAddr, ulLen, pucVal);
  return recv_DBG_WriteLogicRegSlc(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_WriteLogicRegSlc(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_WriteLogicRegSlc", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_WriteLogicRegSlc_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_WriteLogicRegSlc(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_WriteLogicRegSlc") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_WriteLogicRegSlc_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_WriteLogicRegSlc failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_LoopEnable(const bool bEnable)
{
  int32_t seqid = send_DBG_LoopEnable(bEnable);
  return recv_DBG_LoopEnable(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_LoopEnable(const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_LoopEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_LoopEnable_pargs args;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_LoopEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_LoopEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_LoopEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_LoopEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_LoopInterval(const int32_t uiInterval)
{
  int32_t seqid = send_DBG_LoopInterval(uiInterval);
  return recv_DBG_LoopInterval(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_LoopInterval(const int32_t uiInterval)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_LoopInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_LoopInterval_pargs args;
  args.uiInterval = &uiInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_LoopInterval(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_LoopInterval") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_LoopInterval_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_LoopInterval failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_IdleEnable(const bool bEnable)
{
  int32_t seqid = send_DBG_IdleEnable(bEnable);
  return recv_DBG_IdleEnable(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_IdleEnable(const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_IdleEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_IdleEnable_pargs args;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_IdleEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_IdleEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_IdleEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_IdleEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_ApsdEnable(const int32_t iIndex, const bool bEnable)
{
  int32_t seqid = send_DBG_ApsdEnable(iIndex, bEnable);
  return recv_DBG_ApsdEnable(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_ApsdEnable(const int32_t iIndex, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_ApsdEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ApsdEnable_pargs args;
  args.iIndex = &iIndex;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_ApsdEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_ApsdEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_ApsdEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ApsdEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_GetAprStatus(i8_rsp& _return, const int32_t uiIndex)
{
  int32_t seqid = send_DBG_GetAprStatus(uiIndex);
  recv_DBG_GetAprStatus(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_GetAprStatus(const int32_t uiIndex)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_GetAprStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_GetAprStatus_pargs args;
  args.uiIndex = &uiIndex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_GetAprStatus(i8_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_GetAprStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_GetAprStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_GetAprStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_SpiSendCommand(binary_rsp& _return, const int32_t ulChip, const std::string& pucBufW, const int32_t ulLen)
{
  int32_t seqid = send_DBG_SpiSendCommand(ulChip, pucBufW, ulLen);
  recv_DBG_SpiSendCommand(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_SpiSendCommand(const int32_t ulChip, const std::string& pucBufW, const int32_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_SpiSendCommand", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SpiSendCommand_pargs args;
  args.ulChip = &ulChip;
  args.pucBufW = &pucBufW;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_SpiSendCommand(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_SpiSendCommand") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_SpiSendCommand_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SpiSendCommand failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_SpiFlashRead(binary_rsp& _return, const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t seqid = send_DBG_SpiFlashRead(ulChip, ulAddr, ulLen);
  recv_DBG_SpiFlashRead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_SpiFlashRead(const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_SpiFlashRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SpiFlashRead_pargs args;
  args.ulChip = &ulChip;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_SpiFlashRead(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_SpiFlashRead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_SpiFlashRead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SpiFlashRead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_SpiFlashWrite(const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t seqid = send_DBG_SpiFlashWrite(ulChip, ulAddr, ulLen, pucVal);
  return recv_DBG_SpiFlashWrite(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_SpiFlashWrite(const int64_t ulChip, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_SpiFlashWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SpiFlashWrite_pargs args;
  args.ulChip = &ulChip;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_SpiFlashWrite(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_SpiFlashWrite") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_SpiFlashWrite_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SpiFlashWrite failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_MdioRead(i16_rsp& _return, const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t seqid = send_DBG_MdioRead(uiIdx, ulPhyAddr, ulRegAddr);
  recv_DBG_MdioRead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_MdioRead(const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_MdioRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_MdioRead_pargs args;
  args.uiIdx = &uiIdx;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_MdioRead(i16_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_MdioRead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_MdioRead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_MdioRead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_MdioWrite(const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t seqid = send_DBG_MdioWrite(uiIdx, ulPhyAddr, ulRegAddr, usData);
  return recv_DBG_MdioWrite(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_MdioWrite(const int32_t uiIdx, const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_MdioWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_MdioWrite_pargs args;
  args.uiIdx = &uiIdx;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.usData = &usData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_MdioWrite(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_MdioWrite") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_MdioWrite_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_MdioWrite failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_NetSwitchRead(i16_rsp& _return, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t seqid = send_DBG_NetSwitchRead(ulPhyAddr, ulRegAddr);
  recv_DBG_NetSwitchRead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_NetSwitchRead(const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_NetSwitchRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_NetSwitchRead_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_NetSwitchRead(i16_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_NetSwitchRead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_NetSwitchRead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_NetSwitchRead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_NetSwitchWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t seqid = send_DBG_NetSwitchWrite(ulPhyAddr, ulRegAddr, usData);
  return recv_DBG_NetSwitchWrite(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_NetSwitchWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_NetSwitchWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_NetSwitchWrite_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.usData = &usData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_NetSwitchWrite(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_NetSwitchWrite") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_NetSwitchWrite_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_NetSwitchWrite failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_SwitchPhyRead(i16_rsp& _return, const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t seqid = send_DBG_SwitchPhyRead(ulPhyAddr, ulRegAddr);
  recv_DBG_SwitchPhyRead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_SwitchPhyRead(const int32_t ulPhyAddr, const int32_t ulRegAddr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_SwitchPhyRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SwitchPhyRead_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_SwitchPhyRead(i16_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_SwitchPhyRead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_SwitchPhyRead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SwitchPhyRead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_SwitchPhyWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t seqid = send_DBG_SwitchPhyWrite(ulPhyAddr, ulRegAddr, usData);
  return recv_DBG_SwitchPhyWrite(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_SwitchPhyWrite(const int32_t ulPhyAddr, const int32_t ulRegAddr, const int16_t usData)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_SwitchPhyWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_SwitchPhyWrite_pargs args;
  args.ulPhyAddr = &ulPhyAddr;
  args.ulRegAddr = &ulRegAddr;
  args.usData = &usData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_SwitchPhyWrite(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_SwitchPhyWrite") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_SwitchPhyWrite_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_SwitchPhyWrite failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::DBG_ReadEeprom(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t seqid = send_DBG_ReadEeprom(uiIdx, ulAddr, ulLen);
  recv_DBG_ReadEeprom(_return, seqid);
}

int32_t HalApiConcurrentClient::send_DBG_ReadEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_ReadEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_ReadEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_DBG_ReadEeprom(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_ReadEeprom") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_DBG_ReadEeprom_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_ReadEeprom failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::DBG_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t seqid = send_DBG_WriteEeprom(uiIdx, ulAddr, ulLen, pucVal);
  return recv_DBG_WriteEeprom(seqid);
}

int32_t HalApiConcurrentClient::send_DBG_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("DBG_WriteEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_DBG_WriteEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_DBG_WriteEeprom(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DBG_WriteEeprom") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_DBG_WriteEeprom_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DBG_WriteEeprom failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetMfg(CMfg_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetMfg(uiDevType);
  recv_EDFA_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetMfg(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetMfg_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetStatusData(COaStatusData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetStatusData(uiDevType);
  recv_EDFA_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetStatusData(COaStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetCfgData(COaCfgData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetCfgData(uiDevType);
  recv_EDFA_GetCfgData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetCfgData(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetCfgData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetCfgData(COaCfgData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetCfgData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetCfgData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetCfgData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_GetDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t seqid = send_EDFA_GetDebugInfo(uiDevType, pcFilePath);
  return recv_EDFA_GetDebugInfo(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetDebugInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetDebugInfo_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_GetDebugInfo(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetDebugInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_GetDebugInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetDebugInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_GetMcuDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t seqid = send_EDFA_GetMcuDebugInfo(uiDevType, pcFilePath);
  return recv_EDFA_GetMcuDebugInfo(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetMcuDebugInfo(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetMcuDebugInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetMcuDebugInfo_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_GetMcuDebugInfo(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetMcuDebugInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_GetMcuDebugInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetMcuDebugInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetGainRange(const int32_t uiDevType, const int16_t sGainRange)
{
  int32_t seqid = send_EDFA_SetGainRange(uiDevType, sGainRange);
  return recv_EDFA_SetGainRange(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetGainRange(const int32_t uiDevType, const int16_t sGainRange)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetGainRange", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetGainRange_pargs args;
  args.uiDevType = &uiDevType;
  args.sGainRange = &sGainRange;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetGainRange(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetGainRange") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetGainRange_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetGainRange failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetGain(const int32_t uiDevType, const int16_t sGain)
{
  int32_t seqid = send_EDFA_SetGain(uiDevType, sGain);
  return recv_EDFA_SetGain(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetGain(const int32_t uiDevType, const int16_t sGain)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetGain", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetGain_pargs args;
  args.uiDevType = &uiDevType;
  args.sGain = &sGain;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetGain(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetGain") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetGain_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetGain failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetTilt(const int32_t uiDevType, const int16_t sTilt)
{
  int32_t seqid = send_EDFA_SetTilt(uiDevType, sTilt);
  return recv_EDFA_SetTilt(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetTilt(const int32_t uiDevType, const int16_t sTilt)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetTilt", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetTilt_pargs args;
  args.uiDevType = &uiDevType;
  args.sTilt = &sTilt;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetTilt(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetTilt") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetTilt_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetTilt failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetMode(const int32_t uiDevType, const int8_t ucMode, const int16_t sVal)
{
  int32_t seqid = send_EDFA_SetMode(uiDevType, ucMode, sVal);
  return recv_EDFA_SetMode(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetMode(const int32_t uiDevType, const int8_t ucMode, const int16_t sVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetMode_pargs args;
  args.uiDevType = &uiDevType;
  args.ucMode = &ucMode;
  args.sVal = &sVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetMode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetMode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetMode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetMode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetPumpEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_EDFA_SetPumpEnable(uiDevType, bEnable);
  return recv_EDFA_SetPumpEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetPumpEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetPumpEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetPumpEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetPumpEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetPumpEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetPumpEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetPumpEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetAprEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_EDFA_SetAprEnable(uiDevType, bEnable);
  return recv_EDFA_SetAprEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetAprEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetAprEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAprEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetAprEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetAprEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetAprEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAprEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetAutolosEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_EDFA_SetAutolosEnable(uiDevType, bEnable);
  return recv_EDFA_SetAutolosEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetAutolosEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetAutolosEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAutolosEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetAutolosEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetAutolosEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetAutolosEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAutolosEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetRxLosThr(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t seqid = send_EDFA_SetRxLosThr(uiDevType, sThr, sHys);
  return recv_EDFA_SetRxLosThr(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetRxLosThr(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetRxLosThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetRxLosThr_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetRxLosThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetRxLosThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetRxLosThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetRxLosThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetAttn(const int32_t uiDevType, const int16_t sAttn)
{
  int32_t seqid = send_EDFA_SetAttn(uiDevType, sAttn);
  return recv_EDFA_SetAttn(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetAttn(const int32_t uiDevType, const int16_t sAttn)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetAttn", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAttn_pargs args;
  args.uiDevType = &uiDevType;
  args.sAttn = &sAttn;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetAttn(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetAttn") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetAttn_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAttn failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetAttn(i16_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetAttn(uiDevType);
  recv_EDFA_GetAttn(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetAttn(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetAttn", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetAttn_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetAttn(i16_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetAttn") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetAttn_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetAttn failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t seqid = send_EDFA_Reset(uiDevType, ucResetType);
  return recv_EDFA_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Reset_pargs args;
  args.uiDevType = &uiDevType;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  int32_t seqid = send_EDFA_Upgrade(uiDevType, c_pcFilePath);
  return recv_EDFA_Upgrade(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Upgrade_pargs args;
  args.uiDevType = &uiDevType;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_Upgrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_Upgrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_Upgrade_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Upgrade failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_Swap(const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_Swap(uiDevType);
  return recv_EDFA_Swap(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_Swap(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_Swap", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Swap_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_Swap(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_Swap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_Swap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Swap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_Commit(const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_Commit(uiDevType);
  return recv_EDFA_Commit(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_Commit(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_Commit", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_Commit_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_Commit(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_Commit") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_Commit_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_Commit failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_GetUpgadeStatus(const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetUpgadeStatus(uiDevType);
  return recv_EDFA_GetUpgadeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetUpgadeStatus(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetUpgadeStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_GetUpgadeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetUpgadeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_GetUpgadeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetUpgadeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_DbgRead(binary_rsp& _return, const int32_t uiDevType, const int32_t uiLen)
{
  int32_t seqid = send_EDFA_DbgRead(uiDevType, uiLen);
  recv_EDFA_DbgRead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_DbgRead(const int32_t uiDevType, const int32_t uiLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_DbgRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_DbgRead_pargs args;
  args.uiDevType = &uiDevType;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_DbgRead(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_DbgRead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_DbgRead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_DbgRead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_DbgWrite(const int32_t uiDevType, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t seqid = send_EDFA_DbgWrite(uiDevType, pucBuf, uiLen);
  return recv_EDFA_DbgWrite(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_DbgWrite(const int32_t uiDevType, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_DbgWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_DbgWrite_pargs args;
  args.uiDevType = &uiDevType;
  args.pucBuf = &pucBuf;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_DbgWrite(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_DbgWrite") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_DbgWrite_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_DbgWrite failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetDfbEnable(const int32_t uiDevType, const bool bEnable, const int32_t iPower)
{
  int32_t seqid = send_EDFA_SetDfbEnable(uiDevType, bEnable, iPower);
  return recv_EDFA_SetDfbEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetDfbEnable(const int32_t uiDevType, const bool bEnable, const int32_t iPower)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetDfbEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetDfbEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.iPower = &iPower;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetDfbEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetDfbEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetDfbEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetDfbEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetOscEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_EDFA_SetOscEnable(uiDevType, bEnable);
  return recv_EDFA_SetOscEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetOscEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetOscEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetOscEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetOscEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetOscEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetOtdrSwitchPos(const int32_t uiDevType, const int32_t uiPos)
{
  int32_t seqid = send_EDFA_SetOtdrSwitchPos(uiDevType, uiPos);
  return recv_EDFA_SetOtdrSwitchPos(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetOtdrSwitchPos(const int32_t uiDevType, const int32_t uiPos)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetOtdrSwitchPos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOtdrSwitchPos_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPos = &uiPos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetOtdrSwitchPos(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetOtdrSwitchPos") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetOtdrSwitchPos_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOtdrSwitchPos failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetOscAddThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t seqid = send_EDFA_SetOscAddThrHys(uiDevType, sThr, sHys);
  return recv_EDFA_SetOscAddThrHys(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetOscAddThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetOscAddThrHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscAddThrHys_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetOscAddThrHys(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetOscAddThrHys") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetOscAddThrHys_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscAddThrHys failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetOscDropThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t seqid = send_EDFA_SetOscDropThrHys(uiDevType, sThr, sHys);
  return recv_EDFA_SetOscDropThrHys(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetOscDropThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetOscDropThrHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscDropThrHys_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetOscDropThrHys(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetOscDropThrHys") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetOscDropThrHys_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscDropThrHys failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetOscRxThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t seqid = send_EDFA_SetOscRxThrHys(uiDevType, sThr, sHys);
  return recv_EDFA_SetOscRxThrHys(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetOscRxThrHys(const int32_t uiDevType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetOscRxThrHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOscRxThrHys_pargs args;
  args.uiDevType = &uiDevType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetOscRxThrHys(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetOscRxThrHys") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetOscRxThrHys_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOscRxThrHys failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetApsdEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_EDFA_SetApsdEnable(uiDevType, bEnable);
  return recv_EDFA_SetApsdEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetApsdEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetApsdEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetApsdEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetApsdEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetApsdEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetApsdEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetApsdEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetApsdStatus(bool_list_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetApsdStatus(uiDevType);
  recv_EDFA_GetApsdStatus(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetApsdStatus(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetApsdStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetApsdStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetApsdStatus(bool_list_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetApsdStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetApsdStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetApsdStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetOcmAttn(i16_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetOcmAttn(uiDevType);
  recv_EDFA_GetOcmAttn(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetOcmAttn(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetOcmAttn", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetOcmAttn_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetOcmAttn(i16_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetOcmAttn") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetOcmAttn_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetOcmAttn failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetUpgState(const int32_t uiDevType, const int16_t sState)
{
  int32_t seqid = send_EDFA_SetUpgState(uiDevType, sState);
  return recv_EDFA_SetUpgState(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetUpgState(const int32_t uiDevType, const int16_t sState)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetUpgState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetUpgState_pargs args;
  args.uiDevType = &uiDevType;
  args.sState = &sState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetUpgState(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetUpgState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetUpgState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetUpgState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetLedState(const int32_t uiDevType, const int16_t sState)
{
  int32_t seqid = send_EDFA_SetLedState(uiDevType, sState);
  return recv_EDFA_SetLedState(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetLedState(const int32_t uiDevType, const int16_t sState)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetLedState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetLedState_pargs args;
  args.uiDevType = &uiDevType;
  args.sState = &sState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetLedState(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetLedState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetLedState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetLedState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetLedAlm(const int32_t uiDevType, const int16_t sState)
{
  int32_t seqid = send_EDFA_SetLedAlm(uiDevType, sState);
  return recv_EDFA_SetLedAlm(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetLedAlm(const int32_t uiDevType, const int16_t sState)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetLedAlm", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetLedAlm_pargs args;
  args.uiDevType = &uiDevType;
  args.sState = &sState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetLedAlm(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetLedAlm") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetLedAlm_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetLedAlm failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetCali(COaCaliData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetCali(uiDevType);
  recv_EDFA_GetCali(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetCali(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetCali_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetCali(COaCaliData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetOtdrCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t seqid = send_EDFA_SetOtdrCali(uiDevType, pcFilePath);
  return recv_EDFA_SetOtdrCali(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetOtdrCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetOtdrCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOtdrCali_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetOtdrCali(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetOtdrCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetOtdrCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOtdrCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetOcmCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t seqid = send_EDFA_SetOcmCali(uiDevType, pcFilePath);
  return recv_EDFA_SetOcmCali(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetOcmCali(const int32_t uiDevType, const std::string& pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetOcmCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetOcmCali_pargs args;
  args.uiDevType = &uiDevType;
  args.pcFilePath = &pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetOcmCali(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetOcmCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetOcmCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetOcmCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetManualVoaEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_EDFA_SetManualVoaEnable(uiDevType, bEnable);
  return recv_EDFA_SetManualVoaEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetManualVoaEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetManualVoaEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetManualVoaEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetManualVoaEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetManualVoaEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetManualVoaEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetManualVoaEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetPaddingVoaConfigPower(const int32_t uiDevType, const int16_t sOutPower)
{
  int32_t seqid = send_EDFA_SetPaddingVoaConfigPower(uiDevType, sOutPower);
  return recv_EDFA_SetPaddingVoaConfigPower(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetPaddingVoaConfigPower(const int32_t uiDevType, const int16_t sOutPower)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetPaddingVoaConfigPower", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetPaddingVoaConfigPower_pargs args;
  args.uiDevType = &uiDevType;
  args.sOutPower = &sOutPower;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetPaddingVoaConfigPower(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetPaddingVoaConfigPower") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetPaddingVoaConfigPower_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetPaddingVoaConfigPower failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetManualGainEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_EDFA_SetManualGainEnable(uiDevType, bEnable);
  return recv_EDFA_SetManualGainEnable(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetManualGainEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetManualGainEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetManualGainEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetManualGainEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetManualGainEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetManualGainEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetManualGainEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetThr(const int32_t uiDevType, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int16_t sHys)
{
  int32_t seqid = send_EDFA_SetThr(uiDevType, uiPortIdx, uiType, sThr, sHys);
  return recv_EDFA_SetThr(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetThr(const int32_t uiDevType, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int16_t sHys)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetThr_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetPumpCurrent(const int32_t uiDevType, const int32_t uiPumpIdx, const int16_t sCurrent)
{
  int32_t seqid = send_EDFA_SetPumpCurrent(uiDevType, uiPumpIdx, sCurrent);
  return recv_EDFA_SetPumpCurrent(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetPumpCurrent(const int32_t uiDevType, const int32_t uiPumpIdx, const int16_t sCurrent)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetPumpCurrent", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetPumpCurrent_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPumpIdx = &uiPumpIdx;
  args.sCurrent = &sCurrent;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetPumpCurrent(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetPumpCurrent") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetPumpCurrent_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetPumpCurrent failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal)
{
  int32_t seqid = send_EDFA_SetAlmMask(uiDevType, iMaskIdx, iMaskVal);
  return recv_EDFA_SetAlmMask(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetAlmMask", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetAlmMask_pargs args;
  args.uiDevType = &uiDevType;
  args.iMaskIdx = &iMaskIdx;
  args.iMaskVal = &iMaskVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetAlmMask(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetAlmMask") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetAlmMask_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetAlmMask failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetEventLog(COaEventLogAllData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetEventLog(uiDevType);
  recv_EDFA_GetEventLog(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetEventLog(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetEventLog", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetEventLog_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetEventLog(COaEventLogAllData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetEventLog") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetEventLog_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetEventLog failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EDFA_SetShutterState(const int32_t uiDevType, const bool block)
{
  int32_t seqid = send_EDFA_SetShutterState(uiDevType, block);
  return recv_EDFA_SetShutterState(seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_SetShutterState(const int32_t uiDevType, const bool block)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_SetShutterState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_SetShutterState_pargs args;
  args.uiDevType = &uiDevType;
  args.block = &block;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EDFA_SetShutterState(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_SetShutterState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EDFA_SetShutterState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_SetShutterState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EDFA_GetShutterState(bool_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_EDFA_GetShutterState(uiDevType);
  recv_EDFA_GetShutterState(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EDFA_GetShutterState(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EDFA_GetShutterState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EDFA_GetShutterState_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EDFA_GetShutterState(bool_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EDFA_GetShutterState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EDFA_GetShutterState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EDFA_GetShutterState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EXTEND_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_EXTEND_GetMfg(uiDevIdx);
  recv_EXTEND_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EXTEND_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EXTEND_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EXTEND_GetStatusData(CExtendStatusData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_EXTEND_GetStatusData(uiDevIdx);
  recv_EXTEND_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EXTEND_GetStatusData(CExtendStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EXTEND_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EXTEND_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t seqid = send_EXTEND_Reset(uiDevIdx, ucResetType);
  return recv_EXTEND_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EXTEND_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EXTEND_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EXTEND_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t seqid = send_EXTEND_Upgrade(uiDevIdx, c_pcFilePath);
  return recv_EXTEND_Upgrade(seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_Upgrade_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EXTEND_Upgrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_Upgrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EXTEND_Upgrade_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_Upgrade failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EXTEND_GetUpgadeStatus(const int32_t uiDevIdx)
{
  int32_t seqid = send_EXTEND_GetUpgadeStatus(uiDevIdx);
  return recv_EXTEND_GetUpgadeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_GetUpgadeStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_GetUpgadeStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EXTEND_GetUpgadeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_GetUpgadeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EXTEND_GetUpgadeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_GetUpgadeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::EXTEND_DbgRead(binary_rsp& _return, const int32_t uiDevIdx, const int32_t uiLen)
{
  int32_t seqid = send_EXTEND_DbgRead(uiDevIdx, uiLen);
  recv_EXTEND_DbgRead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_DbgRead(const int32_t uiDevIdx, const int32_t uiLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_DbgRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_DbgRead_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_EXTEND_DbgRead(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_DbgRead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_EXTEND_DbgRead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_DbgRead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EXTEND_DbgWrite(const int32_t uiDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t seqid = send_EXTEND_DbgWrite(uiDevIdx, pucBuf, uiLen);
  return recv_EXTEND_DbgWrite(seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_DbgWrite(const int32_t uiDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_DbgWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_DbgWrite_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pucBuf = &pucBuf;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EXTEND_DbgWrite(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_DbgWrite") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EXTEND_DbgWrite_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_DbgWrite failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::EXTEND_SetSfp(const int32_t uiDevIdx, const int32_t ulVal)
{
  int32_t seqid = send_EXTEND_SetSfp(uiDevIdx, ulVal);
  return recv_EXTEND_SetSfp(seqid);
}

int32_t HalApiConcurrentClient::send_EXTEND_SetSfp(const int32_t uiDevIdx, const int32_t ulVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("EXTEND_SetSfp", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_EXTEND_SetSfp_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ulVal = &ulVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_EXTEND_SetSfp(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("EXTEND_SetSfp") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_EXTEND_SetSfp_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "EXTEND_SetSfp failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::MIRROR_GetStatusData(CMirrorData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_MIRROR_GetStatusData(uiDevIdx);
  recv_MIRROR_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_MIRROR_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MIRROR_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MIRROR_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_MIRROR_GetStatusData(CMirrorData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MIRROR_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_MIRROR_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MIRROR_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SWITCH_Pos(const int32_t uiDevIdx, const int32_t uiPort)
{
  int32_t seqid = send_SWITCH_Pos(uiDevIdx, uiPort);
  return recv_SWITCH_Pos(seqid);
}

int32_t HalApiConcurrentClient::send_SWITCH_Pos(const int32_t uiDevIdx, const int32_t uiPort)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SWITCH_Pos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SWITCH_Pos_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPort = &uiPort;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SWITCH_Pos(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SWITCH_Pos") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SWITCH_Pos_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SWITCH_Pos failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::MUX_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_MUX_GetMfg(uiDevIdx);
  recv_MUX_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_MUX_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MUX_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MUX_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_MUX_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MUX_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_MUX_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MUX_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::MUX_GetStatusData(CMuxStatusData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_MUX_GetStatusData(uiDevIdx);
  recv_MUX_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_MUX_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MUX_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MUX_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_MUX_GetStatusData(CMuxStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MUX_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_MUX_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MUX_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::MUX_GetCali(CMuxCaliData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_MUX_GetCali(uiDevIdx);
  recv_MUX_GetCali(_return, seqid);
}

int32_t HalApiConcurrentClient::send_MUX_GetCali(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("MUX_GetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_MUX_GetCali_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_MUX_GetCali(CMuxCaliData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MUX_GetCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_MUX_GetCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "MUX_GetCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCM_GetMfg(CMfg_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OCM_GetMfg(uiDevType);
  recv_OCM_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetMfg(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetMfg_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCM_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCM_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCM_GetStatusData(COcmStatusData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OCM_GetStatusData(uiDevType);
  recv_OCM_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCM_GetStatusData(COcmStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCM_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCM_GetChPower(COcmChPower_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t seqid = send_OCM_GetChPower(uiDevType, uiPortId);
  recv_OCM_GetChPower(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetChPower(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetChPower", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetChPower_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCM_GetChPower(COcmChPower_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetChPower") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCM_GetChPower_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetChPower failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCM_GetOsaData(COcmOsa_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t seqid = send_OCM_GetOsaData(uiDevType, uiPortId);
  recv_OCM_GetOsaData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetOsaData(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetOsaData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetOsaData_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCM_GetOsaData(COcmOsa_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetOsaData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCM_GetOsaData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetOsaData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCM_GetRealTimeOsaData(COcmOsa_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t seqid = send_OCM_GetRealTimeOsaData(uiDevType, uiPortId);
  recv_OCM_GetRealTimeOsaData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetRealTimeOsaData(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetRealTimeOsaData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetRealTimeOsaData_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCM_GetRealTimeOsaData(COcmOsa_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetRealTimeOsaData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCM_GetRealTimeOsaData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetRealTimeOsaData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCM_SetWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<CWavePlanSlice_t> & pstWavePlan)
{
  int32_t seqid = send_OCM_SetWaveplan(uiDevType, uiPortId, uiChCnt, pstWavePlan);
  return recv_OCM_SetWaveplan(seqid);
}

int32_t HalApiConcurrentClient::send_OCM_SetWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<CWavePlanSlice_t> & pstWavePlan)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_SetWaveplan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_SetWaveplan_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.uiChCnt = &uiChCnt;
  args.pstWavePlan = &pstWavePlan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCM_SetWaveplan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_SetWaveplan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCM_SetWaveplan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_SetWaveplan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCM_SetOcmWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<STChannelGrid_t> & pstWavePlan)
{
  int32_t seqid = send_OCM_SetOcmWaveplan(uiDevType, uiPortId, uiChCnt, pstWavePlan);
  return recv_OCM_SetOcmWaveplan(seqid);
}

int32_t HalApiConcurrentClient::send_OCM_SetOcmWaveplan(const int32_t uiDevType, const int32_t uiPortId, const int32_t uiChCnt, const std::vector<STChannelGrid_t> & pstWavePlan)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_SetOcmWaveplan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_SetOcmWaveplan_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.uiChCnt = &uiChCnt;
  args.pstWavePlan = &pstWavePlan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCM_SetOcmWaveplan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_SetOcmWaveplan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCM_SetOcmWaveplan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_SetOcmWaveplan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCM_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t seqid = send_OCM_Reset(uiDevType, ucResetType);
  return recv_OCM_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_OCM_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_Reset_pargs args;
  args.uiDevType = &uiDevType;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCM_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCM_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCM_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  int32_t seqid = send_OCM_Upgrade(uiDevType, c_pcFilePath);
  return recv_OCM_Upgrade(seqid);
}

int32_t HalApiConcurrentClient::send_OCM_Upgrade(const int32_t uiDevType, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_Upgrade_pargs args;
  args.uiDevType = &uiDevType;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCM_Upgrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_Upgrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCM_Upgrade_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_Upgrade failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCM_Commit(const int32_t uiDevType)
{
  int32_t seqid = send_OCM_Commit(uiDevType);
  return recv_OCM_Commit(seqid);
}

int32_t HalApiConcurrentClient::send_OCM_Commit(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_Commit", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_Commit_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCM_Commit(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_Commit") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCM_Commit_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_Commit failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCM_GetUpgradeStatus(const int32_t uiDevType)
{
  int32_t seqid = send_OCM_GetUpgradeStatus(uiDevType);
  return recv_OCM_GetUpgradeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetUpgradeStatus(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetUpgradeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetUpgradeStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCM_GetUpgradeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetUpgradeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCM_GetUpgradeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetUpgradeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCM_SetVoa(const int32_t uiDevType, const int16_t sAttn)
{
  int32_t seqid = send_OCM_SetVoa(uiDevType, sAttn);
  return recv_OCM_SetVoa(seqid);
}

int32_t HalApiConcurrentClient::send_OCM_SetVoa(const int32_t uiDevType, const int16_t sAttn)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_SetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_SetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.sAttn = &sAttn;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCM_SetVoa(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_SetVoa") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCM_SetVoa_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_SetVoa failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCM_GetVoa(i16_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OCM_GetVoa(uiDevType);
  recv_OCM_GetVoa(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetVoa(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCM_GetVoa(i16_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetVoa") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCM_GetVoa_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetVoa failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCM_GetVoaPd(i16_list_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OCM_GetVoaPd(uiDevType);
  recv_OCM_GetVoaPd(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCM_GetVoaPd(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCM_GetVoaPd", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCM_GetVoaPd_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCM_GetVoaPd(i16_list_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCM_GetVoaPd") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCM_GetVoaPd_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCM_GetVoaPd failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCS_GetMfg(CMfg_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OCS_GetMfg(uiDevType);
  recv_OCS_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCS_GetMfg(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_GetMfg_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCS_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCS_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OCS_GetStatusData(COcsStatusData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OCS_GetStatusData(uiDevType);
  recv_OCS_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OCS_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OCS_GetStatusData(COcsStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OCS_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCS_SetConnection(const int32_t uiDevType, const COcsConnection_t& pstConnection)
{
  int32_t seqid = send_OCS_SetConnection(uiDevType, pstConnection);
  return recv_OCS_SetConnection(seqid);
}

int32_t HalApiConcurrentClient::send_OCS_SetConnection(const int32_t uiDevType, const COcsConnection_t& pstConnection)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_SetConnection", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetConnection_pargs args;
  args.uiDevType = &uiDevType;
  args.pstConnection = &pstConnection;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCS_SetConnection(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_SetConnection") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCS_SetConnection_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetConnection failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCS_SetConnections(const int32_t uiDevType, const COcsConnections_t& pstConnections)
{
  int32_t seqid = send_OCS_SetConnections(uiDevType, pstConnections);
  return recv_OCS_SetConnections(seqid);
}

int32_t HalApiConcurrentClient::send_OCS_SetConnections(const int32_t uiDevType, const COcsConnections_t& pstConnections)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_SetConnections", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetConnections_pargs args;
  args.uiDevType = &uiDevType;
  args.pstConnections = &pstConnections;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCS_SetConnections(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_SetConnections") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCS_SetConnections_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetConnections failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCS_SetLedState(const int32_t uiDevType, const int32_t index, const int32_t uiState)
{
  int32_t seqid = send_OCS_SetLedState(uiDevType, index, uiState);
  return recv_OCS_SetLedState(seqid);
}

int32_t HalApiConcurrentClient::send_OCS_SetLedState(const int32_t uiDevType, const int32_t index, const int32_t uiState)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_SetLedState", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetLedState_pargs args;
  args.uiDevType = &uiDevType;
  args.index = &index;
  args.uiState = &uiState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCS_SetLedState(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_SetLedState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCS_SetLedState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetLedState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCS_SetLedMode(const int32_t uiDevType, const int32_t uiMode)
{
  int32_t seqid = send_OCS_SetLedMode(uiDevType, uiMode);
  return recv_OCS_SetLedMode(seqid);
}

int32_t HalApiConcurrentClient::send_OCS_SetLedMode(const int32_t uiDevType, const int32_t uiMode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_SetLedMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_SetLedMode_pargs args;
  args.uiDevType = &uiDevType;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCS_SetLedMode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_SetLedMode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCS_SetLedMode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_SetLedMode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCS_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t seqid = send_OCS_Reset(uiDevType, ucResetType);
  return recv_OCS_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_OCS_Reset(const int32_t uiDevType, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_Reset_pargs args;
  args.uiDevType = &uiDevType;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCS_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCS_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCS_Upgrade(const int32_t uiDevType, const std::string& pcPath)
{
  int32_t seqid = send_OCS_Upgrade(uiDevType, pcPath);
  return recv_OCS_Upgrade(seqid);
}

int32_t HalApiConcurrentClient::send_OCS_Upgrade(const int32_t uiDevType, const std::string& pcPath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_Upgrade_pargs args;
  args.uiDevType = &uiDevType;
  args.pcPath = &pcPath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCS_Upgrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_Upgrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCS_Upgrade_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_Upgrade failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OCS_GetUpgradeStatus(const int32_t uiDevType)
{
  int32_t seqid = send_OCS_GetUpgradeStatus(uiDevType);
  return recv_OCS_GetUpgradeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_OCS_GetUpgradeStatus(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OCS_GetUpgradeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OCS_GetUpgradeStatus_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OCS_GetUpgradeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OCS_GetUpgradeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OCS_GetUpgradeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OCS_GetUpgradeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_OPS_GetMfg(uiDevIdx);
  recv_OPS_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetCommStatusData(COpsCommStatusData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_OPS_GetCommStatusData(uiDevIdx);
  recv_OPS_GetCommStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetCommStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetCommStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetCommStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetCommStatusData(COpsCommStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetCommStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetCommStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetCommStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetCfgData(COpsCfgData_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_GetCfgData(uiDevIdx, uiPortId);
  recv_OPS_GetCfgData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetCfgData(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetCfgData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetCfgData(COpsCfgData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetCfgData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetCfgData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetCfgData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetStatusData(COpsStatusData_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_GetStatusData(uiDevIdx, uiPortId);
  recv_OPS_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetStatusData(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetStatusData(COpsStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetHistoryData(COpsHistoryData_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_GetHistoryData(uiDevIdx, uiPortId);
  recv_OPS_GetHistoryData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetHistoryData(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetHistoryData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetHistoryData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetHistoryData(COpsHistoryData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetHistoryData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetHistoryData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetHistoryData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetLedStatus(COpsLed_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_OPS_GetLedStatus(uiDevIdx);
  recv_OPS_GetLedStatus(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetLedStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetLedStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetLedStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetLedStatus(COpsLed_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetLedStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetLedStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetLedStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_ClearAlarmDuration(const int32_t uiDevIdx)
{
  int32_t seqid = send_OPS_ClearAlarmDuration(uiDevIdx);
  return recv_OPS_ClearAlarmDuration(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_ClearAlarmDuration(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_ClearAlarmDuration", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_ClearAlarmDuration_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_ClearAlarmDuration(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_ClearAlarmDuration") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_ClearAlarmDuration_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_ClearAlarmDuration failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetThrPwrDiff(const int32_t uiDevIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetThrPwrDiff(uiDevIdx, sThr, sHys, uiPortId);
  return recv_OPS_SetThrPwrDiff(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetThrPwrDiff(const int32_t uiDevIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetThrPwrDiff", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetThrPwrDiff_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetThrPwrDiff(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetThrPwrDiff") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetThrPwrDiff_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetThrPwrDiff failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetThrLine(const int32_t uiDevIdx, const int32_t uiPortIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetThrLine(uiDevIdx, uiPortIdx, sThr, sHys, uiPortId);
  return recv_OPS_SetThrLine(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetThrLine(const int32_t uiDevIdx, const int32_t uiPortIdx, const int16_t sThr, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetThrLine", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetThrLine_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.sThr = &sThr;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetThrLine(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetThrLine") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetThrLine_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetThrLine failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetPortPowerThr(uiDevIdx, uiPortIdx, uiType, sThr, uiPortId);
  return recv_OPS_SetPortPowerThr(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetPortPowerThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetPortPowerThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetPortPowerThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetPortPowerThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetPortPowerThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetPortPowerThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetPortPowerHys(uiDevIdx, uiPortIdx, uiType, sHys, uiPortId);
  return recv_OPS_SetPortPowerHys(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetPortPowerHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetPortPowerHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetPortPowerHys(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetPortPowerHys") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetPortPowerHys_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetPortPowerHys failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetWtr(const int32_t uiDevIdx, const int32_t uiWtr, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetWtr(uiDevIdx, uiWtr, uiPortId);
  return recv_OPS_SetWtr(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetWtr(const int32_t uiDevIdx, const int32_t uiWtr, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetWtr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetWtr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiWtr = &uiWtr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetWtr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetWtr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetWtr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetWtr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetHoldOffTime(const int32_t uiDevIdx, const int32_t uiHoldOffTime, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetHoldOffTime(uiDevIdx, uiHoldOffTime, uiPortId);
  return recv_OPS_SetHoldOffTime(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetHoldOffTime(const int32_t uiDevIdx, const int32_t uiHoldOffTime, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetHoldOffTime", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetHoldOffTime_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiHoldOffTime = &uiHoldOffTime;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetHoldOffTime(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetHoldOffTime") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetHoldOffTime_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetHoldOffTime failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetRevertive(const int32_t uiDevIdx, const bool bRevertive, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetRevertive(uiDevIdx, bRevertive, uiPortId);
  return recv_OPS_SetRevertive(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetRevertive(const int32_t uiDevIdx, const bool bRevertive, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetRevertive", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRevertive_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.bRevertive = &bRevertive;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetRevertive(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetRevertive") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetRevertive_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRevertive failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetMode(const int32_t uiDevIdx, const int32_t uiMode, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetMode(uiDevIdx, uiMode, uiPortId);
  return recv_OPS_SetMode(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetMode(const int32_t uiDevIdx, const int32_t uiMode, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetMode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetMode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetMode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetMode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetRelativeThr(const int32_t uiDevIdx, const int16_t sThr, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetRelativeThr(uiDevIdx, sThr, uiPortId);
  return recv_OPS_SetRelativeThr(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetRelativeThr(const int32_t uiDevIdx, const int16_t sThr, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetRelativeThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRelativeThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.sThr = &sThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetRelativeThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetRelativeThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetRelativeThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRelativeThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetRelativeOffset(const int32_t uiDevIdx, const int16_t sOffset, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetRelativeOffset(uiDevIdx, sOffset, uiPortId);
  return recv_OPS_SetRelativeOffset(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetRelativeOffset(const int32_t uiDevIdx, const int16_t sOffset, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetRelativeOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRelativeOffset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.sOffset = &sOffset;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetRelativeOffset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetRelativeOffset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetRelativeOffset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRelativeOffset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetSwitchThr(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iThr, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetSwitchThr(uiDevIdx, uiPos, iThr, uiPortId);
  return recv_OPS_SetSwitchThr(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetSwitchThr(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iThr, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetSwitchThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetSwitchThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPos = &uiPos;
  args.iThr = &iThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetSwitchThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetSwitchThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetSwitchThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetSwitchThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetSwitchHys(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iHys, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetSwitchHys(uiDevIdx, uiPos, iHys, uiPortId);
  return recv_OPS_SetSwitchHys(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetSwitchHys(const int32_t uiDevIdx, const int32_t uiPos, const int32_t iHys, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetSwitchHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetSwitchHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPos = &uiPos;
  args.iHys = &iHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetSwitchHys(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetSwitchHys") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetSwitchHys_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetSwitchHys failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t seqid = send_OPS_Reset(uiDevIdx, ucResetType);
  return recv_OPS_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t seqid = send_OPS_Upgrade(uiDevIdx, c_pcFilePath);
  return recv_OPS_Upgrade(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_Upgrade_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_Upgrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_Upgrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_Upgrade_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_Upgrade failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_GetUpgadeStatus(const int32_t uiDevIdx)
{
  int32_t seqid = send_OPS_GetUpgadeStatus(uiDevIdx);
  return recv_OPS_GetUpgadeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetUpgadeStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetUpgadeStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_GetUpgadeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetUpgadeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_GetUpgadeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetUpgadeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t seqid = send_OPS_SetLedDebugMode(uiDevIdx, uiMode);
  return recv_OPS_SetLedDebugMode(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetLedDebugMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetLedDebugMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetLedDebugMode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetLedDebugMode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetLedDebugMode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetLedDebugMode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  int32_t seqid = send_OPS_SetLedStatus(uiDevIdx, uiLedIdx, uiStatus);
  return recv_OPS_SetLedStatus(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetLedStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetLedStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiLedIdx = &uiLedIdx;
  args.uiStatus = &uiStatus;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetLedStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetLedStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetLedStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetLedStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetConnectionPdThr(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetConnectionPdThr(uiDevIdx, uiPdIdx, uiType, sThr, uiPortId);
  return recv_OPS_SetConnectionPdThr(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetConnectionPdThr(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sThr, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetConnectionPdThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetConnectionPdThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPdIdx = &uiPdIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetConnectionPdThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetConnectionPdThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetConnectionPdThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetConnectionPdThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetConnectionPdHys(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetConnectionPdHys(uiDevIdx, uiPdIdx, uiType, sHys, uiPortId);
  return recv_OPS_SetConnectionPdHys(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetConnectionPdHys(const int32_t uiDevIdx, const int32_t uiPdIdx, const int32_t uiType, const int16_t sHys, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetConnectionPdHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetConnectionPdHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPdIdx = &uiPdIdx;
  args.uiType = &uiType;
  args.sHys = &sHys;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetConnectionPdHys(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetConnectionPdHys") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetConnectionPdHys_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetConnectionPdHys failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetAlmMask(uiDevType, iMaskIdx, iMaskVal, uiPortId);
  return recv_OPS_SetAlmMask(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetAlmMask(const int32_t uiDevType, const int32_t iMaskIdx, const int32_t iMaskVal, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetAlmMask", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetAlmMask_pargs args;
  args.uiDevType = &uiDevType;
  args.iMaskIdx = &iMaskIdx;
  args.iMaskVal = &iMaskVal;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetAlmMask(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetAlmMask") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetAlmMask_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetAlmMask failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetEventLog(COpsEventLogAllData_rsp& _return, const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_GetEventLog(uiDevType, uiPortId);
  recv_OPS_GetEventLog(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetEventLog(const int32_t uiDevType, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetEventLog", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetEventLog_pargs args;
  args.uiDevType = &uiDevType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetEventLog(COpsEventLogAllData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetEventLog") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetEventLog_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetEventLog failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetRemoteStatus(const int32_t uiDevIdx, const COpsReqStatus_t& pstStatus, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetRemoteStatus(uiDevIdx, pstStatus, uiPortId);
  return recv_OPS_SetRemoteStatus(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetRemoteStatus(const int32_t uiDevIdx, const COpsReqStatus_t& pstStatus, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetRemoteStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetRemoteStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pstStatus = &pstStatus;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetRemoteStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetRemoteStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetRemoteStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetRemoteStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetRequestStatus(COpsBidirectionStatus_rsp& _return, const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_GetRequestStatus(uiDevIdx, uiPortId);
  recv_OPS_GetRequestStatus(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetRequestStatus(const int32_t uiDevIdx, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetRequestStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetRequestStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetRequestStatus(COpsBidirectionStatus_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetRequestStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetRequestStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetRequestStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OPS_SetSwitchingType(const int32_t uiDevIdx, const int8_t ucType, const int32_t uiPortId)
{
  int32_t seqid = send_OPS_SetSwitchingType(uiDevIdx, ucType, uiPortId);
  return recv_OPS_SetSwitchingType(seqid);
}

int32_t HalApiConcurrentClient::send_OPS_SetSwitchingType(const int32_t uiDevIdx, const int8_t ucType, const int32_t uiPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_SetSwitchingType", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_SetSwitchingType_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucType = &ucType;
  args.uiPortId = &uiPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OPS_SetSwitchingType(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_SetSwitchingType") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OPS_SetSwitchingType_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_SetSwitchingType failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OPS_GetOpsDevIdByKey(i32_list_rsp& _return, const std::string& pcName)
{
  int32_t seqid = send_OPS_GetOpsDevIdByKey(pcName);
  recv_OPS_GetOpsDevIdByKey(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OPS_GetOpsDevIdByKey(const std::string& pcName)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OPS_GetOpsDevIdByKey", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OPS_GetOpsDevIdByKey_pargs args;
  args.pcName = &pcName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OPS_GetOpsDevIdByKey(i32_list_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OPS_GetOpsDevIdByKey") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OPS_GetOpsDevIdByKey_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OPS_GetOpsDevIdByKey failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OSC_GetStatusData(COscStatusData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OSC_GetStatusData(uiDevType);
  recv_OSC_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OSC_GetStatusData(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OSC_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetStatusData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OSC_GetStatusData(COscStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OSC_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OSC_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OSC_GetCfgData(COscCfgData_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OSC_GetCfgData(uiDevType);
  recv_OSC_GetCfgData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OSC_GetCfgData(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OSC_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetCfgData_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OSC_GetCfgData(COscCfgData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OSC_GetCfgData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OSC_GetCfgData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetCfgData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OSC_SetEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t seqid = send_OSC_SetEnable(uiDevType, bEnable);
  return recv_OSC_SetEnable(seqid);
}

int32_t HalApiConcurrentClient::send_OSC_SetEnable(const int32_t uiDevType, const bool bEnable)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OSC_SetEnable", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_SetEnable_pargs args;
  args.uiDevType = &uiDevType;
  args.bEnable = &bEnable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OSC_SetEnable(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OSC_SetEnable") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OSC_SetEnable_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_SetEnable failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OSC_SetVoa(const int32_t uiDevType, const int32_t uiTxRx, const int16_t sAttn)
{
  int32_t seqid = send_OSC_SetVoa(uiDevType, uiTxRx, sAttn);
  return recv_OSC_SetVoa(seqid);
}

int32_t HalApiConcurrentClient::send_OSC_SetVoa(const int32_t uiDevType, const int32_t uiTxRx, const int16_t sAttn)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OSC_SetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_SetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.uiTxRx = &uiTxRx;
  args.sAttn = &sAttn;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OSC_SetVoa(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OSC_SetVoa") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OSC_SetVoa_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_SetVoa failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OSC_GetVoa(i16_rsp& _return, const int32_t uiDevType, const int32_t uiTxRx)
{
  int32_t seqid = send_OSC_GetVoa(uiDevType, uiTxRx);
  recv_OSC_GetVoa(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OSC_GetVoa(const int32_t uiDevType, const int32_t uiTxRx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OSC_GetVoa", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetVoa_pargs args;
  args.uiDevType = &uiDevType;
  args.uiTxRx = &uiTxRx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OSC_GetVoa(i16_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OSC_GetVoa") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OSC_GetVoa_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetVoa failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OSC_SetSwitchPos(const int32_t uiDevType, const COscSwitchPosSet_t& rstSwitchPos)
{
  int32_t seqid = send_OSC_SetSwitchPos(uiDevType, rstSwitchPos);
  return recv_OSC_SetSwitchPos(seqid);
}

int32_t HalApiConcurrentClient::send_OSC_SetSwitchPos(const int32_t uiDevType, const COscSwitchPosSet_t& rstSwitchPos)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OSC_SetSwitchPos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_SetSwitchPos_pargs args;
  args.uiDevType = &uiDevType;
  args.rstSwitchPos = &rstSwitchPos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OSC_SetSwitchPos(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OSC_SetSwitchPos") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OSC_SetSwitchPos_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_SetSwitchPos failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OSC_GetSwitchPos(COscSwitchPos_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OSC_GetSwitchPos(uiDevType);
  recv_OSC_GetSwitchPos(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OSC_GetSwitchPos(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OSC_GetSwitchPos", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OSC_GetSwitchPos_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OSC_GetSwitchPos(COscSwitchPos_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OSC_GetSwitchPos") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OSC_GetSwitchPos_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OSC_GetSwitchPos failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OTDR_GetMfg(CMfg_rsp& _return, const int32_t ulDevIdx)
{
  int32_t seqid = send_OTDR_GetMfg(ulDevIdx);
  recv_OTDR_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_GetMfg(const int32_t ulDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetMfg_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OTDR_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OTDR_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OTDR_GetStatusData(COtdrStatusData_rsp& _return, const int32_t ulDevIdx)
{
  int32_t seqid = send_OTDR_GetStatusData(ulDevIdx);
  recv_OTDR_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_GetStatusData(const int32_t ulDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetStatusData_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OTDR_GetStatusData(COtdrStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OTDR_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OTDR_GetCfgData(COtdrCfgData_rsp& _return, const int32_t ulDevIdx)
{
  int32_t seqid = send_OTDR_GetCfgData(ulDevIdx);
  recv_OTDR_GetCfgData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_GetCfgData(const int32_t ulDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetCfgData_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OTDR_GetCfgData(COtdrCfgData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_GetCfgData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OTDR_GetCfgData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetCfgData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_StartScan(const int32_t ulDevIdx)
{
  int32_t seqid = send_OTDR_StartScan(ulDevIdx);
  return recv_OTDR_StartScan(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_StartScan(const int32_t ulDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_StartScan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_StartScan_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_StartScan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_StartScan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_StartScan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_StartScan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_SetPara(const int32_t ulDevIdx, const int32_t ulDistRang, const int32_t ulPulseWidth, const double dSamplingResolution)
{
  int32_t seqid = send_OTDR_SetPara(ulDevIdx, ulDistRang, ulPulseWidth, dSamplingResolution);
  return recv_OTDR_SetPara(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_SetPara(const int32_t ulDevIdx, const int32_t ulDistRang, const int32_t ulPulseWidth, const double dSamplingResolution)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_SetPara", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetPara_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ulDistRang = &ulDistRang;
  args.ulPulseWidth = &ulPulseWidth;
  args.dSamplingResolution = &dSamplingResolution;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_SetPara(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_SetPara") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_SetPara_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetPara failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_SetMeasuringTime(const int32_t ulDevIdx, const int32_t ulMeasuringTime)
{
  int32_t seqid = send_OTDR_SetMeasuringTime(ulDevIdx, ulMeasuringTime);
  return recv_OTDR_SetMeasuringTime(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_SetMeasuringTime(const int32_t ulDevIdx, const int32_t ulMeasuringTime)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_SetMeasuringTime", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetMeasuringTime_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ulMeasuringTime = &ulMeasuringTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_SetMeasuringTime(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_SetMeasuringTime") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_SetMeasuringTime_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetMeasuringTime failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_SetUserIOR(const int32_t ulDevIdx, const double dUserIOR)
{
  int32_t seqid = send_OTDR_SetUserIOR(ulDevIdx, dUserIOR);
  return recv_OTDR_SetUserIOR(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_SetUserIOR(const int32_t ulDevIdx, const double dUserIOR)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_SetUserIOR", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetUserIOR_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.dUserIOR = &dUserIOR;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_SetUserIOR(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_SetUserIOR") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_SetUserIOR_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetUserIOR failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_SetThr(const int32_t ulDevIdx, const double dRefThr, const double dSpliceLosThr, const double dFiberEndThr)
{
  int32_t seqid = send_OTDR_SetThr(ulDevIdx, dRefThr, dSpliceLosThr, dFiberEndThr);
  return recv_OTDR_SetThr(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_SetThr(const int32_t ulDevIdx, const double dRefThr, const double dSpliceLosThr, const double dFiberEndThr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_SetThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetThr_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.dRefThr = &dRefThr;
  args.dSpliceLosThr = &dSpliceLosThr;
  args.dFiberEndThr = &dFiberEndThr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_SetThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_SetThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_SetThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_Reset(const int32_t ulDevIdx, const int8_t ucResetType)
{
  int32_t seqid = send_OTDR_Reset(ulDevIdx, ucResetType);
  return recv_OTDR_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_Reset(const int32_t ulDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_Reset_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_Upgrade(const int32_t ulDevIdx, const std::string& c_pcFilePath)
{
  int32_t seqid = send_OTDR_Upgrade(ulDevIdx, c_pcFilePath);
  return recv_OTDR_Upgrade(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_Upgrade(const int32_t ulDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_Upgrade_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_Upgrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_Upgrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_Upgrade_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_Upgrade failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_GetUpgadeStatus(const int32_t ulDevIdx)
{
  int32_t seqid = send_OTDR_GetUpgadeStatus(ulDevIdx);
  return recv_OTDR_GetUpgadeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_GetUpgadeStatus(const int32_t ulDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_GetUpgadeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetUpgadeStatus_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_GetUpgadeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_GetUpgadeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_GetUpgadeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetUpgadeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OTDR_DbgRead(binary_rsp& _return, const int32_t ulDevIdx, const int32_t uiLen)
{
  int32_t seqid = send_OTDR_DbgRead(ulDevIdx, uiLen);
  recv_OTDR_DbgRead(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_DbgRead(const int32_t ulDevIdx, const int32_t uiLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_DbgRead", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_DbgRead_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OTDR_DbgRead(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_DbgRead") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OTDR_DbgRead_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_DbgRead failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_DbgWrite(const int32_t ulDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t seqid = send_OTDR_DbgWrite(ulDevIdx, pucBuf, uiLen);
  return recv_OTDR_DbgWrite(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_DbgWrite(const int32_t ulDevIdx, const std::string& pucBuf, const int32_t uiLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_DbgWrite", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_DbgWrite_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.pucBuf = &pucBuf;
  args.uiLen = &uiLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_DbgWrite(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_DbgWrite") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_DbgWrite_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_DbgWrite failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_SetScanMode(const int32_t uiDevType, const int32_t ulScanMode)
{
  int32_t seqid = send_OTDR_SetScanMode(uiDevType, ulScanMode);
  return recv_OTDR_SetScanMode(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_SetScanMode(const int32_t uiDevType, const int32_t ulScanMode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_SetScanMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetScanMode_pargs args;
  args.uiDevType = &uiDevType;
  args.ulScanMode = &ulScanMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_SetScanMode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_SetScanMode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_SetScanMode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetScanMode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_SetStartOffset(const int32_t uiDevType, const COtdrStartOffset_t& pstStartOffset)
{
  int32_t seqid = send_OTDR_SetStartOffset(uiDevType, pstStartOffset);
  return recv_OTDR_SetStartOffset(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_SetStartOffset(const int32_t uiDevType, const COtdrStartOffset_t& pstStartOffset)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_SetStartOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_SetStartOffset_pargs args;
  args.uiDevType = &uiDevType;
  args.pstStartOffset = &pstStartOffset;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_SetStartOffset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_SetStartOffset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_SetStartOffset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_SetStartOffset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::OTDR_GetStartOffset(COtdrStartOffset_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_OTDR_GetStartOffset(uiDevType);
  recv_OTDR_GetStartOffset(_return, seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_GetStartOffset(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_GetStartOffset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_GetStartOffset_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_OTDR_GetStartOffset(COtdrStartOffset_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_GetStartOffset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_OTDR_GetStartOffset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_GetStartOffset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::OTDR_StartScanPort(const int32_t ulDevIdx, const int32_t ulPortId)
{
  int32_t seqid = send_OTDR_StartScanPort(ulDevIdx, ulPortId);
  return recv_OTDR_StartScanPort(seqid);
}

int32_t HalApiConcurrentClient::send_OTDR_StartScanPort(const int32_t ulDevIdx, const int32_t ulPortId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("OTDR_StartScanPort", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_OTDR_StartScanPort_pargs args;
  args.ulDevIdx = &ulDevIdx;
  args.ulPortId = &ulPortId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_OTDR_StartScanPort(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("OTDR_StartScanPort") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_OTDR_StartScanPort_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "OTDR_StartScanPort failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::SLOT_GetDevIdx(i32_list_rsp& _return, const int32_t uiDevType)
{
  int32_t seqid = send_SLOT_GetDevIdx(uiDevType);
  recv_SLOT_GetDevIdx(_return, seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_GetDevIdx(const int32_t uiDevType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_GetDevIdx", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetDevIdx_pargs args;
  args.uiDevType = &uiDevType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_SLOT_GetDevIdx(i32_list_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_GetDevIdx") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_SLOT_GetDevIdx_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetDevIdx failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SLOT_SetOnline(const int32_t uiSlotIdx, const bool bOnline)
{
  int32_t seqid = send_SLOT_SetOnline(uiSlotIdx, bOnline);
  return recv_SLOT_SetOnline(seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_SetOnline(const int32_t uiSlotIdx, const bool bOnline)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_SetOnline", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetOnline_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.bOnline = &bOnline;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SLOT_SetOnline(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_SetOnline") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SLOT_SetOnline_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetOnline failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::SLOT_GetSlotNum(i32_rsp& _return)
{
  int32_t seqid = send_SLOT_GetSlotNum();
  recv_SLOT_GetSlotNum(_return, seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_GetSlotNum()
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_GetSlotNum", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetSlotNum_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_SLOT_GetSlotNum(i32_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_GetSlotNum") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_SLOT_GetSlotNum_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetSlotNum failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SLOT_SetMfg(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  int32_t seqid = send_SLOT_SetMfg(uiSlotIdx, c_pcFilePath);
  return recv_SLOT_SetMfg(seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_SetMfg(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_SetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetMfg_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SLOT_SetMfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_SetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SLOT_SetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::SLOT_GetMfg(CMfg_rsp& _return, const int32_t uiSlotIdx)
{
  int32_t seqid = send_SLOT_GetMfg(uiSlotIdx);
  recv_SLOT_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_GetMfg(const int32_t uiSlotIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetMfg_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_SLOT_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_SLOT_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::SLOT_GetStatusData(CSlotStatusData_rsp& _return, const int32_t uiSlotIdx)
{
  int32_t seqid = send_SLOT_GetStatusData(uiSlotIdx);
  recv_SLOT_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_GetStatusData(const int32_t uiSlotIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetStatusData_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_SLOT_GetStatusData(CSlotStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_SLOT_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SLOT_ClearPlugFlag(const int32_t uiSlotIdx)
{
  int32_t seqid = send_SLOT_ClearPlugFlag(uiSlotIdx);
  return recv_SLOT_ClearPlugFlag(seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_ClearPlugFlag(const int32_t uiSlotIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_ClearPlugFlag", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_ClearPlugFlag_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SLOT_ClearPlugFlag(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_ClearPlugFlag") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SLOT_ClearPlugFlag_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_ClearPlugFlag failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::SLOT_GetInfo(CSlotInfo_rsp& _return, const int32_t uiSlotIdx)
{
  int32_t seqid = send_SLOT_GetInfo(uiSlotIdx);
  recv_SLOT_GetInfo(_return, seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_GetInfo(const int32_t uiSlotIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_GetInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetInfo_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_SLOT_GetInfo(CSlotInfo_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_GetInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_SLOT_GetInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::SLOT_GetCali(CCali_rsp& _return, const int32_t uiSlotIdx)
{
  int32_t seqid = send_SLOT_GetCali(uiSlotIdx);
  recv_SLOT_GetCali(_return, seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_GetCali(const int32_t uiSlotIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_GetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_GetCali_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_SLOT_GetCali(CCali_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_GetCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_SLOT_GetCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_GetCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SLOT_SetCali(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  int32_t seqid = send_SLOT_SetCali(uiSlotIdx, c_pcFilePath);
  return recv_SLOT_SetCali(seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_SetCali(const int32_t uiSlotIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_SetCali", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetCali_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SLOT_SetCali(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_SetCali") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SLOT_SetCali_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetCali failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SLOT_Reset(const int32_t uiSlotIdx, const int8_t ucResetType)
{
  int32_t seqid = send_SLOT_Reset(uiSlotIdx, ucResetType);
  return recv_SLOT_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_Reset(const int32_t uiSlotIdx, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_Reset_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SLOT_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SLOT_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SLOT_SetLed(const int32_t uiSlotIdx, const int32_t uiLedIdx, const int32_t uiState)
{
  int32_t seqid = send_SLOT_SetLed(uiSlotIdx, uiLedIdx, uiState);
  return recv_SLOT_SetLed(seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_SetLed(const int32_t uiSlotIdx, const int32_t uiLedIdx, const int32_t uiState)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_SetLed", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_SetLed_pargs args;
  args.uiSlotIdx = &uiSlotIdx;
  args.uiLedIdx = &uiLedIdx;
  args.uiState = &uiState;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SLOT_SetLed(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_SetLed") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SLOT_SetLed_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_SetLed failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::SLOT_ReadEeprom(binary_rsp& _return, const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t seqid = send_SLOT_ReadEeprom(uiIdx, ulAddr, ulLen);
  recv_SLOT_ReadEeprom(_return, seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_ReadEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_ReadEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_ReadEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_SLOT_ReadEeprom(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_ReadEeprom") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_SLOT_ReadEeprom_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_ReadEeprom failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::SLOT_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t seqid = send_SLOT_WriteEeprom(uiIdx, ulAddr, ulLen, pucVal);
  return recv_SLOT_WriteEeprom(seqid);
}

int32_t HalApiConcurrentClient::send_SLOT_WriteEeprom(const int32_t uiIdx, const int64_t ulAddr, const int64_t ulLen, const std::string& pucVal)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SLOT_WriteEeprom", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_SLOT_WriteEeprom_pargs args;
  args.uiIdx = &uiIdx;
  args.ulAddr = &ulAddr;
  args.ulLen = &ulLen;
  args.pucVal = &pucVal;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_SLOT_WriteEeprom(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SLOT_WriteEeprom") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_SLOT_WriteEeprom_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SLOT_WriteEeprom failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::TDCM_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_TDCM_GetMfg(uiDevIdx);
  recv_TDCM_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_TDCM_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TDCM_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_TDCM_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TDCM_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_TDCM_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::TDCM_GetStatusData(CTdcmStatusData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_TDCM_GetStatusData(uiDevIdx);
  recv_TDCM_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_TDCM_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TDCM_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_TDCM_GetStatusData(CTdcmStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TDCM_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_TDCM_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::TDCM_GetCfgData(CTdcmCfgData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_TDCM_GetCfgData(uiDevIdx);
  recv_TDCM_GetCfgData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_TDCM_GetCfgData(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TDCM_GetCfgData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_GetCfgData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_TDCM_GetCfgData(CTdcmCfgData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TDCM_GetCfgData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_TDCM_GetCfgData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_GetCfgData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::TDCM_SetFrequency(const int32_t uiDevIdx, const double fFrequency)
{
  int32_t seqid = send_TDCM_SetFrequency(uiDevIdx, fFrequency);
  return recv_TDCM_SetFrequency(seqid);
}

int32_t HalApiConcurrentClient::send_TDCM_SetFrequency(const int32_t uiDevIdx, const double fFrequency)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TDCM_SetFrequency", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_SetFrequency_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.fFrequency = &fFrequency;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_TDCM_SetFrequency(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TDCM_SetFrequency") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_TDCM_SetFrequency_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_SetFrequency failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::TDCM_SetDispersion(const int32_t uiDevIdx, const double fDispersion)
{
  int32_t seqid = send_TDCM_SetDispersion(uiDevIdx, fDispersion);
  return recv_TDCM_SetDispersion(seqid);
}

int32_t HalApiConcurrentClient::send_TDCM_SetDispersion(const int32_t uiDevIdx, const double fDispersion)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TDCM_SetDispersion", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_SetDispersion_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.fDispersion = &fDispersion;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_TDCM_SetDispersion(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TDCM_SetDispersion") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_TDCM_SetDispersion_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_SetDispersion failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::TDCM_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t seqid = send_TDCM_Reset(uiDevIdx, ucResetType);
  return recv_TDCM_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_TDCM_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TDCM_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_TDCM_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_TDCM_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TDCM_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_TDCM_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TDCM_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::WSS_GetMfg(CMfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_WSS_GetMfg(uiDevIdx);
  recv_WSS_GetMfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetMfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetMfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetMfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_WSS_GetMfg(CMfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetMfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_WSS_GetMfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetMfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::WSS_GetCfg(CWssAllCfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_WSS_GetCfg(uiDevIdx);
  recv_WSS_GetCfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetCfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_WSS_GetCfg(CWssAllCfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetCfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_WSS_GetCfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetCfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::WSS_GetOscCfg(CWssAllCfg_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_WSS_GetOscCfg(uiDevIdx);
  recv_WSS_GetOscCfg(_return, seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetOscCfg(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetOscCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetOscCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_WSS_GetOscCfg(CWssAllCfg_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetOscCfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_WSS_GetOscCfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetOscCfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::WSS_GetStatusData(CWssStatusData_rsp& _return, const int32_t uiDevIdx)
{
  int32_t seqid = send_WSS_GetStatusData(uiDevIdx);
  recv_WSS_GetStatusData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetStatusData(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetStatusData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetStatusData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_WSS_GetStatusData(CWssStatusData_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetStatusData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_WSS_GetStatusData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetStatusData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetAllChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  int32_t seqid = send_WSS_SetAllChCfg(uiDevIdx, uiSubIdx, uiChCnt, pstWssCfg);
  return recv_WSS_SetAllChCfg(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetAllChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetAllChCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetAllChCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiSubIdx = &uiSubIdx;
  args.uiChCnt = &uiChCnt;
  args.pstWssCfg = &pstWssCfg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetAllChCfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetAllChCfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetAllChCfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetAllChCfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetOscChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  int32_t seqid = send_WSS_SetOscChCfg(uiDevIdx, uiSubIdx, uiChCnt, pstWssCfg);
  return recv_WSS_SetOscChCfg(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetOscChCfg(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWssCfg_t> & pstWssCfg)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetOscChCfg", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetOscChCfg_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiSubIdx = &uiSubIdx;
  args.uiChCnt = &uiChCnt;
  args.pstWssCfg = &pstWssCfg;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetOscChCfg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetOscChCfg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetOscChCfg_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetOscChCfg failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetWaveplan(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWavePlan_t> & pstWavePlan)
{
  int32_t seqid = send_WSS_SetWaveplan(uiDevIdx, uiSubIdx, uiChCnt, pstWavePlan);
  return recv_WSS_SetWaveplan(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetWaveplan(const int32_t uiDevIdx, const int32_t uiSubIdx, const int32_t uiChCnt, const std::vector<CWavePlan_t> & pstWavePlan)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetWaveplan", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetWaveplan_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiSubIdx = &uiSubIdx;
  args.uiChCnt = &uiChCnt;
  args.pstWavePlan = &pstWavePlan;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetWaveplan(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetWaveplan") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetWaveplan_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetWaveplan failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr)
{
  int32_t seqid = send_WSS_SetPortPowerThr(uiDevIdx, uiPortIdx, uiType, sThr);
  return recv_WSS_SetPortPowerThr(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetPortPowerThr(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sThr)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetPortPowerThr", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetPortPowerThr_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sThr = &sThr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetPortPowerThr(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetPortPowerThr") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetPortPowerThr_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetPortPowerThr failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys)
{
  int32_t seqid = send_WSS_SetPortPowerHys(uiDevIdx, uiPortIdx, uiType, sHys);
  return recv_WSS_SetPortPowerHys(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetPortPowerHys(const int32_t uiDevIdx, const int32_t uiPortIdx, const int32_t uiType, const int16_t sHys)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetPortPowerHys", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetPortPowerHys_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiPortIdx = &uiPortIdx;
  args.uiType = &uiType;
  args.sHys = &sHys;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetPortPowerHys(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetPortPowerHys") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetPortPowerHys_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetPortPowerHys failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_GetPortPowerHistory(const int32_t uiDevIdx)
{
  int32_t seqid = send_WSS_GetPortPowerHistory(uiDevIdx);
  return recv_WSS_GetPortPowerHistory(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetPortPowerHistory(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetPortPowerHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetPortPowerHistory_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_GetPortPowerHistory(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetPortPowerHistory") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_GetPortPowerHistory_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetPortPowerHistory failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetLedMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t seqid = send_WSS_SetLedMode(uiDevIdx, uiMode);
  return recv_WSS_SetLedMode(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetLedMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetLedMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetLedMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetLedMode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetLedMode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetLedMode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetLedMode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t seqid = send_WSS_SetLedDebugMode(uiDevIdx, uiMode);
  return recv_WSS_SetLedDebugMode(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetLedDebugMode(const int32_t uiDevIdx, const int32_t uiMode)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetLedDebugMode", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetLedDebugMode_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiMode = &uiMode;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetLedDebugMode(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetLedDebugMode") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetLedDebugMode_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetLedDebugMode failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  int32_t seqid = send_WSS_SetLedStatus(uiDevIdx, uiLedIdx, uiStatus);
  return recv_WSS_SetLedStatus(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetLedStatus(const int32_t uiDevIdx, const int32_t uiLedIdx, const int32_t uiStatus)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetLedStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetLedStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.uiLedIdx = &uiLedIdx;
  args.uiStatus = &uiStatus;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetLedStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetLedStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetLedStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetLedStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t seqid = send_WSS_Reset(uiDevIdx, ucResetType);
  return recv_WSS_Reset(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_Reset(const int32_t uiDevIdx, const int8_t ucResetType)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_Reset", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_Reset_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.ucResetType = &ucResetType;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_Reset(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_Reset") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_Reset_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_Reset failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t seqid = send_WSS_Upgrade(uiDevIdx, c_pcFilePath);
  return recv_WSS_Upgrade(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_Upgrade(const int32_t uiDevIdx, const std::string& c_pcFilePath)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_Upgrade", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_Upgrade_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.c_pcFilePath = &c_pcFilePath;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_Upgrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_Upgrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_Upgrade_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_Upgrade failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_GetUpgradeStatus(const int32_t uiDevIdx)
{
  int32_t seqid = send_WSS_GetUpgradeStatus(uiDevIdx);
  return recv_WSS_GetUpgradeStatus(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetUpgradeStatus(const int32_t uiDevIdx)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetUpgradeStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetUpgradeStatus_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_GetUpgradeStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetUpgradeStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_GetUpgradeStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetUpgradeStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  int32_t seqid = send_WSS_SetUserData(uiDevIdx, pucData, nLen);
  return recv_WSS_SetUserData(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pucData = &pucData;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetUserData(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetUserData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetUserData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetUserData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::WSS_GetUserData(binary_rsp& _return, const int32_t uiDevIdx, const int32_t nLen)
{
  int32_t seqid = send_WSS_GetUserData(uiDevIdx, nLen);
  recv_WSS_GetUserData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetUserData(const int32_t uiDevIdx, const int32_t nLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_WSS_GetUserData(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetUserData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_WSS_GetUserData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetUserData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int32_t HalApiConcurrentClient::WSS_SetPmUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  int32_t seqid = send_WSS_SetPmUserData(uiDevIdx, pucData, nLen);
  return recv_WSS_SetPmUserData(seqid);
}

int32_t HalApiConcurrentClient::send_WSS_SetPmUserData(const int32_t uiDevIdx, const std::string& pucData, const int32_t nLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_SetPmUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_SetPmUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.pucData = &pucData;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HalApiConcurrentClient::recv_WSS_SetPmUserData(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_SetPmUserData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HalApi_WSS_SetPmUserData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_SetPmUserData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void HalApiConcurrentClient::WSS_GetPmUserData(binary_rsp& _return, const int32_t uiDevIdx, const int32_t nLen)
{
  int32_t seqid = send_WSS_GetPmUserData(uiDevIdx, nLen);
  recv_WSS_GetPmUserData(_return, seqid);
}

int32_t HalApiConcurrentClient::send_WSS_GetPmUserData(const int32_t uiDevIdx, const int32_t nLen)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("WSS_GetPmUserData", ::apache::thrift::protocol::T_CALL, cseqid);

  HalApi_WSS_GetPmUserData_pargs args;
  args.uiDevIdx = &uiDevIdx;
  args.nLen = &nLen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HalApiConcurrentClient::recv_WSS_GetPmUserData(binary_rsp& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("WSS_GetPmUserData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HalApi_WSS_GetPmUserData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "WSS_GetPmUserData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}



